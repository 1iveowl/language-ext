using System; 
using System.Collections.Generic;
using System.Collections;
using System.Collections.Immutable;
using System.Linq;
using System.ComponentModel;
using LanguageExt;
using static LanguageExt.Prelude;

namespace LanguageExt.Trans
{
    internal static partial class HKTInternal
    {
        public static T ValueT<T>(this IEnumerable<T> self) => default(T);
        public static T ValueT<T>(this Option<T> self) => self.IsSome ? self.Value : default(T);
        public static T ValueT<T>(this OptionUnsafe<T> self) => self.IsSome ? self.Value : default(T);
        public static T ValueT<T>(this Lst<T> self) => default(T);
        public static T ValueT<K, T>(this Map<K, T> self) => default(T);
        public static T ValueT<T>(this TryOption<T> self) => self.Try().Value.IfNone(default(T));
        public static T ValueT<T>(this Try<T> self) => self.Try().Value;
        public static T ValueT<L, T>(this Either<L, T> self) => self.IsRight ? self.RightValue : default(T);
        public static T ValueT<L, T>(this EitherUnsafe<L, T> self) => self.IsRight ? self.RightValue : default(T);
        public static T ValueT<Out, T>(this Writer<Out, T> self) => default(T);
        public static int SumT(this IEnumerable<int> self) => self.Sum();
        public static int SumT(this Option<int> self) => self.Sum();
        public static int SumT(this OptionUnsafe<int> self) => self.Sum();
        public static int SumT(this Lst<int> self) => self.Sum();
        public static int SumT<K>(this Map<K, int> self) => self.Sum();
        public static int SumT(this TryOption<int> self) => self.Sum();
        public static int SumT(this Try<int> self) => self.Sum();
        public static int SumT<L>(this Either<L, int> self) => self.Sum();
        public static int SumT<L>(this EitherUnsafe<L, int> self) => self.Sum();
        public static int SumT<Out>(this Writer<Out, int> self) => self.Sum();
        public static int CountT<T>(this IEnumerable<T> self) => self.Count();
        public static int CountT<T>(this Option<T> self) => self.Count();
        public static int CountT<T>(this OptionUnsafe<T> self) => self.Count();
        public static int CountT<T>(this Lst<T> self) => self.Count();
        public static int CountT<K, T>(this Map<K, T> self) => self.Count();
        public static int CountT<T>(this TryOption<T> self) => self.Count();
        public static int CountT<T>(this Try<T> self) => self.Count();
        public static int CountT<L, T>(this Either<L, T> self) => self.Count();
        public static int CountT<L, T>(this EitherUnsafe<L, T> self) => self.Count();
        public static int CountT<Out, T>(this Writer<Out, T> self) => self.Count();
        public static IEnumerable<U> BindT<T, U>(this IEnumerable<T> self, Func<T, IEnumerable<U>> binder) => self.Bind(binder);
        public static Option<U> BindT<T, U>(this Option<T> self, Func<T, Option<U>> binder) => self.Bind(binder);
        public static OptionUnsafe<U> BindT<T, U>(this OptionUnsafe<T> self, Func<T, OptionUnsafe<U>> binder) => self.Bind(binder);
        public static Lst<U> BindT<T, U>(this Lst<T> self, Func<T, Lst<U>> binder) => self.Bind(binder);
        public static Map<K, U> BindT<K, T, U>(this Map<K, T> self, Func<T, Map<K, U>> binder) => self.Bind(binder);
        public static TryOption<U> BindT<T, U>(this TryOption<T> self, Func<T, TryOption<U>> binder) => self.Bind(binder);
        public static Try<U> BindT<T, U>(this Try<T> self, Func<T, Try<U>> binder) => self.Bind(binder);
        public static Either<L, U> BindT<L, T, U>(this Either<L, T> self, Func<T, Either<L, U>> binder) => self.Bind(binder);
        public static EitherUnsafe<L, U> BindT<L, T, U>(this EitherUnsafe<L, T> self, Func<T, EitherUnsafe<L, U>> binder) => self.Bind(binder);
        public static Writer<Out, U> BindT<Out, T, U>(this Writer<Out, T> self, Func<T, Writer<Out, U>> binder) => self.Bind(binder);
        public static bool ExistsT<T>(this IEnumerable<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<T>(this Option<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<T>(this OptionUnsafe<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<T>(this Lst<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<K, T>(this Map<K, T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<T>(this TryOption<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<T>(this Try<T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<L, T>(this Either<L, T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, T> self, Func<T, bool> pred) => self.Exists(pred);
        public static bool ExistsT<Out, T>(this Writer<Out, T> self, Func<T, bool> pred) => self.Exists(pred);
        public static IEnumerable<T> FilterT<T>(this IEnumerable<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Option<T> FilterT<T>(this Option<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static OptionUnsafe<T> FilterT<T>(this OptionUnsafe<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Lst<T> FilterT<T>(this Lst<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Map<K, T> FilterT<K, T>(this Map<K, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static TryOption<T> FilterT<T>(this TryOption<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Try<T> FilterT<T>(this Try<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Either<L, T> FilterT<L, T>(this Either<L, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static EitherUnsafe<L, T> FilterT<L, T>(this EitherUnsafe<L, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Writer<Out, T> FilterT<Out, T>(this Writer<Out, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static V FoldT<T, V>(this IEnumerable<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<T, V>(this Option<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<T, V>(this OptionUnsafe<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<T, V>(this Lst<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<K, T, V>(this Map<K, T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<T, V>(this TryOption<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<T, V>(this Try<T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<L, T, V>(this Either<L, T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<L, T, V>(this EitherUnsafe<L, T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static V FoldT<Out, T, V>(this Writer<Out, T> self, V state, Func<V, T, V> fold) => self.Fold(state,fold);
        public static bool ForAllT<T>(this IEnumerable<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<T>(this Option<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<T>(this OptionUnsafe<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<T>(this Lst<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<K, T>(this Map<K, T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<T>(this TryOption<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<T>(this Try<T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<L, T>(this Either<L, T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static bool ForAllT<Out, T>(this Writer<Out, T> self, Func<T, bool> pred) => self.ForAll(pred);
        public static Unit IterT<T>(this IEnumerable<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<T>(this Option<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<T>(this OptionUnsafe<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<T>(this Lst<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<K, T>(this Map<K, T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<T>(this TryOption<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<T>(this Try<T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<L, T>(this Either<L, T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<L, T>(this EitherUnsafe<L, T> self, Action<T> action) => self.Iter(action);
        public static Unit IterT<Out, T>(this Writer<Out, T> self, Action<T> action) => self.Iter(action);
        public static IEnumerable<U> MapT<T, U>(this IEnumerable<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Option<U> MapT<T, U>(this Option<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static OptionUnsafe<U> MapT<T, U>(this OptionUnsafe<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Lst<U> MapT<T, U>(this Lst<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Map<K, U> MapT<K, T, U>(this Map<K, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static TryOption<U> MapT<T, U>(this TryOption<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Try<U> MapT<T, U>(this Try<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Either<L, U> MapT<L, T, U>(this Either<L, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static EitherUnsafe<L, U> MapT<L, T, U>(this EitherUnsafe<L, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Writer<Out, U> MapT<Out, T, U>(this Writer<Out, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static IEnumerable<U> Select<T, U>(this IEnumerable<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Option<U> Select<T, U>(this Option<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static OptionUnsafe<U> Select<T, U>(this OptionUnsafe<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Lst<U> Select<T, U>(this Lst<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Map<K, U> Select<K, T, U>(this Map<K, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static TryOption<U> Select<T, U>(this TryOption<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Try<U> Select<T, U>(this Try<T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Either<L, U> Select<L, T, U>(this Either<L, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static EitherUnsafe<L, U> Select<L, T, U>(this EitherUnsafe<L, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static Writer<Out, U> Select<Out, T, U>(this Writer<Out, T> self, Func<T, U> mapper) => self.Map(mapper);
        public static IEnumerable<T> Where<T>(this IEnumerable<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Option<T> Where<T>(this Option<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static OptionUnsafe<T> Where<T>(this OptionUnsafe<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Lst<T> Where<T>(this Lst<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Map<K, T> Where<K, T>(this Map<K, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static TryOption<T> Where<T>(this TryOption<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Try<T> Where<T>(this Try<T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Either<L, T> Where<L, T>(this Either<L, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static EitherUnsafe<L, T> Where<L, T>(this EitherUnsafe<L, T> self, Func<T, bool> pred) => self.Filter(pred);
        public static Writer<Out, T> Where<Out, T>(this Writer<Out, T> self, Func<T, bool> pred) => self.Filter(pred);
        
        
        
        
        
        
        
        
        
        
        public static T LiftT<T>(this IEnumerable<T> self) => self.ValueT();
        public static T LiftT<T>(this Option<T> self) => self.ValueT();
        public static T LiftT<T>(this OptionUnsafe<T> self) => self.ValueT();
        public static T LiftT<T>(this Lst<T> self) => self.ValueT();
        public static T LiftT<K, T>(this Map<K, T> self) => self.ValueT();
        public static T LiftT<T>(this TryOption<T> self) => self.ValueT();
        public static T LiftT<T>(this Try<T> self) => self.ValueT();
        public static T LiftT<L, T>(this Either<L, T> self) => self.ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, T> self) => self.ValueT();
        public static T LiftT<Out, T>(this Writer<Out, T> self) => self.ValueT();
        
    }

    public static partial class HKT
    {

        public static IEnumerable<T> ValueT<T>(this IEnumerable<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T>(this IEnumerable<Option<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T>(this IEnumerable<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T>(this IEnumerable<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T, K>(this IEnumerable<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T>(this IEnumerable<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T>(this IEnumerable<Try<T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T, L>(this IEnumerable<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static IEnumerable<T> ValueT<T, Out>(this IEnumerable<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<Option<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T, K>(this Option<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T>(this Option<Try<T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T, L>(this Option<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T, L>(this Option<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Option<T> ValueT<T, Out>(this Option<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<Option<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T, K>(this OptionUnsafe<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T>(this OptionUnsafe<Try<T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T, L>(this OptionUnsafe<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static OptionUnsafe<T> ValueT<T, Out>(this OptionUnsafe<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<Option<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T, K>(this Lst<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T>(this Lst<Try<T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T, L>(this Lst<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T, L>(this Lst<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Lst<T> ValueT<T, Out>(this Lst<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, Option<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T>(this Map<K, Try<T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T, L>(this Map<K, Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Map<K, T> ValueT<K, T, Out>(this Map<K, Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<Option<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T, K>(this TryOption<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T>(this TryOption<Try<T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T, L>(this TryOption<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T, L>(this TryOption<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static TryOption<T> ValueT<T, Out>(this TryOption<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<Option<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T, K>(this Try<Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T>(this Try<Try<T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T, L>(this Try<Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T, L>(this Try<EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Try<T> ValueT<T, Out>(this Try<Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, Option<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T, K>(this Either<L, Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, Try<T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T>(this Either<L, EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Either<L, T> ValueT<L, T, Out>(this Either<L, Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, Option<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, Lst<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, Try<T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static EitherUnsafe<L, T> ValueT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, IEnumerable<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, Option<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, OptionUnsafe<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, Lst<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T, K>(this Writer<Out, Map<K, T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, TryOption<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, Try<T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T, L>(this Writer<Out, Either<L, T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self) => self.MapT(x => x.ValueT());
        public static Writer<Out, T> ValueT<Out, T>(this Writer<Out, Writer<Out, T>> self) => self.MapT(x => x.ValueT());
        public static int SumT(this IEnumerable<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this IEnumerable<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this IEnumerable<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this IEnumerable<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this IEnumerable<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this IEnumerable<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this IEnumerable<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this IEnumerable<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this IEnumerable<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this IEnumerable<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Option<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Option<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Option<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Option<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Option<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this OptionUnsafe<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this OptionUnsafe<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this OptionUnsafe<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this OptionUnsafe<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this OptionUnsafe<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Lst<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Lst<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Lst<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Lst<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Lst<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Map<K, Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K, L>(this Map<K, Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K, L>(this Map<K, EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K, Out>(this Map<K, Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this TryOption<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this TryOption<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this TryOption<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this TryOption<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this TryOption<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<K>(this Try<Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT(this Try<Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Try<Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Try<EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Try<Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L, K>(this Either<L, Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this Either<L, EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L, Out>(this Either<L, Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L, K>(this EitherUnsafe<L, Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L>(this EitherUnsafe<L, EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<L, Out>(this EitherUnsafe<L, Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, IEnumerable<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, Option<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, OptionUnsafe<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, Lst<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out, K>(this Writer<Out, Map<K, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, TryOption<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, Try<int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out, L>(this Writer<Out, Either<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out, L>(this Writer<Out, EitherUnsafe<L, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int SumT<Out>(this Writer<Out, Writer<Out, int>> self) => self.MapT(x => x.SumT()).Sum();
        public static int CountT<T>(this IEnumerable<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this IEnumerable<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this IEnumerable<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this IEnumerable<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this IEnumerable<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this IEnumerable<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this IEnumerable<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this IEnumerable<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this IEnumerable<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this Option<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Option<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Option<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Option<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this Option<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this OptionUnsafe<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this OptionUnsafe<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this OptionUnsafe<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this OptionUnsafe<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this Lst<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Lst<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Lst<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Lst<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this Lst<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T>(this Map<K, Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T, L>(this Map<K, Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<K, T, Out>(this Map<K, Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this TryOption<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this TryOption<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this TryOption<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this TryOption<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this TryOption<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, K>(this Try<Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T>(this Try<Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Try<Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, L>(this Try<EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<T, Out>(this Try<Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T, K>(this Either<L, Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this Either<L, EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T, Out>(this Either<L, Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, IEnumerable<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, Option<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, OptionUnsafe<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, Lst<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T, K>(this Writer<Out, Map<K, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, TryOption<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, Try<T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T, L>(this Writer<Out, Either<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self) => self.Map(x => x.CountT()).Sum();
        public static int CountT<Out, T>(this Writer<Out, Writer<Out, T>> self) => self.Map(x => x.CountT()).Sum();
        public static IEnumerable<IEnumerable<U>> BindT<T, U>(this IEnumerable<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Option<U>> BindT<T, U>(this IEnumerable<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<OptionUnsafe<U>> BindT<T, U>(this IEnumerable<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Lst<U>> BindT<T, U>(this IEnumerable<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Map<K, U>> BindT<T, K, U>(this IEnumerable<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<TryOption<U>> BindT<T, U>(this IEnumerable<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Try<U>> BindT<T, U>(this IEnumerable<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Either<L, U>> BindT<T, L, U>(this IEnumerable<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<EitherUnsafe<L, U>> BindT<T, L, U>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static IEnumerable<Writer<Out, U>> BindT<T, Out, U>(this IEnumerable<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<IEnumerable<U>> BindT<T, U>(this Option<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Option<U>> BindT<T, U>(this Option<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<OptionUnsafe<U>> BindT<T, U>(this Option<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Lst<U>> BindT<T, U>(this Option<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Map<K, U>> BindT<T, K, U>(this Option<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<TryOption<U>> BindT<T, U>(this Option<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Try<U>> BindT<T, U>(this Option<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Either<L, U>> BindT<T, L, U>(this Option<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<EitherUnsafe<L, U>> BindT<T, L, U>(this Option<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Option<Writer<Out, U>> BindT<T, Out, U>(this Option<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<IEnumerable<U>> BindT<T, U>(this OptionUnsafe<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Option<U>> BindT<T, U>(this OptionUnsafe<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<OptionUnsafe<U>> BindT<T, U>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Lst<U>> BindT<T, U>(this OptionUnsafe<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Map<K, U>> BindT<T, K, U>(this OptionUnsafe<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<TryOption<U>> BindT<T, U>(this OptionUnsafe<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Try<U>> BindT<T, U>(this OptionUnsafe<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Either<L, U>> BindT<T, L, U>(this OptionUnsafe<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<EitherUnsafe<L, U>> BindT<T, L, U>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static OptionUnsafe<Writer<Out, U>> BindT<T, Out, U>(this OptionUnsafe<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<IEnumerable<U>> BindT<T, U>(this Lst<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Option<U>> BindT<T, U>(this Lst<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<OptionUnsafe<U>> BindT<T, U>(this Lst<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Lst<U>> BindT<T, U>(this Lst<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Map<K, U>> BindT<T, K, U>(this Lst<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<TryOption<U>> BindT<T, U>(this Lst<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Try<U>> BindT<T, U>(this Lst<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Either<L, U>> BindT<T, L, U>(this Lst<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<EitherUnsafe<L, U>> BindT<T, L, U>(this Lst<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Lst<Writer<Out, U>> BindT<T, Out, U>(this Lst<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, IEnumerable<U>> BindT<K, T, U>(this Map<K, IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Option<U>> BindT<K, T, U>(this Map<K, Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, OptionUnsafe<U>> BindT<K, T, U>(this Map<K, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Lst<U>> BindT<K, T, U>(this Map<K, Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Map<K, U>> BindT<K, T, U>(this Map<K, Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, TryOption<U>> BindT<K, T, U>(this Map<K, TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Try<U>> BindT<K, T, U>(this Map<K, Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Either<L, U>> BindT<K, T, L, U>(this Map<K, Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, EitherUnsafe<L, U>> BindT<K, T, L, U>(this Map<K, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Map<K, Writer<Out, U>> BindT<K, T, Out, U>(this Map<K, Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<IEnumerable<U>> BindT<T, U>(this TryOption<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Option<U>> BindT<T, U>(this TryOption<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<OptionUnsafe<U>> BindT<T, U>(this TryOption<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Lst<U>> BindT<T, U>(this TryOption<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Map<K, U>> BindT<T, K, U>(this TryOption<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<TryOption<U>> BindT<T, U>(this TryOption<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Try<U>> BindT<T, U>(this TryOption<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Either<L, U>> BindT<T, L, U>(this TryOption<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<EitherUnsafe<L, U>> BindT<T, L, U>(this TryOption<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static TryOption<Writer<Out, U>> BindT<T, Out, U>(this TryOption<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<IEnumerable<U>> BindT<T, U>(this Try<IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Option<U>> BindT<T, U>(this Try<Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<OptionUnsafe<U>> BindT<T, U>(this Try<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Lst<U>> BindT<T, U>(this Try<Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Map<K, U>> BindT<T, K, U>(this Try<Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<TryOption<U>> BindT<T, U>(this Try<TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Try<U>> BindT<T, U>(this Try<Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Either<L, U>> BindT<T, L, U>(this Try<Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<EitherUnsafe<L, U>> BindT<T, L, U>(this Try<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Try<Writer<Out, U>> BindT<T, Out, U>(this Try<Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, IEnumerable<U>> BindT<L, T, U>(this Either<L, IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Option<U>> BindT<L, T, U>(this Either<L, Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, OptionUnsafe<U>> BindT<L, T, U>(this Either<L, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Lst<U>> BindT<L, T, U>(this Either<L, Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Map<K, U>> BindT<L, T, K, U>(this Either<L, Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, TryOption<U>> BindT<L, T, U>(this Either<L, TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Try<U>> BindT<L, T, U>(this Either<L, Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Either<L, U>> BindT<L, T, U>(this Either<L, Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, EitherUnsafe<L, U>> BindT<L, T, U>(this Either<L, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Either<L, Writer<Out, U>> BindT<L, T, Out, U>(this Either<L, Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, IEnumerable<U>> BindT<L, T, U>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Option<U>> BindT<L, T, U>(this EitherUnsafe<L, Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, OptionUnsafe<U>> BindT<L, T, U>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Lst<U>> BindT<L, T, U>(this EitherUnsafe<L, Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Map<K, U>> BindT<L, T, K, U>(this EitherUnsafe<L, Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, TryOption<U>> BindT<L, T, U>(this EitherUnsafe<L, TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Try<U>> BindT<L, T, U>(this EitherUnsafe<L, Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Either<L, U>> BindT<L, T, U>(this EitherUnsafe<L, Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, EitherUnsafe<L, U>> BindT<L, T, U>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static EitherUnsafe<L, Writer<Out, U>> BindT<L, T, Out, U>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, IEnumerable<U>> BindT<Out, T, U>(this Writer<Out, IEnumerable<T>> self, Func<T, IEnumerable<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Option<U>> BindT<Out, T, U>(this Writer<Out, Option<T>> self, Func<T, Option<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, OptionUnsafe<U>> BindT<Out, T, U>(this Writer<Out, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Lst<U>> BindT<Out, T, U>(this Writer<Out, Lst<T>> self, Func<T, Lst<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Map<K, U>> BindT<Out, T, K, U>(this Writer<Out, Map<K, T>> self, Func<T, Map<K, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, TryOption<U>> BindT<Out, T, U>(this Writer<Out, TryOption<T>> self, Func<T, TryOption<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Try<U>> BindT<Out, T, U>(this Writer<Out, Try<T>> self, Func<T, Try<U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Either<L, U>> BindT<Out, T, L, U>(this Writer<Out, Either<L, T>> self, Func<T, Either<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, EitherUnsafe<L, U>> BindT<Out, T, L, U>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> binder) => self.MapT(x => x.BindT(binder));
        public static Writer<Out, Writer<Out, U>> BindT<Out, T, U>(this Writer<Out, Writer<Out, T>> self, Func<T, Writer<Out, U>> binder) => self.MapT(x => x.BindT(binder));
        public static bool ExistsT<T>(this IEnumerable<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this IEnumerable<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this IEnumerable<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this IEnumerable<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this IEnumerable<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this IEnumerable<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this IEnumerable<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this IEnumerable<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this IEnumerable<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this Option<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Option<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Option<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Option<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this Option<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this OptionUnsafe<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this OptionUnsafe<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this OptionUnsafe<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this OptionUnsafe<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this Lst<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Lst<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Lst<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Lst<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this Lst<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T>(this Map<K, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T, L>(this Map<K, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<K, T, Out>(this Map<K, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this TryOption<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this TryOption<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this TryOption<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this TryOption<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this TryOption<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, K>(this Try<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T>(this Try<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Try<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, L>(this Try<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<T, Out>(this Try<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T, K>(this Either<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this Either<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T, Out>(this Either<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T, K>(this Writer<Out, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T, L>(this Writer<Out, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static bool ExistsT<Out, T>(this Writer<Out, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);
        public static IEnumerable<IEnumerable<T>> FilterT<T>(this IEnumerable<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Option<T>> FilterT<T>(this IEnumerable<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<OptionUnsafe<T>> FilterT<T>(this IEnumerable<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Lst<T>> FilterT<T>(this IEnumerable<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Map<K, T>> FilterT<T, K>(this IEnumerable<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<TryOption<T>> FilterT<T>(this IEnumerable<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Try<T>> FilterT<T>(this IEnumerable<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Either<L, T>> FilterT<T, L>(this IEnumerable<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<EitherUnsafe<L, T>> FilterT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Writer<Out, T>> FilterT<T, Out>(this IEnumerable<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<IEnumerable<T>> FilterT<T>(this Option<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Option<T>> FilterT<T>(this Option<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<OptionUnsafe<T>> FilterT<T>(this Option<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Lst<T>> FilterT<T>(this Option<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Map<K, T>> FilterT<T, K>(this Option<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<TryOption<T>> FilterT<T>(this Option<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Try<T>> FilterT<T>(this Option<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Either<L, T>> FilterT<T, L>(this Option<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<EitherUnsafe<L, T>> FilterT<T, L>(this Option<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Writer<Out, T>> FilterT<T, Out>(this Option<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<IEnumerable<T>> FilterT<T>(this OptionUnsafe<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Option<T>> FilterT<T>(this OptionUnsafe<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<OptionUnsafe<T>> FilterT<T>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Lst<T>> FilterT<T>(this OptionUnsafe<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Map<K, T>> FilterT<T, K>(this OptionUnsafe<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<TryOption<T>> FilterT<T>(this OptionUnsafe<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Try<T>> FilterT<T>(this OptionUnsafe<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Either<L, T>> FilterT<T, L>(this OptionUnsafe<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<EitherUnsafe<L, T>> FilterT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Writer<Out, T>> FilterT<T, Out>(this OptionUnsafe<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<IEnumerable<T>> FilterT<T>(this Lst<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Option<T>> FilterT<T>(this Lst<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<OptionUnsafe<T>> FilterT<T>(this Lst<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Lst<T>> FilterT<T>(this Lst<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Map<K, T>> FilterT<T, K>(this Lst<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<TryOption<T>> FilterT<T>(this Lst<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Try<T>> FilterT<T>(this Lst<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Either<L, T>> FilterT<T, L>(this Lst<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<EitherUnsafe<L, T>> FilterT<T, L>(this Lst<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Writer<Out, T>> FilterT<T, Out>(this Lst<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, IEnumerable<T>> FilterT<K, T>(this Map<K, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Option<T>> FilterT<K, T>(this Map<K, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, OptionUnsafe<T>> FilterT<K, T>(this Map<K, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Lst<T>> FilterT<K, T>(this Map<K, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Map<K, T>> FilterT<K, T>(this Map<K, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, TryOption<T>> FilterT<K, T>(this Map<K, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Try<T>> FilterT<K, T>(this Map<K, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Either<L, T>> FilterT<K, T, L>(this Map<K, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, EitherUnsafe<L, T>> FilterT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Writer<Out, T>> FilterT<K, T, Out>(this Map<K, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<IEnumerable<T>> FilterT<T>(this TryOption<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Option<T>> FilterT<T>(this TryOption<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<OptionUnsafe<T>> FilterT<T>(this TryOption<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Lst<T>> FilterT<T>(this TryOption<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Map<K, T>> FilterT<T, K>(this TryOption<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<TryOption<T>> FilterT<T>(this TryOption<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Try<T>> FilterT<T>(this TryOption<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Either<L, T>> FilterT<T, L>(this TryOption<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<EitherUnsafe<L, T>> FilterT<T, L>(this TryOption<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Writer<Out, T>> FilterT<T, Out>(this TryOption<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<IEnumerable<T>> FilterT<T>(this Try<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Option<T>> FilterT<T>(this Try<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<OptionUnsafe<T>> FilterT<T>(this Try<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Lst<T>> FilterT<T>(this Try<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Map<K, T>> FilterT<T, K>(this Try<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<TryOption<T>> FilterT<T>(this Try<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Try<T>> FilterT<T>(this Try<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Either<L, T>> FilterT<T, L>(this Try<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<EitherUnsafe<L, T>> FilterT<T, L>(this Try<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Writer<Out, T>> FilterT<T, Out>(this Try<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, IEnumerable<T>> FilterT<L, T>(this Either<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Option<T>> FilterT<L, T>(this Either<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, OptionUnsafe<T>> FilterT<L, T>(this Either<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Lst<T>> FilterT<L, T>(this Either<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Map<K, T>> FilterT<L, T, K>(this Either<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, TryOption<T>> FilterT<L, T>(this Either<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Try<T>> FilterT<L, T>(this Either<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Either<L, T>> FilterT<L, T>(this Either<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, EitherUnsafe<L, T>> FilterT<L, T>(this Either<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Writer<Out, T>> FilterT<L, T, Out>(this Either<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, IEnumerable<T>> FilterT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Option<T>> FilterT<L, T>(this EitherUnsafe<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, OptionUnsafe<T>> FilterT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Lst<T>> FilterT<L, T>(this EitherUnsafe<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Map<K, T>> FilterT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, TryOption<T>> FilterT<L, T>(this EitherUnsafe<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Try<T>> FilterT<L, T>(this EitherUnsafe<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Either<L, T>> FilterT<L, T>(this EitherUnsafe<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, EitherUnsafe<L, T>> FilterT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Writer<Out, T>> FilterT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, IEnumerable<T>> FilterT<Out, T>(this Writer<Out, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Option<T>> FilterT<Out, T>(this Writer<Out, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, OptionUnsafe<T>> FilterT<Out, T>(this Writer<Out, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Lst<T>> FilterT<Out, T>(this Writer<Out, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Map<K, T>> FilterT<Out, T, K>(this Writer<Out, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, TryOption<T>> FilterT<Out, T>(this Writer<Out, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Try<T>> FilterT<Out, T>(this Writer<Out, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Either<L, T>> FilterT<Out, T, L>(this Writer<Out, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, EitherUnsafe<L, T>> FilterT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Writer<Out, T>> FilterT<Out, T>(this Writer<Out, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static V FoldT<T, V>(this IEnumerable<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this IEnumerable<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this IEnumerable<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this IEnumerable<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this IEnumerable<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this IEnumerable<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this IEnumerable<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this IEnumerable<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this IEnumerable<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this IEnumerable<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this Option<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Option<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Option<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Option<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this Option<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this OptionUnsafe<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this OptionUnsafe<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this OptionUnsafe<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this OptionUnsafe<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this OptionUnsafe<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this Lst<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Lst<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Lst<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Lst<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this Lst<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, V>(this Map<K, Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, L, V>(this Map<K, Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, L, V>(this Map<K, EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<K, T, Out, V>(this Map<K, Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this TryOption<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this TryOption<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this TryOption<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this TryOption<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this TryOption<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, K, V>(this Try<Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, V>(this Try<Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Try<Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, L, V>(this Try<EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<T, Out, V>(this Try<Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, K, V>(this Either<L, Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this Either<L, EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, Out, V>(this Either<L, Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, K, V>(this EitherUnsafe<L, Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, V>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<L, T, Out, V>(this EitherUnsafe<L, Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, IEnumerable<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, Option<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, OptionUnsafe<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, Lst<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, K, V>(this Writer<Out, Map<K, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, TryOption<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, Try<T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, L, V>(this Writer<Out, Either<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, L, V>(this Writer<Out, EitherUnsafe<L, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static V FoldT<Out, T, V>(this Writer<Out, Writer<Out, T>> self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));
        public static bool ForAllT<T>(this IEnumerable<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this IEnumerable<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this IEnumerable<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this IEnumerable<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this IEnumerable<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this IEnumerable<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this IEnumerable<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this IEnumerable<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this IEnumerable<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this Option<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Option<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Option<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Option<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this Option<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this OptionUnsafe<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this OptionUnsafe<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this OptionUnsafe<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this OptionUnsafe<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this Lst<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Lst<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Lst<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Lst<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this Lst<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T>(this Map<K, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T, L>(this Map<K, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<K, T, Out>(this Map<K, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this TryOption<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this TryOption<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this TryOption<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this TryOption<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this TryOption<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, K>(this Try<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T>(this Try<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Try<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, L>(this Try<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<T, Out>(this Try<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T, K>(this Either<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this Either<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T, Out>(this Either<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T, K>(this Writer<Out, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T, L>(this Writer<Out, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static bool ForAllT<Out, T>(this Writer<Out, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);
        public static Unit IterT<T>(this IEnumerable<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this IEnumerable<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this IEnumerable<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this IEnumerable<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this IEnumerable<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this IEnumerable<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this IEnumerable<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this IEnumerable<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this IEnumerable<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this Option<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Option<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Option<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Option<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this Option<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this OptionUnsafe<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this OptionUnsafe<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this OptionUnsafe<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this OptionUnsafe<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this Lst<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Lst<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Lst<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Lst<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this Lst<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T>(this Map<K, Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T, L>(this Map<K, Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<K, T, Out>(this Map<K, Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this TryOption<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this TryOption<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this TryOption<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this TryOption<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this TryOption<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, K>(this Try<Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T>(this Try<Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Try<Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, L>(this Try<EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<T, Out>(this Try<Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T, K>(this Either<L, Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this Either<L, EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T, Out>(this Either<L, Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, IEnumerable<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, Option<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, OptionUnsafe<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, Lst<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T, K>(this Writer<Out, Map<K, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, TryOption<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, Try<T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T, L>(this Writer<Out, Either<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static Unit IterT<Out, T>(this Writer<Out, Writer<Out, T>> self, Action<T> action) => self.Iter(x => x.IterT(action));
        public static IEnumerable<IEnumerable<U>> MapT<T, U>(this IEnumerable<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Option<U>> MapT<T, U>(this IEnumerable<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<OptionUnsafe<U>> MapT<T, U>(this IEnumerable<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Lst<U>> MapT<T, U>(this IEnumerable<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Map<K, U>> MapT<T, K, U>(this IEnumerable<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<TryOption<U>> MapT<T, U>(this IEnumerable<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Try<U>> MapT<T, U>(this IEnumerable<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Either<L, U>> MapT<T, L, U>(this IEnumerable<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<EitherUnsafe<L, U>> MapT<T, L, U>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Writer<Out, U>> MapT<T, Out, U>(this IEnumerable<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<IEnumerable<U>> MapT<T, U>(this Option<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Option<U>> MapT<T, U>(this Option<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<OptionUnsafe<U>> MapT<T, U>(this Option<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Lst<U>> MapT<T, U>(this Option<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Map<K, U>> MapT<T, K, U>(this Option<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<TryOption<U>> MapT<T, U>(this Option<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Try<U>> MapT<T, U>(this Option<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Either<L, U>> MapT<T, L, U>(this Option<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<EitherUnsafe<L, U>> MapT<T, L, U>(this Option<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Writer<Out, U>> MapT<T, Out, U>(this Option<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<IEnumerable<U>> MapT<T, U>(this OptionUnsafe<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Option<U>> MapT<T, U>(this OptionUnsafe<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<OptionUnsafe<U>> MapT<T, U>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Lst<U>> MapT<T, U>(this OptionUnsafe<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Map<K, U>> MapT<T, K, U>(this OptionUnsafe<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<TryOption<U>> MapT<T, U>(this OptionUnsafe<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Try<U>> MapT<T, U>(this OptionUnsafe<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Either<L, U>> MapT<T, L, U>(this OptionUnsafe<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<EitherUnsafe<L, U>> MapT<T, L, U>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Writer<Out, U>> MapT<T, Out, U>(this OptionUnsafe<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<IEnumerable<U>> MapT<T, U>(this Lst<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Option<U>> MapT<T, U>(this Lst<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<OptionUnsafe<U>> MapT<T, U>(this Lst<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Lst<U>> MapT<T, U>(this Lst<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Map<K, U>> MapT<T, K, U>(this Lst<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<TryOption<U>> MapT<T, U>(this Lst<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Try<U>> MapT<T, U>(this Lst<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Either<L, U>> MapT<T, L, U>(this Lst<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<EitherUnsafe<L, U>> MapT<T, L, U>(this Lst<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Writer<Out, U>> MapT<T, Out, U>(this Lst<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, IEnumerable<U>> MapT<K, T, U>(this Map<K, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Option<U>> MapT<K, T, U>(this Map<K, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, OptionUnsafe<U>> MapT<K, T, U>(this Map<K, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Lst<U>> MapT<K, T, U>(this Map<K, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Map<K, U>> MapT<K, T, U>(this Map<K, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, TryOption<U>> MapT<K, T, U>(this Map<K, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Try<U>> MapT<K, T, U>(this Map<K, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Either<L, U>> MapT<K, T, L, U>(this Map<K, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, EitherUnsafe<L, U>> MapT<K, T, L, U>(this Map<K, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Writer<Out, U>> MapT<K, T, Out, U>(this Map<K, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<IEnumerable<U>> MapT<T, U>(this TryOption<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Option<U>> MapT<T, U>(this TryOption<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<OptionUnsafe<U>> MapT<T, U>(this TryOption<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Lst<U>> MapT<T, U>(this TryOption<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Map<K, U>> MapT<T, K, U>(this TryOption<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<TryOption<U>> MapT<T, U>(this TryOption<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Try<U>> MapT<T, U>(this TryOption<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Either<L, U>> MapT<T, L, U>(this TryOption<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<EitherUnsafe<L, U>> MapT<T, L, U>(this TryOption<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Writer<Out, U>> MapT<T, Out, U>(this TryOption<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<IEnumerable<U>> MapT<T, U>(this Try<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Option<U>> MapT<T, U>(this Try<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<OptionUnsafe<U>> MapT<T, U>(this Try<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Lst<U>> MapT<T, U>(this Try<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Map<K, U>> MapT<T, K, U>(this Try<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<TryOption<U>> MapT<T, U>(this Try<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Try<U>> MapT<T, U>(this Try<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Either<L, U>> MapT<T, L, U>(this Try<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<EitherUnsafe<L, U>> MapT<T, L, U>(this Try<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Writer<Out, U>> MapT<T, Out, U>(this Try<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, IEnumerable<U>> MapT<L, T, U>(this Either<L, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Option<U>> MapT<L, T, U>(this Either<L, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, OptionUnsafe<U>> MapT<L, T, U>(this Either<L, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Lst<U>> MapT<L, T, U>(this Either<L, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Map<K, U>> MapT<L, T, K, U>(this Either<L, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, TryOption<U>> MapT<L, T, U>(this Either<L, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Try<U>> MapT<L, T, U>(this Either<L, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Either<L, U>> MapT<L, T, U>(this Either<L, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, EitherUnsafe<L, U>> MapT<L, T, U>(this Either<L, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Writer<Out, U>> MapT<L, T, Out, U>(this Either<L, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, IEnumerable<U>> MapT<L, T, U>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Option<U>> MapT<L, T, U>(this EitherUnsafe<L, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, OptionUnsafe<U>> MapT<L, T, U>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Lst<U>> MapT<L, T, U>(this EitherUnsafe<L, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Map<K, U>> MapT<L, T, K, U>(this EitherUnsafe<L, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, TryOption<U>> MapT<L, T, U>(this EitherUnsafe<L, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Try<U>> MapT<L, T, U>(this EitherUnsafe<L, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Either<L, U>> MapT<L, T, U>(this EitherUnsafe<L, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, EitherUnsafe<L, U>> MapT<L, T, U>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Writer<Out, U>> MapT<L, T, Out, U>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, IEnumerable<U>> MapT<Out, T, U>(this Writer<Out, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Option<U>> MapT<Out, T, U>(this Writer<Out, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, OptionUnsafe<U>> MapT<Out, T, U>(this Writer<Out, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Lst<U>> MapT<Out, T, U>(this Writer<Out, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Map<K, U>> MapT<Out, T, K, U>(this Writer<Out, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, TryOption<U>> MapT<Out, T, U>(this Writer<Out, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Try<U>> MapT<Out, T, U>(this Writer<Out, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Either<L, U>> MapT<Out, T, L, U>(this Writer<Out, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, EitherUnsafe<L, U>> MapT<Out, T, L, U>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Writer<Out, U>> MapT<Out, T, U>(this Writer<Out, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<IEnumerable<U>> Select<T, U>(this IEnumerable<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Option<U>> Select<T, U>(this IEnumerable<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<OptionUnsafe<U>> Select<T, U>(this IEnumerable<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Lst<U>> Select<T, U>(this IEnumerable<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Map<K, U>> Select<T, K, U>(this IEnumerable<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<TryOption<U>> Select<T, U>(this IEnumerable<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Try<U>> Select<T, U>(this IEnumerable<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Either<L, U>> Select<T, L, U>(this IEnumerable<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<EitherUnsafe<L, U>> Select<T, L, U>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<Writer<Out, U>> Select<T, Out, U>(this IEnumerable<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<IEnumerable<U>> Select<T, U>(this Option<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Option<U>> Select<T, U>(this Option<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<OptionUnsafe<U>> Select<T, U>(this Option<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Lst<U>> Select<T, U>(this Option<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Map<K, U>> Select<T, K, U>(this Option<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<TryOption<U>> Select<T, U>(this Option<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Try<U>> Select<T, U>(this Option<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Either<L, U>> Select<T, L, U>(this Option<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<EitherUnsafe<L, U>> Select<T, L, U>(this Option<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Option<Writer<Out, U>> Select<T, Out, U>(this Option<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<IEnumerable<U>> Select<T, U>(this OptionUnsafe<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Option<U>> Select<T, U>(this OptionUnsafe<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<OptionUnsafe<U>> Select<T, U>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Lst<U>> Select<T, U>(this OptionUnsafe<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Map<K, U>> Select<T, K, U>(this OptionUnsafe<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<TryOption<U>> Select<T, U>(this OptionUnsafe<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Try<U>> Select<T, U>(this OptionUnsafe<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Either<L, U>> Select<T, L, U>(this OptionUnsafe<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<EitherUnsafe<L, U>> Select<T, L, U>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static OptionUnsafe<Writer<Out, U>> Select<T, Out, U>(this OptionUnsafe<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<IEnumerable<U>> Select<T, U>(this Lst<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Option<U>> Select<T, U>(this Lst<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<OptionUnsafe<U>> Select<T, U>(this Lst<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Lst<U>> Select<T, U>(this Lst<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Map<K, U>> Select<T, K, U>(this Lst<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<TryOption<U>> Select<T, U>(this Lst<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Try<U>> Select<T, U>(this Lst<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Either<L, U>> Select<T, L, U>(this Lst<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<EitherUnsafe<L, U>> Select<T, L, U>(this Lst<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Lst<Writer<Out, U>> Select<T, Out, U>(this Lst<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, IEnumerable<U>> Select<K, T, U>(this Map<K, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Option<U>> Select<K, T, U>(this Map<K, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, OptionUnsafe<U>> Select<K, T, U>(this Map<K, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Lst<U>> Select<K, T, U>(this Map<K, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Map<K, U>> Select<K, T, U>(this Map<K, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, TryOption<U>> Select<K, T, U>(this Map<K, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Try<U>> Select<K, T, U>(this Map<K, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Either<L, U>> Select<K, T, L, U>(this Map<K, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, EitherUnsafe<L, U>> Select<K, T, L, U>(this Map<K, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Map<K, Writer<Out, U>> Select<K, T, Out, U>(this Map<K, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<IEnumerable<U>> Select<T, U>(this TryOption<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Option<U>> Select<T, U>(this TryOption<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<OptionUnsafe<U>> Select<T, U>(this TryOption<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Lst<U>> Select<T, U>(this TryOption<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Map<K, U>> Select<T, K, U>(this TryOption<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<TryOption<U>> Select<T, U>(this TryOption<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Try<U>> Select<T, U>(this TryOption<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Either<L, U>> Select<T, L, U>(this TryOption<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<EitherUnsafe<L, U>> Select<T, L, U>(this TryOption<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static TryOption<Writer<Out, U>> Select<T, Out, U>(this TryOption<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<IEnumerable<U>> Select<T, U>(this Try<IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Option<U>> Select<T, U>(this Try<Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<OptionUnsafe<U>> Select<T, U>(this Try<OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Lst<U>> Select<T, U>(this Try<Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Map<K, U>> Select<T, K, U>(this Try<Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<TryOption<U>> Select<T, U>(this Try<TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Try<U>> Select<T, U>(this Try<Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Either<L, U>> Select<T, L, U>(this Try<Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<EitherUnsafe<L, U>> Select<T, L, U>(this Try<EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Try<Writer<Out, U>> Select<T, Out, U>(this Try<Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, IEnumerable<U>> Select<L, T, U>(this Either<L, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Option<U>> Select<L, T, U>(this Either<L, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, OptionUnsafe<U>> Select<L, T, U>(this Either<L, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Lst<U>> Select<L, T, U>(this Either<L, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Map<K, U>> Select<L, T, K, U>(this Either<L, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, TryOption<U>> Select<L, T, U>(this Either<L, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Try<U>> Select<L, T, U>(this Either<L, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Either<L, U>> Select<L, T, U>(this Either<L, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, EitherUnsafe<L, U>> Select<L, T, U>(this Either<L, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Either<L, Writer<Out, U>> Select<L, T, Out, U>(this Either<L, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, IEnumerable<U>> Select<L, T, U>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Option<U>> Select<L, T, U>(this EitherUnsafe<L, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, OptionUnsafe<U>> Select<L, T, U>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Lst<U>> Select<L, T, U>(this EitherUnsafe<L, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Map<K, U>> Select<L, T, K, U>(this EitherUnsafe<L, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, TryOption<U>> Select<L, T, U>(this EitherUnsafe<L, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Try<U>> Select<L, T, U>(this EitherUnsafe<L, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Either<L, U>> Select<L, T, U>(this EitherUnsafe<L, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, EitherUnsafe<L, U>> Select<L, T, U>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static EitherUnsafe<L, Writer<Out, U>> Select<L, T, Out, U>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, IEnumerable<U>> Select<Out, T, U>(this Writer<Out, IEnumerable<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Option<U>> Select<Out, T, U>(this Writer<Out, Option<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, OptionUnsafe<U>> Select<Out, T, U>(this Writer<Out, OptionUnsafe<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Lst<U>> Select<Out, T, U>(this Writer<Out, Lst<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Map<K, U>> Select<Out, T, K, U>(this Writer<Out, Map<K, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, TryOption<U>> Select<Out, T, U>(this Writer<Out, TryOption<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Try<U>> Select<Out, T, U>(this Writer<Out, Try<T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Either<L, U>> Select<Out, T, L, U>(this Writer<Out, Either<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, EitherUnsafe<L, U>> Select<Out, T, L, U>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static Writer<Out, Writer<Out, U>> Select<Out, T, U>(this Writer<Out, Writer<Out, T>> self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));
        public static IEnumerable<IEnumerable<T>> Where<T>(this IEnumerable<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Option<T>> Where<T>(this IEnumerable<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<OptionUnsafe<T>> Where<T>(this IEnumerable<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Lst<T>> Where<T>(this IEnumerable<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Map<K, T>> Where<T, K>(this IEnumerable<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<TryOption<T>> Where<T>(this IEnumerable<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Try<T>> Where<T>(this IEnumerable<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Either<L, T>> Where<T, L>(this IEnumerable<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<EitherUnsafe<L, T>> Where<T, L>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<Writer<Out, T>> Where<T, Out>(this IEnumerable<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<IEnumerable<T>> Where<T>(this Option<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Option<T>> Where<T>(this Option<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<OptionUnsafe<T>> Where<T>(this Option<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Lst<T>> Where<T>(this Option<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Map<K, T>> Where<T, K>(this Option<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<TryOption<T>> Where<T>(this Option<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Try<T>> Where<T>(this Option<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Either<L, T>> Where<T, L>(this Option<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<EitherUnsafe<L, T>> Where<T, L>(this Option<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Option<Writer<Out, T>> Where<T, Out>(this Option<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<IEnumerable<T>> Where<T>(this OptionUnsafe<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Option<T>> Where<T>(this OptionUnsafe<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<OptionUnsafe<T>> Where<T>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Lst<T>> Where<T>(this OptionUnsafe<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Map<K, T>> Where<T, K>(this OptionUnsafe<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<TryOption<T>> Where<T>(this OptionUnsafe<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Try<T>> Where<T>(this OptionUnsafe<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Either<L, T>> Where<T, L>(this OptionUnsafe<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<EitherUnsafe<L, T>> Where<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static OptionUnsafe<Writer<Out, T>> Where<T, Out>(this OptionUnsafe<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<IEnumerable<T>> Where<T>(this Lst<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Option<T>> Where<T>(this Lst<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<OptionUnsafe<T>> Where<T>(this Lst<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Lst<T>> Where<T>(this Lst<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Map<K, T>> Where<T, K>(this Lst<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<TryOption<T>> Where<T>(this Lst<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Try<T>> Where<T>(this Lst<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Either<L, T>> Where<T, L>(this Lst<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<EitherUnsafe<L, T>> Where<T, L>(this Lst<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Lst<Writer<Out, T>> Where<T, Out>(this Lst<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, IEnumerable<T>> Where<K, T>(this Map<K, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Option<T>> Where<K, T>(this Map<K, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, OptionUnsafe<T>> Where<K, T>(this Map<K, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Lst<T>> Where<K, T>(this Map<K, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Map<K, T>> Where<K, T>(this Map<K, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, TryOption<T>> Where<K, T>(this Map<K, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Try<T>> Where<K, T>(this Map<K, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Either<L, T>> Where<K, T, L>(this Map<K, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, EitherUnsafe<L, T>> Where<K, T, L>(this Map<K, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Map<K, Writer<Out, T>> Where<K, T, Out>(this Map<K, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<IEnumerable<T>> Where<T>(this TryOption<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Option<T>> Where<T>(this TryOption<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<OptionUnsafe<T>> Where<T>(this TryOption<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Lst<T>> Where<T>(this TryOption<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Map<K, T>> Where<T, K>(this TryOption<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<TryOption<T>> Where<T>(this TryOption<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Try<T>> Where<T>(this TryOption<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Either<L, T>> Where<T, L>(this TryOption<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<EitherUnsafe<L, T>> Where<T, L>(this TryOption<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static TryOption<Writer<Out, T>> Where<T, Out>(this TryOption<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<IEnumerable<T>> Where<T>(this Try<IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Option<T>> Where<T>(this Try<Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<OptionUnsafe<T>> Where<T>(this Try<OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Lst<T>> Where<T>(this Try<Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Map<K, T>> Where<T, K>(this Try<Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<TryOption<T>> Where<T>(this Try<TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Try<T>> Where<T>(this Try<Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Either<L, T>> Where<T, L>(this Try<Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<EitherUnsafe<L, T>> Where<T, L>(this Try<EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Try<Writer<Out, T>> Where<T, Out>(this Try<Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, IEnumerable<T>> Where<L, T>(this Either<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Option<T>> Where<L, T>(this Either<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, OptionUnsafe<T>> Where<L, T>(this Either<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Lst<T>> Where<L, T>(this Either<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Map<K, T>> Where<L, T, K>(this Either<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, TryOption<T>> Where<L, T>(this Either<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Try<T>> Where<L, T>(this Either<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Either<L, T>> Where<L, T>(this Either<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, EitherUnsafe<L, T>> Where<L, T>(this Either<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Either<L, Writer<Out, T>> Where<L, T, Out>(this Either<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, IEnumerable<T>> Where<L, T>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Option<T>> Where<L, T>(this EitherUnsafe<L, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, OptionUnsafe<T>> Where<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Lst<T>> Where<L, T>(this EitherUnsafe<L, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Map<K, T>> Where<L, T, K>(this EitherUnsafe<L, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, TryOption<T>> Where<L, T>(this EitherUnsafe<L, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Try<T>> Where<L, T>(this EitherUnsafe<L, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Either<L, T>> Where<L, T>(this EitherUnsafe<L, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, EitherUnsafe<L, T>> Where<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static EitherUnsafe<L, Writer<Out, T>> Where<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, IEnumerable<T>> Where<Out, T>(this Writer<Out, IEnumerable<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Option<T>> Where<Out, T>(this Writer<Out, Option<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, OptionUnsafe<T>> Where<Out, T>(this Writer<Out, OptionUnsafe<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Lst<T>> Where<Out, T>(this Writer<Out, Lst<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Map<K, T>> Where<Out, T, K>(this Writer<Out, Map<K, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, TryOption<T>> Where<Out, T>(this Writer<Out, TryOption<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Try<T>> Where<Out, T>(this Writer<Out, Try<T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Either<L, T>> Where<Out, T, L>(this Writer<Out, Either<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, EitherUnsafe<L, T>> Where<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static Writer<Out, Writer<Out, T>> Where<Out, T>(this Writer<Out, Writer<Out, T>> self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));
        public static IEnumerable<IEnumerable<V>> SelectMany<T, U, V>(this IEnumerable<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Option<V>> SelectMany<T, U, V>(this IEnumerable<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<OptionUnsafe<V>> SelectMany<T, U, V>(this IEnumerable<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Lst<V>> SelectMany<T, U, V>(this IEnumerable<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Map<K, V>> SelectMany<T, K, U, V>(this IEnumerable<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<TryOption<V>> SelectMany<T, U, V>(this IEnumerable<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Try<V>> SelectMany<T, U, V>(this IEnumerable<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Either<L, V>> SelectMany<T, L, U, V>(this IEnumerable<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this IEnumerable<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static IEnumerable<Writer<Out, V>> SelectMany<T, Out, U, V>(this IEnumerable<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<IEnumerable<V>> SelectMany<T, U, V>(this Option<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Option<V>> SelectMany<T, U, V>(this Option<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<OptionUnsafe<V>> SelectMany<T, U, V>(this Option<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Lst<V>> SelectMany<T, U, V>(this Option<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Map<K, V>> SelectMany<T, K, U, V>(this Option<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<TryOption<V>> SelectMany<T, U, V>(this Option<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Try<V>> SelectMany<T, U, V>(this Option<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Either<L, V>> SelectMany<T, L, U, V>(this Option<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this Option<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Option<Writer<Out, V>> SelectMany<T, Out, U, V>(this Option<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<IEnumerable<V>> SelectMany<T, U, V>(this OptionUnsafe<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Option<V>> SelectMany<T, U, V>(this OptionUnsafe<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<OptionUnsafe<V>> SelectMany<T, U, V>(this OptionUnsafe<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Lst<V>> SelectMany<T, U, V>(this OptionUnsafe<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Map<K, V>> SelectMany<T, K, U, V>(this OptionUnsafe<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<TryOption<V>> SelectMany<T, U, V>(this OptionUnsafe<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Try<V>> SelectMany<T, U, V>(this OptionUnsafe<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Either<L, V>> SelectMany<T, L, U, V>(this OptionUnsafe<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this OptionUnsafe<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static OptionUnsafe<Writer<Out, V>> SelectMany<T, Out, U, V>(this OptionUnsafe<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<IEnumerable<V>> SelectMany<T, U, V>(this Lst<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Option<V>> SelectMany<T, U, V>(this Lst<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<OptionUnsafe<V>> SelectMany<T, U, V>(this Lst<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Lst<V>> SelectMany<T, U, V>(this Lst<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Map<K, V>> SelectMany<T, K, U, V>(this Lst<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<TryOption<V>> SelectMany<T, U, V>(this Lst<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Try<V>> SelectMany<T, U, V>(this Lst<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Either<L, V>> SelectMany<T, L, U, V>(this Lst<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this Lst<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Lst<Writer<Out, V>> SelectMany<T, Out, U, V>(this Lst<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, IEnumerable<V>> SelectMany<K, T, U, V>(this Map<K, IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Option<V>> SelectMany<K, T, U, V>(this Map<K, Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, OptionUnsafe<V>> SelectMany<K, T, U, V>(this Map<K, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Lst<V>> SelectMany<K, T, U, V>(this Map<K, Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Map<K, V>> SelectMany<K, T, U, V>(this Map<K, Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, TryOption<V>> SelectMany<K, T, U, V>(this Map<K, TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Try<V>> SelectMany<K, T, U, V>(this Map<K, Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Either<L, V>> SelectMany<K, T, L, U, V>(this Map<K, Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, EitherUnsafe<L, V>> SelectMany<K, T, L, U, V>(this Map<K, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Map<K, Writer<Out, V>> SelectMany<K, T, Out, U, V>(this Map<K, Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<IEnumerable<V>> SelectMany<T, U, V>(this TryOption<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Option<V>> SelectMany<T, U, V>(this TryOption<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<OptionUnsafe<V>> SelectMany<T, U, V>(this TryOption<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Lst<V>> SelectMany<T, U, V>(this TryOption<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Map<K, V>> SelectMany<T, K, U, V>(this TryOption<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<TryOption<V>> SelectMany<T, U, V>(this TryOption<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Try<V>> SelectMany<T, U, V>(this TryOption<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Either<L, V>> SelectMany<T, L, U, V>(this TryOption<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this TryOption<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static TryOption<Writer<Out, V>> SelectMany<T, Out, U, V>(this TryOption<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<IEnumerable<V>> SelectMany<T, U, V>(this Try<IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Option<V>> SelectMany<T, U, V>(this Try<Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<OptionUnsafe<V>> SelectMany<T, U, V>(this Try<OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Lst<V>> SelectMany<T, U, V>(this Try<Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Map<K, V>> SelectMany<T, K, U, V>(this Try<Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<TryOption<V>> SelectMany<T, U, V>(this Try<TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Try<V>> SelectMany<T, U, V>(this Try<Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Either<L, V>> SelectMany<T, L, U, V>(this Try<Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<EitherUnsafe<L, V>> SelectMany<T, L, U, V>(this Try<EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Try<Writer<Out, V>> SelectMany<T, Out, U, V>(this Try<Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, IEnumerable<V>> SelectMany<L, T, U, V>(this Either<L, IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Option<V>> SelectMany<L, T, U, V>(this Either<L, Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, OptionUnsafe<V>> SelectMany<L, T, U, V>(this Either<L, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Lst<V>> SelectMany<L, T, U, V>(this Either<L, Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Map<K, V>> SelectMany<L, T, K, U, V>(this Either<L, Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, TryOption<V>> SelectMany<L, T, U, V>(this Either<L, TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Try<V>> SelectMany<L, T, U, V>(this Either<L, Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Either<L, V>> SelectMany<L, T, U, V>(this Either<L, Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, EitherUnsafe<L, V>> SelectMany<L, T, U, V>(this Either<L, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Either<L, Writer<Out, V>> SelectMany<L, T, Out, U, V>(this Either<L, Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, IEnumerable<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Option<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, OptionUnsafe<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Lst<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Map<K, V>> SelectMany<L, T, K, U, V>(this EitherUnsafe<L, Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, TryOption<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Try<V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Either<L, V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, EitherUnsafe<L, V>> SelectMany<L, T, U, V>(this EitherUnsafe<L, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static EitherUnsafe<L, Writer<Out, V>> SelectMany<L, T, Out, U, V>(this EitherUnsafe<L, Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, IEnumerable<V>> SelectMany<Out, T, U, V>(this Writer<Out, IEnumerable<T>> self, Func<T, IEnumerable<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Option<V>> SelectMany<Out, T, U, V>(this Writer<Out, Option<T>> self, Func<T, Option<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, OptionUnsafe<V>> SelectMany<Out, T, U, V>(this Writer<Out, OptionUnsafe<T>> self, Func<T, OptionUnsafe<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Lst<V>> SelectMany<Out, T, U, V>(this Writer<Out, Lst<T>> self, Func<T, Lst<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Map<K, V>> SelectMany<Out, T, K, U, V>(this Writer<Out, Map<K, T>> self, Func<T, Map<K, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, TryOption<V>> SelectMany<Out, T, U, V>(this Writer<Out, TryOption<T>> self, Func<T, TryOption<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Try<V>> SelectMany<Out, T, U, V>(this Writer<Out, Try<T>> self, Func<T, Try<U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Either<L, V>> SelectMany<Out, T, L, U, V>(this Writer<Out, Either<L, T>> self, Func<T, Either<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, EitherUnsafe<L, V>> SelectMany<Out, T, L, U, V>(this Writer<Out, EitherUnsafe<L, T>> self, Func<T, EitherUnsafe<L, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static Writer<Out, Writer<Out, V>> SelectMany<Out, T, U, V>(this Writer<Out, Writer<Out, T>> self, Func<T, Writer<Out, U>> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));
        public static T LiftT<T>(this IEnumerable<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this IEnumerable<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this IEnumerable<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this IEnumerable<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this IEnumerable<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this IEnumerable<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this IEnumerable<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this IEnumerable<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this IEnumerable<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this IEnumerable<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this Option<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Option<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Option<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Option<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this Option<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this OptionUnsafe<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this OptionUnsafe<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this OptionUnsafe<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this OptionUnsafe<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this OptionUnsafe<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this Lst<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Lst<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Lst<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Lst<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this Lst<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T>(this Map<K, Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T, L>(this Map<K, Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T, L>(this Map<K, EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<K, T, Out>(this Map<K, Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this TryOption<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this TryOption<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this TryOption<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this TryOption<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this TryOption<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, K>(this Try<Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T>(this Try<Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Try<Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, L>(this Try<EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<T, Out>(this Try<Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T, K>(this Either<L, Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this Either<L, EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T, Out>(this Either<L, Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T, K>(this EitherUnsafe<L, Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T>(this EitherUnsafe<L, EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<L, T, Out>(this EitherUnsafe<L, Writer<Out, T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, IEnumerable<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, Option<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, OptionUnsafe<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, Lst<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T, K>(this Writer<Out, Map<K, T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, TryOption<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, Try<T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T, L>(this Writer<Out, Either<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T, L>(this Writer<Out, EitherUnsafe<L, T>> self) => self.ValueT().ValueT();
        public static T LiftT<Out, T>(this Writer<Out, Writer<Out, T>> self) => self.ValueT().ValueT();
        
        private static IEnumerable<T> EnumerableCtor<T>(IEnumerable<T> m) => m;
        private static IEnumerable<T> EnumerableCtor<T>(T v) => new T [1] {v};
        private static Reader<Env,T> ReaderCtor<Env,T>(Reader<Env,T> rdr) => rdr;
        private static Reader<Env,T> ReaderCtor<Env,T>(T v) => env => v;
        private static State<S, T> StateCtor<S, T>(State<S, T> s) => s;
        private static State<S, T> StateCtor<S, T>(T v) => s => new StateResult<S, T>(s,v);
        private static Map<K, T> MapCtor<K, T>(Map<K, T> m) => m;
        private static Map<K, T> MapCtor<K, T>(T v) => Prelude.map(Prelude.tuple(default(K),v));
   }
}