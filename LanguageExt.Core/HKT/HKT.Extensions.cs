using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    /// <summary>
    /// Monad transformer for Arr, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class ArrT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Arr<A>> ma) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Arr<B>> BindT< A, B>(this Arr<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Arr<B>></returns>
        [Pure]
        public static Arr<Arr<B>> Traverse< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Arr<A>></returns>
        [Pure]
        public static Arr<Arr<A>> Sequence< A>(this Arr<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Arr<B>> MapT< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Arr<A>> ma, Action<A> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Arr<A>> FilterT< A>(this Arr<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Arr<A>> Where< A>(this Arr<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Arr<B>> Select< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Arr<C>> SelectMany< A, B, C>(
            this Arr<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MArr<Arr<C>>, Arr<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Arr<A>> PlusT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Arr<A>> SubtractT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Arr<A>> ProductT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Arr<A>> DivideT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Arr<A>> AppendT<SEMI,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Arr<A>></param>
        /// <returns>Arr<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Arr<A>> fa) =>
            FArr< Arr<A>, Arr<B>>.Inst.Apply(
                 MArr< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Arr<A>></param>
        /// <param name="fb">Monad of Arr<Arr<A>></param>
        /// <returns>Arr<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Arr<A>> fa, Arr<Arr<B>> fb) =>
            FArr< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MArr< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Arr<A>> ma) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Arr<B>> BindT< A, B>(this HashSet<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<HashSet<B>></returns>
        [Pure]
        public static Arr<HashSet<B>> Traverse< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<HashSet<A>></returns>
        [Pure]
        public static Arr<HashSet<A>> Sequence< A>(this HashSet<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Arr<B>> MapT< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Arr<A>> ma, Action<A> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Arr<A>> FilterT< A>(this HashSet<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Arr<A>> Where< A>(this HashSet<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Arr<B>> Select< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Arr<C>> SelectMany< A, B, C>(
            this HashSet<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MHashSet<Arr<C>>, HashSet<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Arr<A>> PlusT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Arr<A>> SubtractT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Arr<A>> ProductT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Arr<A>> DivideT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Arr<A>> AppendT<SEMI,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Arr<A>></param>
        /// <returns>HashSet<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Arr<A>> fa) =>
            FHashSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MHashSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Arr<A>></param>
        /// <param name="fb">Monad of HashSet<Arr<A>></param>
        /// <returns>HashSet<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Arr<A>> fa, HashSet<Arr<B>> fb) =>
            FHashSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MHashSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Arr<A>> ma) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Arr<B>> BindT< A, B>(this Lst<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Lst<B>></returns>
        [Pure]
        public static Arr<Lst<B>> Traverse< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Lst<A>></returns>
        [Pure]
        public static Arr<Lst<A>> Sequence< A>(this Lst<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Arr<B>> MapT< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Arr<A>> ma, Action<A> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Arr<A>> FilterT< A>(this Lst<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Arr<A>> Where< A>(this Lst<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Arr<B>> Select< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Arr<C>> SelectMany< A, B, C>(
            this Lst<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MLst<Arr<C>>, Lst<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Arr<A>> PlusT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Arr<A>> SubtractT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Arr<A>> ProductT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Arr<A>> DivideT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Arr<A>> AppendT<SEMI,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Arr<A>></param>
        /// <returns>Lst<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Arr<A>> fa) =>
            FLst< Arr<A>, Arr<B>>.Inst.Apply(
                 MLst< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Arr<A>></param>
        /// <param name="fb">Monad of Lst<Arr<A>></param>
        /// <returns>Lst<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Arr<A>> fa, Lst<Arr<B>> fb) =>
            FLst< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MLst< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Arr<A>> ma) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Arr<B>> BindT< A, B>(this Option<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Option<B>></returns>
        [Pure]
        public static Arr<Option<B>> Traverse< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Option<A>></returns>
        [Pure]
        public static Arr<Option<A>> Sequence< A>(this Option<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Arr<B>> MapT< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Arr<A>> ma, Action<A> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Arr<A>> FilterT< A>(this Option<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Arr<A>> Where< A>(this Option<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Arr<B>> Select< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Arr<C>> SelectMany< A, B, C>(
            this Option<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MOption<Arr<C>>, Option<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Arr<A>> PlusT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Arr<A>> SubtractT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Arr<A>> ProductT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Arr<A>> DivideT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Arr<A>> AppendT<SEMI,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Arr<A>></param>
        /// <returns>Option<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Arr<A>> fa) =>
            FOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Arr<A>></param>
        /// <param name="fb">Monad of Option<Arr<A>></param>
        /// <returns>Option<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Arr<A>> fa, Option<Arr<B>> fb) =>
            FOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Arr<A>> ma) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> BindT< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<OptionUnsafe<B>></returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<OptionUnsafe<A>></returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> MapT< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Arr<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> FilterT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> Where< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> Select< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Arr<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MOptionUnsafe<Arr<C>>, OptionUnsafe<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> PlusT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> SubtractT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> ProductT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> DivideT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> AppendT<SEMI,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Arr<A>></param>
        /// <returns>OptionUnsafe<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Arr<A>> fa) =>
            FOptionUnsafe< Arr<A>, Arr<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Arr<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Arr<A>></param>
        /// <returns>OptionUnsafe<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Arr<A>> fa, OptionUnsafe<Arr<B>> fb) =>
            FOptionUnsafe< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOptionUnsafe< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Arr<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Arr<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Arr<A>> ma) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Arr<B>> BindT<L, A, B>(this Either<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Either<L, B>></returns>
        [Pure]
        public static Arr<Either<L, B>> Traverse<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Either<L, A>></returns>
        [Pure]
        public static Arr<Either<L, A>> Sequence<L, A>(this Either<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Arr<B>> MapT<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Arr<A>> FilterT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Arr<A>> Where<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Arr<B>> Select<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Arr<C>> SelectMany<L, A, B, C>(
            this Either<L, Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MEither<L, Arr<C>>, Either<L, Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Arr<A>> PlusT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Arr<A>> SubtractT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Arr<A>> ProductT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Arr<A>> DivideT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Arr<A>> AppendT<SEMI, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Arr<A>></param>
        /// <returns>Either<L, Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Arr<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Arr<A>> fa) =>
            FEither<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEither<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Arr<A>></param>
        /// <param name="fb">Monad of Either<L, Arr<A>></param>
        /// <returns>Either<L, Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Arr<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Arr<A>> fa, Either<L, Arr<B>> fb) =>
            FEither<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEither<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Arr<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Arr<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Arr<A>> ma) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> BindT<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> MapT<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> FilterT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> Where<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> Select<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Arr<C>>, EitherUnsafe<L, Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Arr<A>></param>
        /// <returns>EitherUnsafe<L, Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Arr<A>> fa) =>
            FEitherUnsafe<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Arr<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Arr<A>></param>
        /// <returns>EitherUnsafe<L, Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Arr<A>> fa, EitherUnsafe<L, Arr<B>> fb) =>
            FEitherUnsafe<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Arr<A>> ma) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Arr<B>> BindT< A, B>(this Task<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Task<B>></returns>
        [Pure]
        public static Arr<Task<B>> Traverse< A, B>(this Task<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Task<A>></returns>
        [Pure]
        public static Arr<Task<A>> Sequence< A>(this Task<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Arr<B>> MapT< A, B>(this Task<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Arr<A>> ma, Action<A> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Arr<A>> FilterT< A>(this Task<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Arr<A>> Where< A>(this Task<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Arr<B>> Select< A, B>(this Task<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Arr<C>> SelectMany< A, B, C>(
            this Task<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MTask<Arr<C>>, Task<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Arr<A>> PlusT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Arr<A>> SubtractT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Arr<A>> ProductT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Arr<A>> DivideT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Arr<A>> AppendT<SEMI,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Arr<A>></param>
        /// <returns>Task<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Arr<A>> fa) =>
            FTask< Arr<A>, Arr<B>>.Inst.Apply(
                 MTask< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Arr<A>></param>
        /// <param name="fb">Monad of Task<Arr<A>></param>
        /// <returns>Task<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Arr<A>> fa, Task<Arr<B>> fb) =>
            FTask< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTask< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Arr<A>> ma) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Arr<B>> BindT< A, B>(this Try<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Try<B>></returns>
        [Pure]
        public static Arr<Try<B>> Traverse< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Try<A>></returns>
        [Pure]
        public static Arr<Try<A>> Sequence< A>(this Try<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Arr<B>> MapT< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Arr<A>> ma, Action<A> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Arr<A>> FilterT< A>(this Try<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Arr<A>> Where< A>(this Try<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Arr<B>> Select< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Arr<C>> SelectMany< A, B, C>(
            this Try<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MTry<Arr<C>>, Try<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Arr<A>> PlusT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Arr<A>> SubtractT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Arr<A>> ProductT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Arr<A>> DivideT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Arr<A>> AppendT<SEMI,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Arr<A>></param>
        /// <returns>Try<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Arr<A>> fa) =>
            FTry< Arr<A>, Arr<B>>.Inst.Apply(
                 MTry< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Arr<A>></param>
        /// <param name="fb">Monad of Try<Arr<A>></param>
        /// <returns>Try<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Arr<A>> fa, Try<Arr<B>> fb) =>
            FTry< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTry< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Arr<A>> ma) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Arr<B>> BindT< A, B>(this TryAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryAsync<B>></returns>
        [Pure]
        public static Arr<TryAsync<B>> Traverse< A, B>(this TryAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryAsync<A>></returns>
        [Pure]
        public static Arr<TryAsync<A>> Sequence< A>(this TryAsync<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Arr<B>> MapT< A, B>(this TryAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Arr<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Arr<A>> FilterT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Arr<A>> Where< A>(this TryAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Arr<B>> Select< A, B>(this TryAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Arr<C>> SelectMany< A, B, C>(
            this TryAsync<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MTryAsync<Arr<C>>, TryAsync<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Arr<A>> PlusT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Arr<A>> SubtractT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Arr<A>> ProductT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Arr<A>> DivideT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Arr<A>> AppendT<SEMI,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Arr<A>></param>
        /// <returns>TryAsync<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Arr<A>> fa) =>
            FTryAsync< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryAsync< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Arr<A>></param>
        /// <param name="fb">Monad of TryAsync<Arr<A>></param>
        /// <returns>TryAsync<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Arr<A>> fa, TryAsync<Arr<B>> fb) =>
            FTryAsync< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Arr<A>> ma) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Arr<B>> BindT< A, B>(this TryOption<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOption<B>></returns>
        [Pure]
        public static Arr<TryOption<B>> Traverse< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOption<A>></returns>
        [Pure]
        public static Arr<TryOption<A>> Sequence< A>(this TryOption<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Arr<B>> MapT< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Arr<A>> ma, Action<A> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Arr<A>> FilterT< A>(this TryOption<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Arr<A>> Where< A>(this TryOption<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Arr<B>> Select< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Arr<C>> SelectMany< A, B, C>(
            this TryOption<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MTryOption<Arr<C>>, TryOption<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Arr<A>> PlusT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Arr<A>> SubtractT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Arr<A>> ProductT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Arr<A>> DivideT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Arr<A>> AppendT<SEMI,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Arr<A>></param>
        /// <returns>TryOption<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Arr<A>> fa) =>
            FTryOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Arr<A>></param>
        /// <param name="fb">Monad of TryOption<Arr<A>></param>
        /// <returns>TryOption<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Arr<A>> fa, TryOption<Arr<B>> fb) =>
            FTryOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Arr<A>> ma) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> BindT< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOptionAsync<B>></returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOptionAsync<A>></returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> MapT< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Arr<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> FilterT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> Where< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> Select< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Arr<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MTryOptionAsync<Arr<C>>, TryOptionAsync<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> PlusT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> SubtractT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> ProductT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> DivideT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> AppendT<SEMI,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Arr<A>></param>
        /// <returns>TryOptionAsync<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Arr<A>> fa) =>
            FTryOptionAsync< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Arr<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Arr<A>></param>
        /// <returns>TryOptionAsync<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Arr<A>> fa, TryOptionAsync<Arr<B>> fb) =>
            FTryOptionAsync< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryOptionAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Arr<A>> ma) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Arr<B>> BindT< A, B>(this IEnumerable<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<IEnumerable<B>></returns>
        [Pure]
        public static Arr<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<IEnumerable<A>></returns>
        [Pure]
        public static Arr<IEnumerable<A>> Sequence< A>(this IEnumerable<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Arr<B>> MapT< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Arr<A>> ma, Action<A> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Arr<A>> FilterT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Arr<A>> Where< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Arr<B>> Select< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Arr<C>> SelectMany< A, B, C>(
            this IEnumerable<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MSeq<Arr<C>>, IEnumerable<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> PlusT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> SubtractT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> ProductT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> DivideT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> AppendT<SEMI,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Arr<A>></param>
        /// <returns>IEnumerable<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Arr<A>> fa) =>
            FSeq< Arr<A>, Arr<B>>.Inst.Apply(
                 MSeq< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Arr<A>></param>
        /// <param name="fb">Monad of IEnumerable<Arr<A>></param>
        /// <returns>IEnumerable<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Arr<A>> fa, IEnumerable<Arr<B>> fb) =>
            FSeq< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSeq< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Arr<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Arr<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Arr<A>> ma) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Arr<B>> BindT< A, B>(this Set<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Set<B>></returns>
        [Pure]
        public static Arr<Set<B>> Traverse< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Arr<A>>, traverses the inner
        /// values of type A, and returns Arr<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Set<A>></returns>
        [Pure]
        public static Arr<Set<A>> Sequence< A>(this Set<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Arr<B>> MapT< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Arr<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Arr<A>> ma, Action<A> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Arr<A>> FilterT< A>(this Set<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Arr<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Arr<A>> Where< A>(this Set<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Arr<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Arr<B>> Select< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Arr<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Arr<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Arr<C>> SelectMany< A, B, C>(
            this Set<Arr<A>> ma,
            Func<A, Arr<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                    .Inst.Bind<MSet<Arr<C>>, Set<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MArr<B>).Bind<MArr<C>, Arr<C>, C>(mb, b => default(MArr<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Arr<A>> PlusT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Arr<A>> SubtractT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Arr<A>> ProductT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Arr<A>> DivideT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Arr<A>> AppendT<SEMI,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Arr<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Arr<A>></param>
        /// <returns>Set<Arr<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Arr<A>> fa) =>
            FSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => FArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Arr<A>></param>
        /// <param name="fb">Monad of Set<Arr<A>></param>
        /// <returns>Set<Arr<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Arr<A>> fa, Set<Arr<B>> fb) =>
            FSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            FArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for HashSet, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class HashSetT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<HashSet<A>> ma) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<HashSet<B>> BindT< A, B>(this Arr<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Arr<B>></returns>
        [Pure]
        public static HashSet<Arr<B>> Traverse< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Arr<A>></returns>
        [Pure]
        public static HashSet<Arr<A>> Sequence< A>(this Arr<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<HashSet<B>> MapT< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<HashSet<A>> ma, Action<A> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<HashSet<A>> FilterT< A>(this Arr<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<HashSet<A>> Where< A>(this Arr<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<HashSet<B>> Select< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<HashSet<C>> SelectMany< A, B, C>(
            this Arr<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MArr<HashSet<C>>, Arr<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<HashSet<A>> PlusT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<HashSet<A>> SubtractT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<HashSet<A>> ProductT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<HashSet<A>> DivideT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<HashSet<A>> AppendT<SEMI,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<HashSet<A>></param>
        /// <returns>Arr<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<HashSet<A>> fa) =>
            FArr< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MArr< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<HashSet<A>></param>
        /// <param name="fb">Monad of Arr<HashSet<A>></param>
        /// <returns>Arr<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<HashSet<A>> fa, Arr<HashSet<B>> fb) =>
            FArr< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MArr< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<HashSet<A>> ma) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<HashSet<B>> BindT< A, B>(this HashSet<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<HashSet<B>></returns>
        [Pure]
        public static HashSet<HashSet<B>> Traverse< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<HashSet<A>></returns>
        [Pure]
        public static HashSet<HashSet<A>> Sequence< A>(this HashSet<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<HashSet<B>> MapT< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<HashSet<A>> ma, Action<A> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<HashSet<A>> FilterT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<HashSet<A>> Where< A>(this HashSet<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<HashSet<B>> Select< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<HashSet<C>> SelectMany< A, B, C>(
            this HashSet<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MHashSet<HashSet<C>>, HashSet<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<HashSet<A>> PlusT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<HashSet<A>> SubtractT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<HashSet<A>> ProductT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<HashSet<A>> DivideT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<HashSet<A>> AppendT<SEMI,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<HashSet<A>></param>
        /// <returns>HashSet<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<HashSet<A>> fa) =>
            FHashSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MHashSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<HashSet<A>></param>
        /// <param name="fb">Monad of HashSet<HashSet<A>></param>
        /// <returns>HashSet<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<HashSet<A>> fa, HashSet<HashSet<B>> fb) =>
            FHashSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MHashSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<HashSet<A>> ma) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<HashSet<B>> BindT< A, B>(this Lst<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Lst<B>></returns>
        [Pure]
        public static HashSet<Lst<B>> Traverse< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Lst<A>></returns>
        [Pure]
        public static HashSet<Lst<A>> Sequence< A>(this Lst<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<HashSet<B>> MapT< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<HashSet<A>> ma, Action<A> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<HashSet<A>> FilterT< A>(this Lst<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<HashSet<A>> Where< A>(this Lst<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<HashSet<B>> Select< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<HashSet<C>> SelectMany< A, B, C>(
            this Lst<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MLst<HashSet<C>>, Lst<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<HashSet<A>> PlusT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<HashSet<A>> SubtractT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<HashSet<A>> ProductT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<HashSet<A>> DivideT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<HashSet<A>> AppendT<SEMI,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<HashSet<A>></param>
        /// <returns>Lst<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<HashSet<A>> fa) =>
            FLst< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MLst< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<HashSet<A>></param>
        /// <param name="fb">Monad of Lst<HashSet<A>></param>
        /// <returns>Lst<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<HashSet<A>> fa, Lst<HashSet<B>> fb) =>
            FLst< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MLst< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<HashSet<A>> ma) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<HashSet<B>> BindT< A, B>(this Option<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Option<B>></returns>
        [Pure]
        public static HashSet<Option<B>> Traverse< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Option<A>></returns>
        [Pure]
        public static HashSet<Option<A>> Sequence< A>(this Option<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<HashSet<B>> MapT< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<HashSet<A>> ma, Action<A> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<HashSet<A>> FilterT< A>(this Option<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<HashSet<A>> Where< A>(this Option<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<HashSet<B>> Select< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<HashSet<C>> SelectMany< A, B, C>(
            this Option<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MOption<HashSet<C>>, Option<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<HashSet<A>> PlusT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<HashSet<A>> SubtractT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<HashSet<A>> ProductT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<HashSet<A>> DivideT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<HashSet<A>> AppendT<SEMI,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<HashSet<A>></param>
        /// <returns>Option<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Option<HashSet<A>> fa) =>
            FOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<HashSet<A>></param>
        /// <param name="fb">Monad of Option<HashSet<A>></param>
        /// <returns>Option<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<HashSet<A>> fa, Option<HashSet<B>> fb) =>
            FOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<HashSet<A>> ma) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> BindT< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<OptionUnsafe<B>></returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<OptionUnsafe<A>></returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> MapT< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<HashSet<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> FilterT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> Where< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> Select< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<HashSet<C>> SelectMany< A, B, C>(
            this OptionUnsafe<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MOptionUnsafe<HashSet<C>>, OptionUnsafe<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> PlusT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> SubtractT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> ProductT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> DivideT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> AppendT<SEMI,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<HashSet<A>></param>
        /// <returns>OptionUnsafe<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<HashSet<A>> fa) =>
            FOptionUnsafe< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOptionUnsafe< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<HashSet<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<HashSet<A>></param>
        /// <returns>OptionUnsafe<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<HashSet<A>> fa, OptionUnsafe<HashSet<B>> fb) =>
            FOptionUnsafe< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOptionUnsafe< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, HashSet<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, HashSet<A>> ma) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, HashSet<B>> BindT<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Either<L, B>></returns>
        [Pure]
        public static HashSet<Either<L, B>> Traverse<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Either<L, A>></returns>
        [Pure]
        public static HashSet<Either<L, A>> Sequence<L, A>(this Either<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, HashSet<B>> MapT<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, HashSet<A>> FilterT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, HashSet<A>> Where<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, HashSet<B>> Select<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, HashSet<C>> SelectMany<L, A, B, C>(
            this Either<L, HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MEither<L, HashSet<C>>, Either<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, HashSet<A>> PlusT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, HashSet<A>> SubtractT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, HashSet<A>> ProductT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, HashSet<A>> DivideT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, HashSet<A>> AppendT<SEMI, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, HashSet<A>></param>
        /// <returns>Either<L, HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, HashSet<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, HashSet<A>> fa) =>
            FEither<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEither<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, HashSet<A>></param>
        /// <param name="fb">Monad of Either<L, HashSet<A>></param>
        /// <returns>Either<L, HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, HashSet<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, HashSet<A>> fa, Either<L, HashSet<B>> fb) =>
            FEither<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEither<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, HashSet<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, HashSet<A>> ma) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> BindT<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<EitherUnsafe<L, B>></returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<EitherUnsafe<L, A>></returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> MapT<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> FilterT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> Where<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> Select<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, HashSet<C>>, EitherUnsafe<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, HashSet<A>></param>
        /// <returns>EitherUnsafe<L, HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, HashSet<A>> fa) =>
            FEitherUnsafe<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, HashSet<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, HashSet<A>></param>
        /// <returns>EitherUnsafe<L, HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, HashSet<A>> fa, EitherUnsafe<L, HashSet<B>> fb) =>
            FEitherUnsafe<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<HashSet<A>> ma) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<HashSet<B>> BindT< A, B>(this Task<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Task<B>></returns>
        [Pure]
        public static HashSet<Task<B>> Traverse< A, B>(this Task<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Task<A>></returns>
        [Pure]
        public static HashSet<Task<A>> Sequence< A>(this Task<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<HashSet<B>> MapT< A, B>(this Task<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<HashSet<A>> ma, Action<A> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<HashSet<A>> FilterT< A>(this Task<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<HashSet<A>> Where< A>(this Task<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<HashSet<B>> Select< A, B>(this Task<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<HashSet<C>> SelectMany< A, B, C>(
            this Task<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MTask<HashSet<C>>, Task<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<HashSet<A>> PlusT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<HashSet<A>> SubtractT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<HashSet<A>> ProductT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<HashSet<A>> DivideT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<HashSet<A>> AppendT<SEMI,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<HashSet<A>></param>
        /// <returns>Task<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Task<HashSet<A>> fa) =>
            FTask< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTask< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<HashSet<A>></param>
        /// <param name="fb">Monad of Task<HashSet<A>></param>
        /// <returns>Task<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<HashSet<A>> fa, Task<HashSet<B>> fb) =>
            FTask< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTask< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<HashSet<A>> ma) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<HashSet<B>> BindT< A, B>(this Try<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Try<B>></returns>
        [Pure]
        public static HashSet<Try<B>> Traverse< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Try<A>></returns>
        [Pure]
        public static HashSet<Try<A>> Sequence< A>(this Try<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<HashSet<B>> MapT< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<HashSet<A>> ma, Action<A> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<HashSet<A>> FilterT< A>(this Try<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<HashSet<A>> Where< A>(this Try<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<HashSet<B>> Select< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<HashSet<C>> SelectMany< A, B, C>(
            this Try<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MTry<HashSet<C>>, Try<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<HashSet<A>> PlusT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<HashSet<A>> SubtractT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<HashSet<A>> ProductT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<HashSet<A>> DivideT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<HashSet<A>> AppendT<SEMI,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<HashSet<A>></param>
        /// <returns>Try<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Try<HashSet<A>> fa) =>
            FTry< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTry< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<HashSet<A>></param>
        /// <param name="fb">Monad of Try<HashSet<A>></param>
        /// <returns>Try<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<HashSet<A>> fa, Try<HashSet<B>> fb) =>
            FTry< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTry< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<HashSet<A>> ma) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<HashSet<B>> BindT< A, B>(this TryAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryAsync<B>></returns>
        [Pure]
        public static HashSet<TryAsync<B>> Traverse< A, B>(this TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryAsync<A>></returns>
        [Pure]
        public static HashSet<TryAsync<A>> Sequence< A>(this TryAsync<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<HashSet<B>> MapT< A, B>(this TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<HashSet<A>> FilterT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<HashSet<A>> Where< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<HashSet<B>> Select< A, B>(this TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<HashSet<C>> SelectMany< A, B, C>(
            this TryAsync<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MTryAsync<HashSet<C>>, TryAsync<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> PlusT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> SubtractT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> ProductT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> DivideT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> AppendT<SEMI,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<HashSet<A>></param>
        /// <returns>TryAsync<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<HashSet<A>> fa) =>
            FTryAsync< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryAsync< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<HashSet<A>></param>
        /// <param name="fb">Monad of TryAsync<HashSet<A>></param>
        /// <returns>TryAsync<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<HashSet<A>> fa, TryAsync<HashSet<B>> fb) =>
            FTryAsync< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<HashSet<A>> ma) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<HashSet<B>> BindT< A, B>(this TryOption<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOption<B>></returns>
        [Pure]
        public static HashSet<TryOption<B>> Traverse< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOption<A>></returns>
        [Pure]
        public static HashSet<TryOption<A>> Sequence< A>(this TryOption<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<HashSet<B>> MapT< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<HashSet<A>> FilterT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<HashSet<A>> Where< A>(this TryOption<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<HashSet<B>> Select< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<HashSet<C>> SelectMany< A, B, C>(
            this TryOption<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MTryOption<HashSet<C>>, TryOption<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<HashSet<A>> PlusT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<HashSet<A>> SubtractT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<HashSet<A>> ProductT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<HashSet<A>> DivideT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<HashSet<A>> AppendT<SEMI,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<HashSet<A>></param>
        /// <returns>TryOption<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<HashSet<A>> fa) =>
            FTryOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<HashSet<A>></param>
        /// <param name="fb">Monad of TryOption<HashSet<A>></param>
        /// <returns>TryOption<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<HashSet<A>> fa, TryOption<HashSet<B>> fb) =>
            FTryOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<HashSet<A>> ma) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> BindT< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOptionAsync<B>></returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOptionAsync<A>></returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> MapT< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> FilterT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> Where< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> Select< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<HashSet<C>> SelectMany< A, B, C>(
            this TryOptionAsync<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MTryOptionAsync<HashSet<C>>, TryOptionAsync<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> PlusT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> SubtractT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> ProductT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> DivideT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> AppendT<SEMI,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<HashSet<A>></param>
        /// <returns>TryOptionAsync<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<HashSet<A>> fa) =>
            FTryOptionAsync< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryOptionAsync< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<HashSet<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<HashSet<A>></param>
        /// <returns>TryOptionAsync<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<HashSet<A>> fa, TryOptionAsync<HashSet<B>> fb) =>
            FTryOptionAsync< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryOptionAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<HashSet<A>> ma) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> BindT< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<IEnumerable<B>></returns>
        [Pure]
        public static HashSet<IEnumerable<B>> Traverse< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<IEnumerable<A>></returns>
        [Pure]
        public static HashSet<IEnumerable<A>> Sequence< A>(this IEnumerable<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> MapT< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<HashSet<A>> ma, Action<A> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> FilterT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> Where< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> Select< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<HashSet<C>> SelectMany< A, B, C>(
            this IEnumerable<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MSeq<HashSet<C>>, IEnumerable<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> PlusT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> SubtractT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> ProductT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> DivideT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> AppendT<SEMI,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<HashSet<A>></param>
        /// <returns>IEnumerable<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<HashSet<A>> fa) =>
            FSeq< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSeq< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<HashSet<A>></param>
        /// <param name="fb">Monad of IEnumerable<HashSet<A>></param>
        /// <returns>IEnumerable<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<HashSet<A>> fa, IEnumerable<HashSet<B>> fb) =>
            FSeq< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSeq< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<HashSet<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<HashSet<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<HashSet<A>> ma) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<HashSet<B>> BindT< A, B>(this Set<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Set<B>></returns>
        [Pure]
        public static HashSet<Set<B>> Traverse< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<HashSet<A>>, traverses the inner
        /// values of type A, and returns HashSet<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Set<A>></returns>
        [Pure]
        public static HashSet<Set<A>> Sequence< A>(this Set<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<HashSet<B>> MapT< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<HashSet<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<HashSet<A>> ma, Action<A> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<HashSet<A>> FilterT< A>(this Set<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<HashSet<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<HashSet<A>> Where< A>(this Set<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<HashSet<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<HashSet<B>> Select< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<HashSet<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<HashSet<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<HashSet<C>> SelectMany< A, B, C>(
            this Set<HashSet<A>> ma,
            Func<A, HashSet<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                    .Inst.Bind<MSet<HashSet<C>>, Set<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MHashSet<B>).Bind<MHashSet<C>, HashSet<C>, C>(mb, b => default(MHashSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<HashSet<A>> PlusT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<HashSet<A>> SubtractT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<HashSet<A>> ProductT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<HashSet<A>> DivideT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<HashSet<A>> AppendT<SEMI,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<HashSet<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<HashSet<A>></param>
        /// <returns>Set<HashSet<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Set<HashSet<A>> fa) =>
            FSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => FHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<HashSet<A>></param>
        /// <param name="fb">Monad of Set<HashSet<A>></param>
        /// <returns>Set<HashSet<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<HashSet<A>> fa, Set<HashSet<B>> fb) =>
            FSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            FHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Lst, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class LstT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Lst<A>> ma) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Lst<B>> BindT< A, B>(this Arr<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Arr<B>></returns>
        [Pure]
        public static Lst<Arr<B>> Traverse< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Arr<A>></returns>
        [Pure]
        public static Lst<Arr<A>> Sequence< A>(this Arr<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Lst<B>> MapT< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Lst<A>> ma, Action<A> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Lst<A>> FilterT< A>(this Arr<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Lst<A>> Where< A>(this Arr<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Lst<B>> Select< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Lst<C>> SelectMany< A, B, C>(
            this Arr<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MArr<Lst<C>>, Arr<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Lst<A>> PlusT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Lst<A>> SubtractT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Lst<A>> ProductT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Lst<A>> DivideT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Lst<A>> AppendT<SEMI,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Lst<A>></param>
        /// <returns>Arr<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Lst<A>> fa) =>
            FArr< Lst<A>, Lst<B>>.Inst.Apply(
                 MArr< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Lst<A>></param>
        /// <param name="fb">Monad of Arr<Lst<A>></param>
        /// <returns>Arr<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Lst<A>> fa, Arr<Lst<B>> fb) =>
            FArr< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MArr< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Lst<A>> ma) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Lst<B>> BindT< A, B>(this HashSet<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<HashSet<B>></returns>
        [Pure]
        public static Lst<HashSet<B>> Traverse< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<HashSet<A>></returns>
        [Pure]
        public static Lst<HashSet<A>> Sequence< A>(this HashSet<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Lst<B>> MapT< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Lst<A>> ma, Action<A> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Lst<A>> FilterT< A>(this HashSet<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Lst<A>> Where< A>(this HashSet<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Lst<B>> Select< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Lst<C>> SelectMany< A, B, C>(
            this HashSet<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MHashSet<Lst<C>>, HashSet<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Lst<A>> PlusT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Lst<A>> SubtractT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Lst<A>> ProductT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Lst<A>> DivideT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Lst<A>> AppendT<SEMI,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Lst<A>></param>
        /// <returns>HashSet<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Lst<A>> fa) =>
            FHashSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MHashSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Lst<A>></param>
        /// <param name="fb">Monad of HashSet<Lst<A>></param>
        /// <returns>HashSet<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Lst<A>> fa, HashSet<Lst<B>> fb) =>
            FHashSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MHashSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Lst<A>> ma) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Lst<B>> BindT< A, B>(this Lst<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Lst<B>></returns>
        [Pure]
        public static Lst<Lst<B>> Traverse< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Lst<A>></returns>
        [Pure]
        public static Lst<Lst<A>> Sequence< A>(this Lst<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Lst<B>> MapT< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Lst<A>> ma, Action<A> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Lst<A>> FilterT< A>(this Lst<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Lst<A>> Where< A>(this Lst<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Lst<B>> Select< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Lst<C>> SelectMany< A, B, C>(
            this Lst<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MLst<Lst<C>>, Lst<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Lst<A>> PlusT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Lst<A>> SubtractT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Lst<A>> ProductT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Lst<A>> DivideT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Lst<A>> AppendT<SEMI,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Lst<A>></param>
        /// <returns>Lst<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Lst<A>> fa) =>
            FLst< Lst<A>, Lst<B>>.Inst.Apply(
                 MLst< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Lst<A>></param>
        /// <param name="fb">Monad of Lst<Lst<A>></param>
        /// <returns>Lst<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Lst<A>> fa, Lst<Lst<B>> fb) =>
            FLst< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MLst< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Lst<A>> ma) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Lst<B>> BindT< A, B>(this Option<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Option<B>></returns>
        [Pure]
        public static Lst<Option<B>> Traverse< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Option<A>></returns>
        [Pure]
        public static Lst<Option<A>> Sequence< A>(this Option<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Lst<B>> MapT< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Lst<A>> ma, Action<A> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Lst<A>> FilterT< A>(this Option<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Lst<A>> Where< A>(this Option<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Lst<B>> Select< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Lst<C>> SelectMany< A, B, C>(
            this Option<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MOption<Lst<C>>, Option<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Lst<A>> PlusT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Lst<A>> SubtractT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Lst<A>> ProductT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Lst<A>> DivideT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Lst<A>> AppendT<SEMI,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Lst<A>></param>
        /// <returns>Option<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Lst<A>> fa) =>
            FOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Lst<A>></param>
        /// <param name="fb">Monad of Option<Lst<A>></param>
        /// <returns>Option<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Lst<A>> fa, Option<Lst<B>> fb) =>
            FOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Lst<A>> ma) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> BindT< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<OptionUnsafe<B>></returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<OptionUnsafe<A>></returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> MapT< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Lst<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> FilterT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> Where< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> Select< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Lst<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MOptionUnsafe<Lst<C>>, OptionUnsafe<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> PlusT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> SubtractT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> ProductT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> DivideT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> AppendT<SEMI,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Lst<A>></param>
        /// <returns>OptionUnsafe<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Lst<A>> fa) =>
            FOptionUnsafe< Lst<A>, Lst<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Lst<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Lst<A>></param>
        /// <returns>OptionUnsafe<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Lst<A>> fa, OptionUnsafe<Lst<B>> fb) =>
            FOptionUnsafe< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOptionUnsafe< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Lst<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Lst<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Lst<A>> ma) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Lst<B>> BindT<L, A, B>(this Either<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Either<L, B>></returns>
        [Pure]
        public static Lst<Either<L, B>> Traverse<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Either<L, A>></returns>
        [Pure]
        public static Lst<Either<L, A>> Sequence<L, A>(this Either<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Lst<B>> MapT<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Lst<A>> FilterT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Lst<A>> Where<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Lst<B>> Select<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Lst<C>> SelectMany<L, A, B, C>(
            this Either<L, Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MEither<L, Lst<C>>, Either<L, Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Lst<A>> PlusT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Lst<A>> SubtractT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Lst<A>> ProductT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Lst<A>> DivideT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Lst<A>> AppendT<SEMI, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Lst<A>></param>
        /// <returns>Either<L, Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Lst<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Lst<A>> fa) =>
            FEither<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEither<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Lst<A>></param>
        /// <param name="fb">Monad of Either<L, Lst<A>></param>
        /// <returns>Either<L, Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Lst<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Lst<A>> fa, Either<L, Lst<B>> fb) =>
            FEither<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEither<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Lst<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Lst<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Lst<A>> ma) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> BindT<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> MapT<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> FilterT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> Where<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> Select<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Lst<C>>, EitherUnsafe<L, Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Lst<A>></param>
        /// <returns>EitherUnsafe<L, Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Lst<A>> fa) =>
            FEitherUnsafe<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Lst<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Lst<A>></param>
        /// <returns>EitherUnsafe<L, Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Lst<A>> fa, EitherUnsafe<L, Lst<B>> fb) =>
            FEitherUnsafe<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Lst<A>> ma) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Lst<B>> BindT< A, B>(this Task<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Task<B>></returns>
        [Pure]
        public static Lst<Task<B>> Traverse< A, B>(this Task<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Task<A>></returns>
        [Pure]
        public static Lst<Task<A>> Sequence< A>(this Task<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Lst<B>> MapT< A, B>(this Task<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Lst<A>> ma, Action<A> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Lst<A>> FilterT< A>(this Task<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Lst<A>> Where< A>(this Task<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Lst<B>> Select< A, B>(this Task<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Lst<C>> SelectMany< A, B, C>(
            this Task<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MTask<Lst<C>>, Task<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Lst<A>> PlusT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Lst<A>> SubtractT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Lst<A>> ProductT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Lst<A>> DivideT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Lst<A>> AppendT<SEMI,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Lst<A>></param>
        /// <returns>Task<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Lst<A>> fa) =>
            FTask< Lst<A>, Lst<B>>.Inst.Apply(
                 MTask< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Lst<A>></param>
        /// <param name="fb">Monad of Task<Lst<A>></param>
        /// <returns>Task<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Lst<A>> fa, Task<Lst<B>> fb) =>
            FTask< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTask< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Lst<A>> ma) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Lst<B>> BindT< A, B>(this Try<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Try<B>></returns>
        [Pure]
        public static Lst<Try<B>> Traverse< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Try<A>></returns>
        [Pure]
        public static Lst<Try<A>> Sequence< A>(this Try<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Lst<B>> MapT< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Lst<A>> ma, Action<A> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Lst<A>> FilterT< A>(this Try<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Lst<A>> Where< A>(this Try<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Lst<B>> Select< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Lst<C>> SelectMany< A, B, C>(
            this Try<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MTry<Lst<C>>, Try<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Lst<A>> PlusT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Lst<A>> SubtractT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Lst<A>> ProductT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Lst<A>> DivideT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Lst<A>> AppendT<SEMI,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Lst<A>></param>
        /// <returns>Try<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Lst<A>> fa) =>
            FTry< Lst<A>, Lst<B>>.Inst.Apply(
                 MTry< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Lst<A>></param>
        /// <param name="fb">Monad of Try<Lst<A>></param>
        /// <returns>Try<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Lst<A>> fa, Try<Lst<B>> fb) =>
            FTry< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTry< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Lst<A>> ma) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Lst<B>> BindT< A, B>(this TryAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryAsync<B>></returns>
        [Pure]
        public static Lst<TryAsync<B>> Traverse< A, B>(this TryAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryAsync<A>></returns>
        [Pure]
        public static Lst<TryAsync<A>> Sequence< A>(this TryAsync<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Lst<B>> MapT< A, B>(this TryAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Lst<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Lst<A>> FilterT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Lst<A>> Where< A>(this TryAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Lst<B>> Select< A, B>(this TryAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Lst<C>> SelectMany< A, B, C>(
            this TryAsync<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MTryAsync<Lst<C>>, TryAsync<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Lst<A>> PlusT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Lst<A>> SubtractT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Lst<A>> ProductT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Lst<A>> DivideT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Lst<A>> AppendT<SEMI,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Lst<A>></param>
        /// <returns>TryAsync<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Lst<A>> fa) =>
            FTryAsync< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryAsync< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Lst<A>></param>
        /// <param name="fb">Monad of TryAsync<Lst<A>></param>
        /// <returns>TryAsync<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Lst<A>> fa, TryAsync<Lst<B>> fb) =>
            FTryAsync< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Lst<A>> ma) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Lst<B>> BindT< A, B>(this TryOption<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOption<B>></returns>
        [Pure]
        public static Lst<TryOption<B>> Traverse< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOption<A>></returns>
        [Pure]
        public static Lst<TryOption<A>> Sequence< A>(this TryOption<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Lst<B>> MapT< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Lst<A>> ma, Action<A> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Lst<A>> FilterT< A>(this TryOption<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Lst<A>> Where< A>(this TryOption<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Lst<B>> Select< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Lst<C>> SelectMany< A, B, C>(
            this TryOption<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MTryOption<Lst<C>>, TryOption<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Lst<A>> PlusT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Lst<A>> SubtractT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Lst<A>> ProductT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Lst<A>> DivideT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Lst<A>> AppendT<SEMI,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Lst<A>></param>
        /// <returns>TryOption<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Lst<A>> fa) =>
            FTryOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Lst<A>></param>
        /// <param name="fb">Monad of TryOption<Lst<A>></param>
        /// <returns>TryOption<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Lst<A>> fa, TryOption<Lst<B>> fb) =>
            FTryOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Lst<A>> ma) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> BindT< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOptionAsync<B>></returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOptionAsync<A>></returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> MapT< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Lst<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> FilterT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> Where< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> Select< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Lst<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MTryOptionAsync<Lst<C>>, TryOptionAsync<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> PlusT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> SubtractT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> ProductT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> DivideT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> AppendT<SEMI,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Lst<A>></param>
        /// <returns>TryOptionAsync<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Lst<A>> fa) =>
            FTryOptionAsync< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Lst<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Lst<A>></param>
        /// <returns>TryOptionAsync<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Lst<A>> fa, TryOptionAsync<Lst<B>> fb) =>
            FTryOptionAsync< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryOptionAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Lst<A>> ma) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Lst<B>> BindT< A, B>(this IEnumerable<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<IEnumerable<B>></returns>
        [Pure]
        public static Lst<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<IEnumerable<A>></returns>
        [Pure]
        public static Lst<IEnumerable<A>> Sequence< A>(this IEnumerable<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Lst<B>> MapT< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Lst<A>> ma, Action<A> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Lst<A>> FilterT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Lst<A>> Where< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Lst<B>> Select< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Lst<C>> SelectMany< A, B, C>(
            this IEnumerable<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MSeq<Lst<C>>, IEnumerable<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> PlusT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> SubtractT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> ProductT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> DivideT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> AppendT<SEMI,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Lst<A>></param>
        /// <returns>IEnumerable<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Lst<A>> fa) =>
            FSeq< Lst<A>, Lst<B>>.Inst.Apply(
                 MSeq< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Lst<A>></param>
        /// <param name="fb">Monad of IEnumerable<Lst<A>></param>
        /// <returns>IEnumerable<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Lst<A>> fa, IEnumerable<Lst<B>> fb) =>
            FSeq< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSeq< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Lst<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Lst<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Lst<A>> ma) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Lst<B>> BindT< A, B>(this Set<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Set<B>></returns>
        [Pure]
        public static Lst<Set<B>> Traverse< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Lst<A>>, traverses the inner
        /// values of type A, and returns Lst<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Set<A>></returns>
        [Pure]
        public static Lst<Set<A>> Sequence< A>(this Set<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Lst<B>> MapT< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Lst<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Lst<A>> ma, Action<A> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Lst<A>> FilterT< A>(this Set<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Lst<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Lst<A>> Where< A>(this Set<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Lst<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Lst<B>> Select< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Lst<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Lst<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Lst<C>> SelectMany< A, B, C>(
            this Set<Lst<A>> ma,
            Func<A, Lst<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                    .Inst.Bind<MSet<Lst<C>>, Set<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MLst<B>).Bind<MLst<C>, Lst<C>, C>(mb, b => default(MLst<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Lst<A>> PlusT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Lst<A>> SubtractT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Lst<A>> ProductT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Lst<A>> DivideT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Lst<A>> AppendT<SEMI,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Lst<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Lst<A>></param>
        /// <returns>Set<Lst<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Lst<A>> fa) =>
            FSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => FLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Lst<A>></param>
        /// <param name="fb">Monad of Set<Lst<A>></param>
        /// <returns>Set<Lst<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Lst<A>> fa, Set<Lst<B>> fb) =>
            FSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            FLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Option, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Option<A>> ma) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Option<B>> BindT< A, B>(this Arr<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Arr<B>></returns>
        [Pure]
        public static Option<Arr<B>> Traverse< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Arr<A>></returns>
        [Pure]
        public static Option<Arr<A>> Sequence< A>(this Arr<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Option<B>> MapT< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Option<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Option<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Option<A>> ma, Action<A> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Option<A>> FilterT< A>(this Arr<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Option<A>> Where< A>(this Arr<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Option<B>> Select< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Option<C>> SelectMany< A, B, C>(
            this Arr<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MArr<Option<C>>, Arr<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Option<A>> PlusT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Option<A>> SubtractT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Option<A>> ProductT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Option<A>> DivideT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Option<A>> AppendT<SEMI,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Option<A>></param>
        /// <returns>Arr<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Option<A>> fa) =>
            FArr< Option<A>, Option<B>>.Inst.Apply(
                 MArr< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Option<A>></param>
        /// <param name="fb">Monad of Arr<Option<A>></param>
        /// <returns>Arr<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Option<A>> fa, Arr<Option<B>> fb) =>
            FArr< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MArr< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Option<A>> ma) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Option<B>> BindT< A, B>(this HashSet<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Option<A>>, traverses the inner
        /// values of type A, and returns Option<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<HashSet<B>></returns>
        [Pure]
        public static Option<HashSet<B>> Traverse< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Option<A>>, traverses the inner
        /// values of type A, and returns Option<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<HashSet<A>></returns>
        [Pure]
        public static Option<HashSet<A>> Sequence< A>(this HashSet<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Option<B>> MapT< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Option<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Option<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Option<A>> ma, Action<A> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Option<A>> FilterT< A>(this HashSet<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Option<A>> Where< A>(this HashSet<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Option<B>> Select< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Option<C>> SelectMany< A, B, C>(
            this HashSet<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MHashSet<Option<C>>, HashSet<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Option<A>> PlusT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Option<A>> SubtractT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Option<A>> ProductT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Option<A>> DivideT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Option<A>> AppendT<SEMI,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Option<A>></param>
        /// <returns>HashSet<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Option<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Option<A>> fa) =>
            FHashSet< Option<A>, Option<B>>.Inst.Apply(
                 MHashSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Option<A>></param>
        /// <param name="fb">Monad of HashSet<Option<A>></param>
        /// <returns>HashSet<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Option<A>> fa, HashSet<Option<B>> fb) =>
            FHashSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MHashSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Option<A>> ma) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Option<B>> BindT< A, B>(this Lst<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Lst<B>></returns>
        [Pure]
        public static Option<Lst<B>> Traverse< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Lst<A>></returns>
        [Pure]
        public static Option<Lst<A>> Sequence< A>(this Lst<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Option<B>> MapT< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Option<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Option<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Option<A>> ma, Action<A> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Option<A>> FilterT< A>(this Lst<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Option<A>> Where< A>(this Lst<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Option<B>> Select< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Option<C>> SelectMany< A, B, C>(
            this Lst<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MLst<Option<C>>, Lst<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Option<A>> PlusT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Option<A>> SubtractT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Option<A>> ProductT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Option<A>> DivideT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Option<A>> AppendT<SEMI,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Option<A>></param>
        /// <returns>Lst<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Option<A>> fa) =>
            FLst< Option<A>, Option<B>>.Inst.Apply(
                 MLst< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Option<A>></param>
        /// <param name="fb">Monad of Lst<Option<A>></param>
        /// <returns>Lst<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Option<A>> fa, Lst<Option<B>> fb) =>
            FLst< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MLst< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Option<A>> ma) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Option<B>> BindT< A, B>(this Option<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Option<B>></returns>
        [Pure]
        public static Option<Option<B>> Traverse< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Option<A>></returns>
        [Pure]
        public static Option<Option<A>> Sequence< A>(this Option<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Option<B>> MapT< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Option<A>> ma, Action<A> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Option<A>> FilterT< A>(this Option<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Option<A>> Where< A>(this Option<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Option<B>> Select< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Option<C>> SelectMany< A, B, C>(
            this Option<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MOption<Option<C>>, Option<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Option<A>> PlusT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Option<A>> SubtractT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Option<A>> ProductT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Option<A>> DivideT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Option<A>> AppendT<SEMI,  A>(this Option<Option<A>> x, Option<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Option<A>> x, Option<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Option<A>> x, Option<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Option<A>></param>
        /// <returns>Option<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Option<A>> fa) =>
            FOption< Option<A>, Option<B>>.Inst.Apply(
                 MOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Option<A>></param>
        /// <param name="fb">Monad of Option<Option<A>></param>
        /// <returns>Option<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Option<A>> fa, Option<Option<B>> fb) =>
            FOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Option<A>> ma) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> BindT< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Option<A>>, traverses the inner
        /// values of type A, and returns Option<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<OptionUnsafe<B>></returns>
        [Pure]
        public static Option<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Option<A>>, traverses the inner
        /// values of type A, and returns Option<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<OptionUnsafe<A>></returns>
        [Pure]
        public static Option<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> MapT< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Option<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> FilterT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> Where< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> Select< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Option<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MOptionUnsafe<Option<C>>, OptionUnsafe<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> PlusT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> SubtractT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> ProductT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> DivideT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> AppendT<SEMI,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Option<A>></param>
        /// <returns>OptionUnsafe<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Option<A>> fa) =>
            FOptionUnsafe< Option<A>, Option<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Option<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Option<A>></param>
        /// <returns>OptionUnsafe<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Option<A>> fa, OptionUnsafe<Option<B>> fb) =>
            FOptionUnsafe< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOptionUnsafe< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Option<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Option<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Option<A>> ma) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Option<B>> BindT<L, A, B>(this Either<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Option<A>>, traverses the inner
        /// values of type A, and returns Option<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Either<L, B>></returns>
        [Pure]
        public static Option<Either<L, B>> Traverse<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Option<A>>, traverses the inner
        /// values of type A, and returns Option<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Either<L, A>></returns>
        [Pure]
        public static Option<Either<L, A>> Sequence<L, A>(this Either<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Option<B>> MapT<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Option<A>> ma, Action<A> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Option<A>> FilterT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Option<A>> Where<L, A>(this Either<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Option<B>> Select<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Option<C>> SelectMany<L, A, B, C>(
            this Either<L, Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MEither<L, Option<C>>, Either<L, Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Option<A>> PlusT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Option<A>> SubtractT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Option<A>> ProductT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Option<A>> DivideT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Option<A>> AppendT<SEMI, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Option<A>></param>
        /// <returns>Either<L, Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Option<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Option<A>> fa) =>
            FEither<L, Option<A>, Option<B>>.Inst.Apply(
                 MEither<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Option<A>></param>
        /// <param name="fb">Monad of Either<L, Option<A>></param>
        /// <returns>Either<L, Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Option<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Option<A>> fa, Either<L, Option<B>> fb) =>
            FEither<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEither<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Option<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Option<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Option<A>> ma) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> BindT<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Option<A>>, traverses the inner
        /// values of type A, and returns Option<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Option<A>>, traverses the inner
        /// values of type A, and returns Option<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> MapT<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Option<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> FilterT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> Where<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> Select<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Option<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Option<C>>, EitherUnsafe<L, Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Option<A>></param>
        /// <returns>EitherUnsafe<L, Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Option<A>> fa) =>
            FEitherUnsafe<L, Option<A>, Option<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Option<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Option<A>></param>
        /// <returns>EitherUnsafe<L, Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Option<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Option<A>> fa, EitherUnsafe<L, Option<B>> fb) =>
            FEitherUnsafe<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Option<A>> ma) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Option<B>> BindT< A, B>(this Task<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Task<B>></returns>
        [Pure]
        public static Option<Task<B>> Traverse< A, B>(this Task<Option<A>> ma, Func<A, B> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Task<A>></returns>
        [Pure]
        public static Option<Task<A>> Sequence< A>(this Task<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Option<B>> MapT< A, B>(this Task<Option<A>> ma, Func<A, B> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Option<A>> ma, Action<A> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Option<A>> FilterT< A>(this Task<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Option<A>> Where< A>(this Task<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Option<B>> Select< A, B>(this Task<Option<A>> ma, Func<A, B> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Option<C>> SelectMany< A, B, C>(
            this Task<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MTask<Option<C>>, Task<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Option<A>> PlusT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Option<A>> SubtractT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Option<A>> ProductT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Option<A>> DivideT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Option<A>> AppendT<SEMI,  A>(this Task<Option<A>> x, Task<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Option<A>> x, Task<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Option<A>> x, Task<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Option<A>></param>
        /// <returns>Task<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Option<A>> fa) =>
            FTask< Option<A>, Option<B>>.Inst.Apply(
                 MTask< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Option<A>></param>
        /// <param name="fb">Monad of Task<Option<A>></param>
        /// <returns>Task<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Option<A>> fa, Task<Option<B>> fb) =>
            FTask< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTask< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Option<A>> ma) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Option<B>> BindT< A, B>(this Try<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Try<B>></returns>
        [Pure]
        public static Option<Try<B>> Traverse< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Try<A>></returns>
        [Pure]
        public static Option<Try<A>> Sequence< A>(this Try<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Option<B>> MapT< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Option<A>> ma, Action<A> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Option<A>> FilterT< A>(this Try<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Option<A>> Where< A>(this Try<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Option<B>> Select< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Option<C>> SelectMany< A, B, C>(
            this Try<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MTry<Option<C>>, Try<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Option<A>> PlusT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Option<A>> SubtractT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Option<A>> ProductT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Option<A>> DivideT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Option<A>> AppendT<SEMI,  A>(this Try<Option<A>> x, Try<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Option<A>> x, Try<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Option<A>> x, Try<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Option<A>></param>
        /// <returns>Try<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Option<A>> fa) =>
            FTry< Option<A>, Option<B>>.Inst.Apply(
                 MTry< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Option<A>></param>
        /// <param name="fb">Monad of Try<Option<A>></param>
        /// <returns>Try<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Option<A>> fa, Try<Option<B>> fb) =>
            FTry< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTry< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Option<A>> ma) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Option<B>> BindT< A, B>(this TryAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryAsync<B>></returns>
        [Pure]
        public static Option<TryAsync<B>> Traverse< A, B>(this TryAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryAsync<A>></returns>
        [Pure]
        public static Option<TryAsync<A>> Sequence< A>(this TryAsync<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Option<B>> MapT< A, B>(this TryAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Option<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Option<A>> FilterT< A>(this TryAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Option<A>> Where< A>(this TryAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Option<B>> Select< A, B>(this TryAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Option<C>> SelectMany< A, B, C>(
            this TryAsync<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MTryAsync<Option<C>>, TryAsync<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Option<A>> PlusT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Option<A>> SubtractT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Option<A>> ProductT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Option<A>> DivideT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Option<A>> AppendT<SEMI,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Option<A>></param>
        /// <returns>TryAsync<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Option<A>> fa) =>
            FTryAsync< Option<A>, Option<B>>.Inst.Apply(
                 MTryAsync< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Option<A>></param>
        /// <param name="fb">Monad of TryAsync<Option<A>></param>
        /// <returns>TryAsync<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Option<A>> fa, TryAsync<Option<B>> fb) =>
            FTryAsync< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Option<A>> ma) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Option<B>> BindT< A, B>(this TryOption<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOption<B>></returns>
        [Pure]
        public static Option<TryOption<B>> Traverse< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOption<A>></returns>
        [Pure]
        public static Option<TryOption<A>> Sequence< A>(this TryOption<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Option<B>> MapT< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Option<A>> ma, Action<A> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Option<A>> FilterT< A>(this TryOption<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Option<A>> Where< A>(this TryOption<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Option<B>> Select< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Option<C>> SelectMany< A, B, C>(
            this TryOption<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MTryOption<Option<C>>, TryOption<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Option<A>> PlusT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Option<A>> SubtractT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Option<A>> ProductT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Option<A>> DivideT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Option<A>> AppendT<SEMI,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Option<A>></param>
        /// <returns>TryOption<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Option<A>> fa) =>
            FTryOption< Option<A>, Option<B>>.Inst.Apply(
                 MTryOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Option<A>></param>
        /// <param name="fb">Monad of TryOption<Option<A>></param>
        /// <returns>TryOption<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Option<A>> fa, TryOption<Option<B>> fb) =>
            FTryOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Option<A>> ma) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> BindT< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOptionAsync<B>></returns>
        [Pure]
        public static Option<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Option<A>>, traverses the inner
        /// values of type A, and returns Option<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOptionAsync<A>></returns>
        [Pure]
        public static Option<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> MapT< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Option<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> FilterT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> Where< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> Select< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Option<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MTryOptionAsync<Option<C>>, TryOptionAsync<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> PlusT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> SubtractT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> ProductT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> DivideT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> AppendT<SEMI,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Option<A>></param>
        /// <returns>TryOptionAsync<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Option<A>> fa) =>
            FTryOptionAsync< Option<A>, Option<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Option<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Option<A>></param>
        /// <returns>TryOptionAsync<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Option<A>> fa, TryOptionAsync<Option<B>> fb) =>
            FTryOptionAsync< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryOptionAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Option<A>> ma) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Option<B>> BindT< A, B>(this IEnumerable<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Option<A>>, traverses the inner
        /// values of type A, and returns Option<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<IEnumerable<B>></returns>
        [Pure]
        public static Option<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Option<A>>, traverses the inner
        /// values of type A, and returns Option<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<IEnumerable<A>></returns>
        [Pure]
        public static Option<IEnumerable<A>> Sequence< A>(this IEnumerable<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Option<B>> MapT< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Option<A>> ma, Action<A> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Option<A>> FilterT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Option<A>> Where< A>(this IEnumerable<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Option<B>> Select< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Option<C>> SelectMany< A, B, C>(
            this IEnumerable<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MSeq<Option<C>>, IEnumerable<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Option<A>> PlusT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Option<A>> SubtractT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Option<A>> ProductT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Option<A>> DivideT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Option<A>> AppendT<SEMI,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Option<A>></param>
        /// <returns>IEnumerable<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Option<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Option<A>> fa) =>
            FSeq< Option<A>, Option<B>>.Inst.Apply(
                 MSeq< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Option<A>></param>
        /// <param name="fb">Monad of IEnumerable<Option<A>></param>
        /// <returns>IEnumerable<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Option<A>> fa, IEnumerable<Option<B>> fb) =>
            FSeq< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSeq< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Option<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Option<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Option<A>> ma) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Option<B>> BindT< A, B>(this Set<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Set<B>></returns>
        [Pure]
        public static Option<Set<B>> Traverse< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Option<A>>, traverses the inner
        /// values of type A, and returns Option<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Set<A>></returns>
        [Pure]
        public static Option<Set<A>> Sequence< A>(this Set<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Option<B>> MapT< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Option<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Option<A>> ma, Action<A> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Option<A>> FilterT< A>(this Set<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Option<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Option<A>> Where< A>(this Set<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Option<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Option<B>> Select< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Option<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Option<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Option<C>> SelectMany< A, B, C>(
            this Set<Option<A>> ma,
            Func<A, Option<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                    .Inst.Bind<MSet<Option<C>>, Set<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOption<B>).Bind<MOption<C>, Option<C>, C>(mb, b => default(MOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Option<A>> PlusT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Option<A>> SubtractT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Option<A>> ProductT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Option<A>> DivideT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Option<A>> AppendT<SEMI,  A>(this Set<Option<A>> x, Set<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Option<A>> x, Set<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Option<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Option<A>> x, Set<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Option<A>></param>
        /// <returns>Set<Option<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Option<A>> fa) =>
            FSet< Option<A>, Option<B>>.Inst.Apply(
                 MSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => FOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Option<A>></param>
        /// <param name="fb">Monad of Set<Option<A>></param>
        /// <returns>Set<Option<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Option<A>> fa, Set<Option<B>> fb) =>
            FSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            FOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for OptionUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionUnsafeT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<OptionUnsafe<A>> ma) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> BindT< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Arr<B>></returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> Traverse< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Arr<A>></returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> Sequence< A>(this Arr<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> MapT< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> FilterT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> Where< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> Select< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Arr<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MArr<OptionUnsafe<C>>, Arr<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> PlusT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> SubtractT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> ProductT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> DivideT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> AppendT<SEMI,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<OptionUnsafe<A>></param>
        /// <returns>Arr<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<OptionUnsafe<A>> fa) =>
            FArr< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MArr< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Arr<OptionUnsafe<A>></param>
        /// <returns>Arr<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<OptionUnsafe<A>> fa, Arr<OptionUnsafe<B>> fb) =>
            FArr< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MArr< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<OptionUnsafe<A>> ma) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> BindT< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<HashSet<B>></returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> Traverse< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<HashSet<A>></returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> Sequence< A>(this HashSet<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> MapT< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> FilterT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> Where< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> Select< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionUnsafe<C>> SelectMany< A, B, C>(
            this HashSet<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MHashSet<OptionUnsafe<C>>, HashSet<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> PlusT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> SubtractT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> ProductT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> DivideT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> AppendT<SEMI,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<OptionUnsafe<A>></param>
        /// <returns>HashSet<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<OptionUnsafe<A>> fa) =>
            FHashSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MHashSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of HashSet<OptionUnsafe<A>></param>
        /// <returns>HashSet<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<OptionUnsafe<A>> fa, HashSet<OptionUnsafe<B>> fb) =>
            FHashSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MHashSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<OptionUnsafe<A>> ma) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> BindT< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Lst<B>></returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> Traverse< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Lst<A>></returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> Sequence< A>(this Lst<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> MapT< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> FilterT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> Where< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> Select< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Lst<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MLst<OptionUnsafe<C>>, Lst<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> PlusT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> SubtractT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> ProductT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> DivideT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> AppendT<SEMI,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<OptionUnsafe<A>></param>
        /// <returns>Lst<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<OptionUnsafe<A>> fa) =>
            FLst< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MLst< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Lst<OptionUnsafe<A>></param>
        /// <returns>Lst<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<OptionUnsafe<A>> fa, Lst<OptionUnsafe<B>> fb) =>
            FLst< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MLst< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<OptionUnsafe<A>> ma) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> BindT< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Option<B>></returns>
        [Pure]
        public static OptionUnsafe<Option<B>> Traverse< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Option<A>></returns>
        [Pure]
        public static OptionUnsafe<Option<A>> Sequence< A>(this Option<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> MapT< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> FilterT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> Where< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> Select< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Option<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MOption<OptionUnsafe<C>>, Option<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> PlusT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> SubtractT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> ProductT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> DivideT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> AppendT<SEMI,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<OptionUnsafe<A>></param>
        /// <returns>Option<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Option<OptionUnsafe<A>> fa) =>
            FOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Option<OptionUnsafe<A>></param>
        /// <returns>Option<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<OptionUnsafe<A>> fa, Option<OptionUnsafe<B>> fb) =>
            FOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<OptionUnsafe<A>> ma) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> BindT< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>></returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>></returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> MapT< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> FilterT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> Where< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> Select< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MOptionUnsafe<OptionUnsafe<C>>, OptionUnsafe<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> PlusT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> SubtractT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> ProductT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> DivideT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> AppendT<SEMI,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<OptionUnsafe<A>></param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<OptionUnsafe<A>> fa) =>
            FOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOptionUnsafe< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<OptionUnsafe<A>></param>
        /// <returns>OptionUnsafe<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<OptionUnsafe<A>> fa, OptionUnsafe<OptionUnsafe<B>> fb) =>
            FOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOptionUnsafe< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, OptionUnsafe<A>> ma) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> BindT<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Either<L, B>></returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> Traverse<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Either<L, A>></returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> Sequence<L, A>(this Either<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> MapT<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> FilterT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> Where<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> Select<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionUnsafe<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MEither<L, OptionUnsafe<C>>, Either<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> PlusT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> SubtractT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> ProductT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> DivideT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> AppendT<SEMI, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, OptionUnsafe<A>></param>
        /// <returns>Either<L, OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, OptionUnsafe<A>> fa) =>
            FEither<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEither<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Either<L, OptionUnsafe<A>></param>
        /// <returns>Either<L, OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, OptionUnsafe<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, OptionUnsafe<A>> fa, Either<L, OptionUnsafe<B>> fb) =>
            FEither<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEither<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> BindT<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>></returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>></returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> MapT<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> FilterT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> Where<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> Select<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<C>>, EitherUnsafe<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, OptionUnsafe<A>></param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, OptionUnsafe<A>> fa) =>
            FEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, OptionUnsafe<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, OptionUnsafe<A>></param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, OptionUnsafe<A>> fa, EitherUnsafe<L, OptionUnsafe<B>> fb) =>
            FEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<OptionUnsafe<A>> ma) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> BindT< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Task<B>></returns>
        [Pure]
        public static OptionUnsafe<Task<B>> Traverse< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Task<A>></returns>
        [Pure]
        public static OptionUnsafe<Task<A>> Sequence< A>(this Task<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> MapT< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> FilterT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> Where< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> Select< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Task<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MTask<OptionUnsafe<C>>, Task<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> PlusT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> SubtractT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> ProductT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> DivideT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> AppendT<SEMI,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<OptionUnsafe<A>></param>
        /// <returns>Task<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Task<OptionUnsafe<A>> fa) =>
            FTask< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTask< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Task<OptionUnsafe<A>></param>
        /// <returns>Task<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<OptionUnsafe<A>> fa, Task<OptionUnsafe<B>> fb) =>
            FTask< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTask< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<OptionUnsafe<A>> ma) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> BindT< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Try<B>></returns>
        [Pure]
        public static OptionUnsafe<Try<B>> Traverse< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Try<A>></returns>
        [Pure]
        public static OptionUnsafe<Try<A>> Sequence< A>(this Try<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> MapT< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> FilterT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> Where< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> Select< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Try<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MTry<OptionUnsafe<C>>, Try<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> PlusT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> SubtractT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> ProductT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> DivideT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> AppendT<SEMI,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<OptionUnsafe<A>></param>
        /// <returns>Try<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Try<OptionUnsafe<A>> fa) =>
            FTry< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTry< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Try<OptionUnsafe<A>></param>
        /// <returns>Try<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<OptionUnsafe<A>> fa, Try<OptionUnsafe<B>> fb) =>
            FTry< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTry< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<OptionUnsafe<A>> ma) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> BindT< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryAsync<B>></returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> Traverse< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryAsync<A>></returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> Sequence< A>(this TryAsync<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> MapT< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> FilterT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> Where< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> Select< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryAsync<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MTryAsync<OptionUnsafe<C>>, TryAsync<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> PlusT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> ProductT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> DivideT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<OptionUnsafe<A>></param>
        /// <returns>TryAsync<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<OptionUnsafe<A>> fa) =>
            FTryAsync< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of TryAsync<OptionUnsafe<A>></param>
        /// <returns>TryAsync<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<OptionUnsafe<A>> fa, TryAsync<OptionUnsafe<B>> fb) =>
            FTryAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<OptionUnsafe<A>> ma) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> BindT< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOption<B>></returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> Traverse< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOption<A>></returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> Sequence< A>(this TryOption<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> MapT< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> FilterT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> Where< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> Select< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryOption<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MTryOption<OptionUnsafe<C>>, TryOption<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> PlusT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> ProductT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> DivideT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<OptionUnsafe<A>></param>
        /// <returns>TryOption<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<OptionUnsafe<A>> fa) =>
            FTryOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of TryOption<OptionUnsafe<A>></param>
        /// <returns>TryOption<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<OptionUnsafe<A>> fa, TryOption<OptionUnsafe<B>> fb) =>
            FTryOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<OptionUnsafe<A>> ma) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> BindT< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>></returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>></returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> MapT< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> FilterT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> Where< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> Select< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MTryOptionAsync<OptionUnsafe<C>>, TryOptionAsync<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> PlusT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> ProductT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> DivideT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<OptionUnsafe<A>></param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<OptionUnsafe<A>> fa) =>
            FTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryOptionAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<OptionUnsafe<A>></param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<OptionUnsafe<A>> fa, TryOptionAsync<OptionUnsafe<B>> fb) =>
            FTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryOptionAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<OptionUnsafe<A>> ma) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> BindT< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<IEnumerable<B>></returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> Traverse< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<IEnumerable<A>></returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> Sequence< A>(this IEnumerable<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> MapT< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> FilterT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> Where< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> Select< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MSeq<OptionUnsafe<C>>, IEnumerable<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> PlusT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> SubtractT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> ProductT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> DivideT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> AppendT<SEMI,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<OptionUnsafe<A>></param>
        /// <returns>IEnumerable<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<OptionUnsafe<A>> fa) =>
            FSeq< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSeq< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of IEnumerable<OptionUnsafe<A>></param>
        /// <returns>IEnumerable<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<OptionUnsafe<A>> fa, IEnumerable<OptionUnsafe<B>> fb) =>
            FSeq< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSeq< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<OptionUnsafe<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<OptionUnsafe<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<OptionUnsafe<A>> ma) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> BindT< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Set<B>></returns>
        [Pure]
        public static OptionUnsafe<Set<B>> Traverse< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<OptionUnsafe<A>>, traverses the inner
        /// values of type A, and returns OptionUnsafe<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Set<A>></returns>
        [Pure]
        public static OptionUnsafe<Set<A>> Sequence< A>(this Set<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> MapT< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<OptionUnsafe<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> FilterT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<OptionUnsafe<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> Where< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<OptionUnsafe<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> Select< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<OptionUnsafe<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<OptionUnsafe<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Set<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                    .Inst.Bind<MSet<OptionUnsafe<C>>, Set<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MOptionUnsafe<B>).Bind<MOptionUnsafe<C>, OptionUnsafe<C>, C>(mb, b => default(MOptionUnsafe<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> PlusT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> SubtractT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> ProductT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> DivideT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> AppendT<SEMI,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<OptionUnsafe<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<OptionUnsafe<A>></param>
        /// <returns>Set<OptionUnsafe<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Set<OptionUnsafe<A>> fa) =>
            FSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => FOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<OptionUnsafe<A>></param>
        /// <param name="fb">Monad of Set<OptionUnsafe<A>></param>
        /// <returns>Set<OptionUnsafe<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<OptionUnsafe<A>> fa, Set<OptionUnsafe<B>> fb) =>
            FSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            FOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Either, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Arr<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Arr<Either<L, A>> ma) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Either<L, B>> BindT<L, A, B>(this Arr<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Arr<B>></returns>
        [Pure]
        public static Either<L, Arr<B>> Traverse<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Arr<A>></returns>
        [Pure]
        public static Either<L, Arr<A>> Sequence<L, A>(this Arr<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Either<L, B>> MapT<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Arr<Either<L, A>> ma, Action<A> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Either<L, A>> FilterT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Either<L, A>> Where<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Either<L, B>> Select<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Either<L, C>> SelectMany<L, A, B, C>(
            this Arr<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MArr<Either<L, C>>, Arr<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Either<L, A>> PlusT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Either<L, A>> SubtractT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Either<L, A>> ProductT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Either<L, A>> DivideT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Either<L, A>> AppendT<SEMI, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Either<L, A>></param>
        /// <returns>Arr<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Arr<Either<L, A>> fa) =>
            FArr< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MArr< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Either<L, A>></param>
        /// <param name="fb">Monad of Arr<Either<L, A>></param>
        /// <returns>Arr<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Arr<Either<L, A>> fa, Arr<Either<L, B>> fb) =>
            FArr< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MArr< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this HashSet<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this HashSet<Either<L, A>> ma) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Either<L, B>> BindT<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, HashSet<B>></returns>
        [Pure]
        public static Either<L, HashSet<B>> Traverse<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, HashSet<A>></returns>
        [Pure]
        public static Either<L, HashSet<A>> Sequence<L, A>(this HashSet<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Either<L, B>> MapT<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this HashSet<Either<L, A>> ma, Action<A> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Either<L, A>> FilterT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Either<L, A>> Where<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Either<L, B>> Select<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Either<L, C>> SelectMany<L, A, B, C>(
            this HashSet<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MHashSet<Either<L, C>>, HashSet<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Either<L, A>> PlusT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Either<L, A>> SubtractT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Either<L, A>> ProductT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Either<L, A>> DivideT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Either<L, A>> AppendT<SEMI, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Either<L, A>></param>
        /// <returns>HashSet<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, HashSet<Either<L, A>> fa) =>
            FHashSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MHashSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Either<L, A>></param>
        /// <param name="fb">Monad of HashSet<Either<L, A>></param>
        /// <returns>HashSet<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, HashSet<Either<L, A>> fa, HashSet<Either<L, B>> fb) =>
            FHashSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MHashSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Lst<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Lst<Either<L, A>> ma) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Either<L, B>> BindT<L, A, B>(this Lst<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Lst<B>></returns>
        [Pure]
        public static Either<L, Lst<B>> Traverse<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Lst<A>></returns>
        [Pure]
        public static Either<L, Lst<A>> Sequence<L, A>(this Lst<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Either<L, B>> MapT<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Lst<Either<L, A>> ma, Action<A> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Either<L, A>> FilterT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Either<L, A>> Where<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Either<L, B>> Select<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Either<L, C>> SelectMany<L, A, B, C>(
            this Lst<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MLst<Either<L, C>>, Lst<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Either<L, A>> PlusT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Either<L, A>> SubtractT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Either<L, A>> ProductT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Either<L, A>> DivideT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Either<L, A>> AppendT<SEMI, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Either<L, A>></param>
        /// <returns>Lst<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Lst<Either<L, A>> fa) =>
            FLst< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MLst< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Either<L, A>></param>
        /// <param name="fb">Monad of Lst<Either<L, A>></param>
        /// <returns>Lst<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Lst<Either<L, A>> fa, Lst<Either<L, B>> fb) =>
            FLst< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MLst< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Option<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Option<Either<L, A>> ma) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Either<L, B>> BindT<L, A, B>(this Option<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Option<B>></returns>
        [Pure]
        public static Either<L, Option<B>> Traverse<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Option<A>></returns>
        [Pure]
        public static Either<L, Option<A>> Sequence<L, A>(this Option<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Either<L, B>> MapT<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Option<Either<L, A>> ma, Action<A> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Either<L, A>> FilterT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Either<L, A>> Where<L, A>(this Option<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Either<L, B>> Select<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Either<L, C>> SelectMany<L, A, B, C>(
            this Option<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MOption<Either<L, C>>, Option<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Either<L, A>> PlusT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Either<L, A>> SubtractT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Either<L, A>> ProductT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Either<L, A>> DivideT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Either<L, A>> AppendT<SEMI, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Either<L, A>></param>
        /// <returns>Option<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Option<Either<L, A>> fa) =>
            FOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Either<L, A>></param>
        /// <param name="fb">Monad of Option<Either<L, A>></param>
        /// <returns>Option<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Option<Either<L, A>> fa, Option<Either<L, B>> fb) =>
            FOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this OptionUnsafe<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this OptionUnsafe<Either<L, A>> ma) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> BindT<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, OptionUnsafe<B>></returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> Traverse<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, OptionUnsafe<A>></returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> Sequence<L, A>(this OptionUnsafe<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> MapT<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this OptionUnsafe<Either<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> FilterT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> Where<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> Select<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Either<L, C>> SelectMany<L, A, B, C>(
            this OptionUnsafe<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MOptionUnsafe<Either<L, C>>, OptionUnsafe<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> PlusT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> SubtractT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> ProductT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> DivideT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> AppendT<SEMI, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Either<L, A>></param>
        /// <returns>OptionUnsafe<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionUnsafe<Either<L, A>> fa) =>
            FOptionUnsafe< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Either<L, A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Either<L, A>></param>
        /// <returns>OptionUnsafe<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Either<L, A>> fa, OptionUnsafe<Either<L, B>> fb) =>
            FOptionUnsafe< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Either<L, A>> ma) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Either<L, B>> BindT<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Either<L, B>></returns>
        [Pure]
        public static Either<L, Either<L, B>> Traverse<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Either<L, A>></returns>
        [Pure]
        public static Either<L, Either<L, A>> Sequence<L, A>(this Either<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Either<L, B>> MapT<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Either<L, A>> FilterT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Either<L, A>> Where<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Either<L, B>> Select<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Either<L, C>> SelectMany<L, A, B, C>(
            this Either<L, Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MEither<L, Either<L, C>>, Either<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Either<L, A>> PlusT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Either<L, A>> SubtractT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Either<L, A>> ProductT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Either<L, A>> DivideT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Either<L, A>> AppendT<SEMI, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Either<L, A>></param>
        /// <returns>Either<L, Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Either<L, A>> fa) =>
            FEither<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEither<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Either<L, A>></param>
        /// <param name="fb">Monad of Either<L, Either<L, A>></param>
        /// <returns>Either<L, Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Either<L, A>> fa, Either<L, Either<L, B>> fb) =>
            FEither<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEither<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Either<L, A>> ma) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> BindT<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, EitherUnsafe<L, B>></returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> MapT<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> FilterT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> Where<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> Select<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Either<L, C>>, EitherUnsafe<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Either<L, A>></param>
        /// <returns>EitherUnsafe<L, Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Either<L, A>> fa) =>
            FEitherUnsafe<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Either<L, A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Either<L, A>></param>
        /// <returns>EitherUnsafe<L, Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Either<L, A>> fa, EitherUnsafe<L, Either<L, B>> fb) =>
            FEitherUnsafe<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Task<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Task<Either<L, A>> ma) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Either<L, B>> BindT<L, A, B>(this Task<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Task<B>></returns>
        [Pure]
        public static Either<L, Task<B>> Traverse<L, A, B>(this Task<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Task<A>></returns>
        [Pure]
        public static Either<L, Task<A>> Sequence<L, A>(this Task<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Either<L, B>> MapT<L, A, B>(this Task<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Task<Either<L, A>> ma, Action<A> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Either<L, A>> FilterT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Either<L, A>> Where<L, A>(this Task<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Either<L, B>> Select<L, A, B>(this Task<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Either<L, C>> SelectMany<L, A, B, C>(
            this Task<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MTask<Either<L, C>>, Task<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Either<L, A>> PlusT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Either<L, A>> SubtractT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Either<L, A>> ProductT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Either<L, A>> DivideT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Either<L, A>> AppendT<SEMI, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Either<L, A>></param>
        /// <returns>Task<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Task<Either<L, A>> fa) =>
            FTask< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTask< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Either<L, A>></param>
        /// <param name="fb">Monad of Task<Either<L, A>></param>
        /// <returns>Task<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Task<Either<L, A>> fa, Task<Either<L, B>> fb) =>
            FTask< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTask< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Try<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Try<Either<L, A>> ma) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Either<L, B>> BindT<L, A, B>(this Try<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Try<B>></returns>
        [Pure]
        public static Either<L, Try<B>> Traverse<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Try<A>></returns>
        [Pure]
        public static Either<L, Try<A>> Sequence<L, A>(this Try<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Either<L, B>> MapT<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Try<Either<L, A>> ma, Action<A> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Either<L, A>> FilterT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Either<L, A>> Where<L, A>(this Try<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Either<L, B>> Select<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Either<L, C>> SelectMany<L, A, B, C>(
            this Try<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MTry<Either<L, C>>, Try<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Either<L, A>> PlusT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Either<L, A>> SubtractT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Either<L, A>> ProductT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Either<L, A>> DivideT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Either<L, A>> AppendT<SEMI, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Either<L, A>></param>
        /// <returns>Try<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Try<Either<L, A>> fa) =>
            FTry< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTry< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Either<L, A>></param>
        /// <param name="fb">Monad of Try<Either<L, A>></param>
        /// <returns>Try<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Try<Either<L, A>> fa, Try<Either<L, B>> fb) =>
            FTry< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTry< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryAsync<Either<L, A>> ma) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Either<L, B>> BindT<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryAsync<B>></returns>
        [Pure]
        public static Either<L, TryAsync<B>> Traverse<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryAsync<A>></returns>
        [Pure]
        public static Either<L, TryAsync<A>> Sequence<L, A>(this TryAsync<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Either<L, B>> MapT<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryAsync<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Either<L, A>> FilterT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Either<L, A>> Where<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Either<L, B>> Select<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Either<L, C>> SelectMany<L, A, B, C>(
            this TryAsync<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MTryAsync<Either<L, C>>, TryAsync<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> PlusT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> SubtractT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> ProductT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> DivideT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> AppendT<SEMI, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Either<L, A>></param>
        /// <returns>TryAsync<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryAsync<Either<L, A>> fa) =>
            FTryAsync< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryAsync< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Either<L, A>></param>
        /// <param name="fb">Monad of TryAsync<Either<L, A>></param>
        /// <returns>TryAsync<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryAsync<Either<L, A>> fa, TryAsync<Either<L, B>> fb) =>
            FTryAsync< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOption<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryOption<Either<L, A>> ma) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Either<L, B>> BindT<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOption<B>></returns>
        [Pure]
        public static Either<L, TryOption<B>> Traverse<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOption<A>></returns>
        [Pure]
        public static Either<L, TryOption<A>> Sequence<L, A>(this TryOption<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Either<L, B>> MapT<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOption<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Either<L, A>> FilterT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Either<L, A>> Where<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Either<L, B>> Select<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Either<L, C>> SelectMany<L, A, B, C>(
            this TryOption<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MTryOption<Either<L, C>>, TryOption<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Either<L, A>> PlusT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Either<L, A>> SubtractT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Either<L, A>> ProductT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Either<L, A>> DivideT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Either<L, A>> AppendT<SEMI, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Either<L, A>></param>
        /// <returns>TryOption<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOption<Either<L, A>> fa) =>
            FTryOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Either<L, A>></param>
        /// <param name="fb">Monad of TryOption<Either<L, A>></param>
        /// <returns>TryOption<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOption<Either<L, A>> fa, TryOption<Either<L, B>> fb) =>
            FTryOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOptionAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryOptionAsync<Either<L, A>> ma) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> BindT<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOptionAsync<B>></returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> Traverse<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOptionAsync<A>></returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> Sequence<L, A>(this TryOptionAsync<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> MapT<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOptionAsync<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> FilterT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> Where<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> Select<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Either<L, C>> SelectMany<L, A, B, C>(
            this TryOptionAsync<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MTryOptionAsync<Either<L, C>>, TryOptionAsync<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> PlusT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> SubtractT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> ProductT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> DivideT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> AppendT<SEMI, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Either<L, A>></param>
        /// <returns>TryOptionAsync<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOptionAsync<Either<L, A>> fa) =>
            FTryOptionAsync< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryOptionAsync< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Either<L, A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Either<L, A>></param>
        /// <returns>TryOptionAsync<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Either<L, A>> fa, TryOptionAsync<Either<L, B>> fb) =>
            FTryOptionAsync< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryOptionAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this IEnumerable<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this IEnumerable<Either<L, A>> ma) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> BindT<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, IEnumerable<B>></returns>
        [Pure]
        public static Either<L, IEnumerable<B>> Traverse<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, IEnumerable<A>></returns>
        [Pure]
        public static Either<L, IEnumerable<A>> Sequence<L, A>(this IEnumerable<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> MapT<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this IEnumerable<Either<L, A>> ma, Action<A> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> FilterT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> Where<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> Select<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Either<L, C>> SelectMany<L, A, B, C>(
            this IEnumerable<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MSeq<Either<L, C>>, IEnumerable<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> PlusT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> SubtractT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> ProductT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> DivideT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> AppendT<SEMI, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Either<L, A>></param>
        /// <returns>IEnumerable<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, IEnumerable<Either<L, A>> fa) =>
            FSeq< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSeq< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Either<L, A>></param>
        /// <param name="fb">Monad of IEnumerable<Either<L, A>></param>
        /// <returns>IEnumerable<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, IEnumerable<Either<L, A>> fa, IEnumerable<Either<L, B>> fb) =>
            FSeq< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSeq< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Either<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Set<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Either<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Set<Either<L, A>> ma) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Either<L, B>> BindT<L, A, B>(this Set<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Set<B>></returns>
        [Pure]
        public static Either<L, Set<B>> Traverse<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Either<L, A>>, traverses the inner
        /// values of type A, and returns Either<L, Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Set<A>></returns>
        [Pure]
        public static Either<L, Set<A>> Sequence<L, A>(this Set<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Either<L, B>> MapT<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Either<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Set<Either<L, A>> ma, Action<A> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Either<L, A>> FilterT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Either<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Either<L, A>> Where<L, A>(this Set<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Either<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Either<L, B>> Select<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Either<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Either<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Either<L, C>> SelectMany<L, A, B, C>(
            this Set<Either<L, A>> ma,
            Func<A, Either<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                    .Inst.Bind<MSet<Either<L, C>>, Set<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEither<L, B>).Bind<MEither<L, C>, Either<L, C>, C>(mb, b => default(MEither<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Either<L, A>> PlusT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Either<L, A>> SubtractT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Either<L, A>> ProductT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Either<L, A>> DivideT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Either<L, A>> AppendT<SEMI, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Either<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Either<L, A>></param>
        /// <returns>Set<Either<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Set<Either<L, A>> fa) =>
            FSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => FEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Either<L, A>></param>
        /// <param name="fb">Monad of Set<Either<L, A>></param>
        /// <returns>Set<Either<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Set<Either<L, A>> fa, Set<Either<L, B>> fb) =>
            FSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            FEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for EitherUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherUnsafeT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Arr<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Arr<EitherUnsafe<L, A>> ma) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> BindT<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Arr<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> Traverse<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Arr<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> Sequence<L, A>(this Arr<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> MapT<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> FilterT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> Where<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> Select<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Arr<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MArr<EitherUnsafe<L, C>>, Arr<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<EitherUnsafe<L, A>></param>
        /// <returns>Arr<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Arr<EitherUnsafe<L, A>> fa) =>
            FArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MArr< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Arr<EitherUnsafe<L, A>></param>
        /// <returns>Arr<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Arr<EitherUnsafe<L, A>> fa, Arr<EitherUnsafe<L, B>> fb) =>
            FArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MArr< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this HashSet<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this HashSet<EitherUnsafe<L, A>> ma) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> BindT<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, HashSet<B>></returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> Traverse<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, HashSet<A>></returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> Sequence<L, A>(this HashSet<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> MapT<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> FilterT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> Where<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> Select<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this HashSet<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MHashSet<EitherUnsafe<L, C>>, HashSet<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<EitherUnsafe<L, A>></param>
        /// <returns>HashSet<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, HashSet<EitherUnsafe<L, A>> fa) =>
            FHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MHashSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of HashSet<EitherUnsafe<L, A>></param>
        /// <returns>HashSet<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, HashSet<EitherUnsafe<L, A>> fa, HashSet<EitherUnsafe<L, B>> fb) =>
            FHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MHashSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Lst<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Lst<EitherUnsafe<L, A>> ma) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> BindT<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Lst<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> Traverse<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Lst<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> Sequence<L, A>(this Lst<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> MapT<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> FilterT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> Where<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> Select<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Lst<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MLst<EitherUnsafe<L, C>>, Lst<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<EitherUnsafe<L, A>></param>
        /// <returns>Lst<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Lst<EitherUnsafe<L, A>> fa) =>
            FLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MLst< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Lst<EitherUnsafe<L, A>></param>
        /// <returns>Lst<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Lst<EitherUnsafe<L, A>> fa, Lst<EitherUnsafe<L, B>> fb) =>
            FLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MLst< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Option<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Option<EitherUnsafe<L, A>> ma) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> BindT<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Option<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> Traverse<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Option<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> Sequence<L, A>(this Option<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> MapT<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Option<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> FilterT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> Where<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> Select<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Option<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MOption<EitherUnsafe<L, C>>, Option<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<EitherUnsafe<L, A>></param>
        /// <returns>Option<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Option<EitherUnsafe<L, A>> fa) =>
            FOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Option<EitherUnsafe<L, A>></param>
        /// <returns>Option<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Option<EitherUnsafe<L, A>> fa, Option<EitherUnsafe<L, B>> fb) =>
            FOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> BindT<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<B>></returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> Traverse<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, OptionUnsafe<A>></returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> Sequence<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> MapT<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> FilterT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> Where<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> Select<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this OptionUnsafe<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, C>>, OptionUnsafe<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<EitherUnsafe<L, A>></param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionUnsafe<EitherUnsafe<L, A>> fa) =>
            FOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of OptionUnsafe<EitherUnsafe<L, A>></param>
        /// <returns>OptionUnsafe<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<EitherUnsafe<L, A>> fa, OptionUnsafe<EitherUnsafe<L, B>> fb) =>
            FOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> BindT<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Either<L, B>></returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> Traverse<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Either<L, A>></returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> Sequence<L, A>(this Either<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> MapT<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> FilterT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> Where<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> Select<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Either<L, EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MEither<L, EitherUnsafe<L, C>>, Either<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, EitherUnsafe<L, A>></param>
        /// <returns>Either<L, EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, EitherUnsafe<L, A>> fa) =>
            FEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEither<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Either<L, EitherUnsafe<L, A>></param>
        /// <returns>Either<L, EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, EitherUnsafe<L, A>> fa, Either<L, EitherUnsafe<L, B>> fb) =>
            FEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEither<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> BindT<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>></returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>></returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> MapT<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> FilterT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> Where<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> Select<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, C>>, EitherUnsafe<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> PlusT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> ProductT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> DivideT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, EitherUnsafe<L, A>></param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, EitherUnsafe<L, A>> fa) =>
            FEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, EitherUnsafe<L, A>></param>
        /// <returns>EitherUnsafe<L, EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, EitherUnsafe<L, A>> fa, EitherUnsafe<L, EitherUnsafe<L, B>> fb) =>
            FEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Task<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Task<EitherUnsafe<L, A>> ma) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> BindT<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Task<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> Traverse<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Task<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> Sequence<L, A>(this Task<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> MapT<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Task<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> FilterT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> Where<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> Select<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Task<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MTask<EitherUnsafe<L, C>>, Task<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<EitherUnsafe<L, A>></param>
        /// <returns>Task<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Task<EitherUnsafe<L, A>> fa) =>
            FTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTask< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Task<EitherUnsafe<L, A>></param>
        /// <returns>Task<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Task<EitherUnsafe<L, A>> fa, Task<EitherUnsafe<L, B>> fb) =>
            FTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTask< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Try<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Try<EitherUnsafe<L, A>> ma) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> BindT<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Try<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> Traverse<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Try<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> Sequence<L, A>(this Try<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> MapT<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Try<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> FilterT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> Where<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> Select<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Try<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MTry<EitherUnsafe<L, C>>, Try<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<EitherUnsafe<L, A>></param>
        /// <returns>Try<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Try<EitherUnsafe<L, A>> fa) =>
            FTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTry< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Try<EitherUnsafe<L, A>></param>
        /// <returns>Try<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Try<EitherUnsafe<L, A>> fa, Try<EitherUnsafe<L, B>> fb) =>
            FTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTry< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> BindT<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryAsync<B>></returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> Traverse<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>></returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> Sequence<L, A>(this TryAsync<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> MapT<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> FilterT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> Where<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> Select<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryAsync<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MTryAsync<EitherUnsafe<L, C>>, TryAsync<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<EitherUnsafe<L, A>></param>
        /// <returns>TryAsync<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryAsync<EitherUnsafe<L, A>> fa) =>
            FTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of TryAsync<EitherUnsafe<L, A>></param>
        /// <returns>TryAsync<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryAsync<EitherUnsafe<L, A>> fa, TryAsync<EitherUnsafe<L, B>> fb) =>
            FTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOption<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryOption<EitherUnsafe<L, A>> ma) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> BindT<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOption<B>></returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> Traverse<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOption<A>></returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> Sequence<L, A>(this TryOption<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> MapT<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> FilterT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> Where<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> Select<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryOption<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MTryOption<EitherUnsafe<L, C>>, TryOption<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<EitherUnsafe<L, A>></param>
        /// <returns>TryOption<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOption<EitherUnsafe<L, A>> fa) =>
            FTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of TryOption<EitherUnsafe<L, A>></param>
        /// <returns>TryOption<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOption<EitherUnsafe<L, A>> fa, TryOption<EitherUnsafe<L, B>> fb) =>
            FTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> BindT<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>></returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> Traverse<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>></returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> Sequence<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> MapT<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> FilterT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> Where<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> Select<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryOptionAsync<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, C>>, TryOptionAsync<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<EitherUnsafe<L, A>></param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOptionAsync<EitherUnsafe<L, A>> fa) =>
            FTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryOptionAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of TryOptionAsync<EitherUnsafe<L, A>></param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<EitherUnsafe<L, A>> fa, TryOptionAsync<EitherUnsafe<L, B>> fb) =>
            FTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryOptionAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> BindT<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>></returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> Traverse<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>></returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> Sequence<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> MapT<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> FilterT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> Where<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> Select<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this IEnumerable<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MSeq<EitherUnsafe<L, C>>, IEnumerable<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<EitherUnsafe<L, A>></param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, IEnumerable<EitherUnsafe<L, A>> fa) =>
            FSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSeq< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of IEnumerable<EitherUnsafe<L, A>></param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, IEnumerable<EitherUnsafe<L, A>> fa, IEnumerable<EitherUnsafe<L, B>> fb) =>
            FSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSeq< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<EitherUnsafe<L, A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Set<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<EitherUnsafe<L, A>></returns>
        [Pure]
        public static int CountT<L, A>(this Set<EitherUnsafe<L, A>> ma) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> BindT<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Set<B>></returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> Traverse<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<EitherUnsafe<L, A>>, traverses the inner
        /// values of type A, and returns EitherUnsafe<L, Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Set<A>></returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> Sequence<L, A>(this Set<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> MapT<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<EitherUnsafe<L, A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Set<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> FilterT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<EitherUnsafe<L, A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> Where<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<EitherUnsafe<L, B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> Select<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<EitherUnsafe<L, A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<EitherUnsafe<L, C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Set<EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                    .Inst.Bind<MSet<EitherUnsafe<L, C>>, Set<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MEitherUnsafe<L, B>).Bind<MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(mb, b => default(MEitherUnsafe<L, C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<EitherUnsafe<L, A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<EitherUnsafe<L, A>></param>
        /// <returns>Set<EitherUnsafe<L, B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Set<EitherUnsafe<L, A>> fa) =>
            FSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => FEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<EitherUnsafe<L, A>></param>
        /// <param name="fb">Monad of Set<EitherUnsafe<L, A>></param>
        /// <returns>Set<EitherUnsafe<L, B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Set<EitherUnsafe<L, A>> fa, Set<EitherUnsafe<L, B>> fb) =>
            FSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            FEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Task, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TaskT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Task<A>> ma) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Task<B>> BindT< A, B>(this Arr<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Arr<B>></returns>
        [Pure]
        public static Task<Arr<B>> Traverse< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Arr<A>></returns>
        [Pure]
        public static Task<Arr<A>> Sequence< A>(this Arr<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Task<B>> MapT< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Task<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Task<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Task<A>> ma, Action<A> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Task<A>> FilterT< A>(this Arr<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Task<A>> Where< A>(this Arr<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Task<B>> Select< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Task<C>> SelectMany< A, B, C>(
            this Arr<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MArr<Task<C>>, Arr<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Task<A>> PlusT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Task<A>> SubtractT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Task<A>> ProductT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Task<A>> DivideT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Task<A>> AppendT<SEMI,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Task<A>></param>
        /// <returns>Arr<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Task<A>> fa) =>
            FArr< Task<A>, Task<B>>.Inst.Apply(
                 MArr< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Task<A>></param>
        /// <param name="fb">Monad of Arr<Task<A>></param>
        /// <returns>Arr<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Task<A>> fa, Arr<Task<B>> fb) =>
            FArr< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MArr< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Task<A>> ma) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Task<B>> BindT< A, B>(this HashSet<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Task<A>>, traverses the inner
        /// values of type A, and returns Task<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<HashSet<B>></returns>
        [Pure]
        public static Task<HashSet<B>> Traverse< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Task<A>>, traverses the inner
        /// values of type A, and returns Task<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<HashSet<A>></returns>
        [Pure]
        public static Task<HashSet<A>> Sequence< A>(this HashSet<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Task<B>> MapT< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Task<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Task<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Task<A>> ma, Action<A> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Task<A>> FilterT< A>(this HashSet<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Task<A>> Where< A>(this HashSet<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Task<B>> Select< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Task<C>> SelectMany< A, B, C>(
            this HashSet<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MHashSet<Task<C>>, HashSet<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Task<A>> PlusT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Task<A>> SubtractT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Task<A>> ProductT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Task<A>> DivideT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Task<A>> AppendT<SEMI,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Task<A>></param>
        /// <returns>HashSet<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Task<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Task<A>> fa) =>
            FHashSet< Task<A>, Task<B>>.Inst.Apply(
                 MHashSet< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Task<A>></param>
        /// <param name="fb">Monad of HashSet<Task<A>></param>
        /// <returns>HashSet<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Task<A>> fa, HashSet<Task<B>> fb) =>
            FHashSet< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MHashSet< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Task<A>> ma) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Task<B>> BindT< A, B>(this Lst<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Lst<B>></returns>
        [Pure]
        public static Task<Lst<B>> Traverse< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Lst<A>></returns>
        [Pure]
        public static Task<Lst<A>> Sequence< A>(this Lst<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Task<B>> MapT< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Task<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Task<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Task<A>> ma, Action<A> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Task<A>> FilterT< A>(this Lst<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Task<A>> Where< A>(this Lst<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Task<B>> Select< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Task<C>> SelectMany< A, B, C>(
            this Lst<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MLst<Task<C>>, Lst<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Task<A>> PlusT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Task<A>> SubtractT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Task<A>> ProductT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Task<A>> DivideT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Task<A>> AppendT<SEMI,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Task<A>></param>
        /// <returns>Lst<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Task<A>> fa) =>
            FLst< Task<A>, Task<B>>.Inst.Apply(
                 MLst< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Task<A>></param>
        /// <param name="fb">Monad of Lst<Task<A>></param>
        /// <returns>Lst<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Task<A>> fa, Lst<Task<B>> fb) =>
            FLst< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MLst< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Task<A>> ma) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Task<B>> BindT< A, B>(this Option<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Option<B>></returns>
        [Pure]
        public static Task<Option<B>> Traverse< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Option<A>></returns>
        [Pure]
        public static Task<Option<A>> Sequence< A>(this Option<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Task<B>> MapT< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Task<A>> ma, Action<A> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Task<A>> FilterT< A>(this Option<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Task<A>> Where< A>(this Option<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Task<B>> Select< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Task<C>> SelectMany< A, B, C>(
            this Option<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MOption<Task<C>>, Option<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Task<A>> PlusT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Task<A>> SubtractT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Task<A>> ProductT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Task<A>> DivideT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Task<A>> AppendT<SEMI,  A>(this Option<Task<A>> x, Option<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Task<A>> x, Option<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Task<A>> x, Option<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Task<A>></param>
        /// <returns>Option<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Task<A>> fa) =>
            FOption< Task<A>, Task<B>>.Inst.Apply(
                 MOption< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Task<A>></param>
        /// <param name="fb">Monad of Option<Task<A>></param>
        /// <returns>Option<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Task<A>> fa, Option<Task<B>> fb) =>
            FOption< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MOption< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Task<A>> ma) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> BindT< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Task<A>>, traverses the inner
        /// values of type A, and returns Task<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<OptionUnsafe<B>></returns>
        [Pure]
        public static Task<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Task<A>>, traverses the inner
        /// values of type A, and returns Task<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<OptionUnsafe<A>></returns>
        [Pure]
        public static Task<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> MapT< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Task<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> FilterT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> Where< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> Select< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MOptionUnsafe<Task<C>>, OptionUnsafe<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> PlusT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> SubtractT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> ProductT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> DivideT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> AppendT<SEMI,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Task<A>></param>
        /// <returns>OptionUnsafe<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Task<A>> fa) =>
            FOptionUnsafe< Task<A>, Task<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Task<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Task<A>></param>
        /// <returns>OptionUnsafe<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Task<A>> fa, OptionUnsafe<Task<B>> fb) =>
            FOptionUnsafe< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MOptionUnsafe< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Task<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Task<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Task<A>> ma) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Task<B>> BindT<L, A, B>(this Either<L, Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Task<A>>, traverses the inner
        /// values of type A, and returns Task<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Either<L, B>></returns>
        [Pure]
        public static Task<Either<L, B>> Traverse<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Task<A>>, traverses the inner
        /// values of type A, and returns Task<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Either<L, A>></returns>
        [Pure]
        public static Task<Either<L, A>> Sequence<L, A>(this Either<L, Task<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Task<B>> MapT<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Task<A>> ma, Action<A> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Task<A>> FilterT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Task<A>> Where<L, A>(this Either<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Task<B>> Select<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Task<C>> SelectMany<L, A, B, C>(
            this Either<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MEither<L, Task<C>>, Either<L, Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Task<A>> PlusT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Task<A>> SubtractT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Task<A>> ProductT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Task<A>> DivideT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Task<A>> AppendT<SEMI, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Task<A>></param>
        /// <returns>Either<L, Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Task<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Task<A>> fa) =>
            FEither<L, Task<A>, Task<B>>.Inst.Apply(
                 MEither<L, Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Task<A>></param>
        /// <param name="fb">Monad of Either<L, Task<A>></param>
        /// <returns>Either<L, Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Task<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Task<A>> fa, Either<L, Task<B>> fb) =>
            FEither<L, Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MEither<L, Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Task<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Task<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Task<A>> ma) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> BindT<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Task<A>>, traverses the inner
        /// values of type A, and returns Task<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Task<A>>, traverses the inner
        /// values of type A, and returns Task<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Task<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> MapT<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Task<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> FilterT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> Where<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> Select<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Task<C>>, EitherUnsafe<L, Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Task<A>></param>
        /// <returns>EitherUnsafe<L, Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Task<A>> fa) =>
            FEitherUnsafe<L, Task<A>, Task<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Task<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Task<A>></param>
        /// <returns>EitherUnsafe<L, Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Task<A>> fa, EitherUnsafe<L, Task<B>> fb) =>
            FEitherUnsafe<L, Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Task<A>> ma) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Task<B>> BindT< A, B>(this Task<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Task<B>></returns>
        [Pure]
        public static Task<Task<B>> Traverse< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Task<A>></returns>
        [Pure]
        public static Task<Task<A>> Sequence< A>(this Task<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Task<B>> MapT< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Task<A>> ma, Action<A> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Task<A>> FilterT< A>(this Task<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Task<A>> Where< A>(this Task<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Task<B>> Select< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Task<C>> SelectMany< A, B, C>(
            this Task<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Task<A>> PlusT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Task<A>> SubtractT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Task<A>> ProductT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Task<A>> DivideT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Task<A>> AppendT<SEMI,  A>(this Task<Task<A>> x, Task<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Task<A>> x, Task<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Task<A>> x, Task<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Task<A>></param>
        /// <returns>Task<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Task<A>> fa) =>
            FTask< Task<A>, Task<B>>.Inst.Apply(
                 MTask< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Task<A>></param>
        /// <param name="fb">Monad of Task<Task<A>></param>
        /// <returns>Task<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Task<A>> fa, Task<Task<B>> fb) =>
            FTask< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTask< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Task<A>> ma) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Task<B>> BindT< A, B>(this Try<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Try<B>></returns>
        [Pure]
        public static Task<Try<B>> Traverse< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Try<A>></returns>
        [Pure]
        public static Task<Try<A>> Sequence< A>(this Try<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Task<B>> MapT< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Task<A>> ma, Action<A> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Task<A>> FilterT< A>(this Try<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Task<A>> Where< A>(this Try<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Task<B>> Select< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Task<C>> SelectMany< A, B, C>(
            this Try<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MTry<Task<C>>, Try<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Task<A>> PlusT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Task<A>> SubtractT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Task<A>> ProductT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Task<A>> DivideT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Task<A>> AppendT<SEMI,  A>(this Try<Task<A>> x, Try<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Task<A>> x, Try<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Task<A>> x, Try<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Task<A>></param>
        /// <returns>Try<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Task<A>> fa) =>
            FTry< Task<A>, Task<B>>.Inst.Apply(
                 MTry< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Task<A>></param>
        /// <param name="fb">Monad of Try<Task<A>></param>
        /// <returns>Try<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Task<A>> fa, Try<Task<B>> fb) =>
            FTry< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTry< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Task<A>> ma) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Task<B>> BindT< A, B>(this TryAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryAsync<B>></returns>
        [Pure]
        public static Task<TryAsync<B>> Traverse< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryAsync<A>></returns>
        [Pure]
        public static Task<TryAsync<A>> Sequence< A>(this TryAsync<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Task<B>> MapT< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Task<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Task<A>> FilterT< A>(this TryAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Task<A>> Where< A>(this TryAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Task<B>> Select< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Task<C>> SelectMany< A, B, C>(
            this TryAsync<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Task<A>> PlusT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Task<A>> SubtractT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Task<A>> ProductT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Task<A>> DivideT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Task<A>> AppendT<SEMI,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Task<A>></param>
        /// <returns>TryAsync<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Task<A>> fa) =>
            FTryAsync< Task<A>, Task<B>>.Inst.Apply(
                 MTryAsync< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Task<A>></param>
        /// <param name="fb">Monad of TryAsync<Task<A>></param>
        /// <returns>TryAsync<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Task<A>> fa, TryAsync<Task<B>> fb) =>
            FTryAsync< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Task<A>> ma) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Task<B>> BindT< A, B>(this TryOption<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOption<B>></returns>
        [Pure]
        public static Task<TryOption<B>> Traverse< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOption<A>></returns>
        [Pure]
        public static Task<TryOption<A>> Sequence< A>(this TryOption<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Task<B>> MapT< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Task<A>> ma, Action<A> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Task<A>> FilterT< A>(this TryOption<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Task<A>> Where< A>(this TryOption<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Task<B>> Select< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Task<C>> SelectMany< A, B, C>(
            this TryOption<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MTryOption<Task<C>>, TryOption<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Task<A>> PlusT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Task<A>> SubtractT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Task<A>> ProductT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Task<A>> DivideT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Task<A>> AppendT<SEMI,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Task<A>></param>
        /// <returns>TryOption<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Task<A>> fa) =>
            FTryOption< Task<A>, Task<B>>.Inst.Apply(
                 MTryOption< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Task<A>></param>
        /// <param name="fb">Monad of TryOption<Task<A>></param>
        /// <returns>TryOption<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Task<A>> fa, TryOption<Task<B>> fb) =>
            FTryOption< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryOption< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Task<A>> ma) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> BindT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOptionAsync<B>></returns>
        [Pure]
        public static Task<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Task<A>>, traverses the inner
        /// values of type A, and returns Task<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOptionAsync<A>></returns>
        [Pure]
        public static Task<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> MapT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Task<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> FilterT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> Where< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> Select< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> PlusT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> SubtractT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> ProductT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> DivideT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> AppendT<SEMI,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Task<A>></param>
        /// <returns>TryOptionAsync<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Task<A>> fa) =>
            FTryOptionAsync< Task<A>, Task<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Task<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Task<A>></param>
        /// <returns>TryOptionAsync<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Task<A>> fa, TryOptionAsync<Task<B>> fb) =>
            FTryOptionAsync< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryOptionAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Task<A>> ma) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Task<B>> BindT< A, B>(this IEnumerable<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Task<A>>, traverses the inner
        /// values of type A, and returns Task<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<IEnumerable<B>></returns>
        [Pure]
        public static Task<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Task<A>>, traverses the inner
        /// values of type A, and returns Task<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<IEnumerable<A>></returns>
        [Pure]
        public static Task<IEnumerable<A>> Sequence< A>(this IEnumerable<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Task<B>> MapT< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Task<A>> ma, Action<A> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> FilterT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> Where< A>(this IEnumerable<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Task<B>> Select< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Task<C>> SelectMany< A, B, C>(
            this IEnumerable<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MSeq<Task<C>>, IEnumerable<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Task<A>> PlusT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Task<A>> SubtractT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Task<A>> ProductT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Task<A>> DivideT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Task<A>> AppendT<SEMI,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Task<A>></param>
        /// <returns>IEnumerable<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Task<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Task<A>> fa) =>
            FSeq< Task<A>, Task<B>>.Inst.Apply(
                 MSeq< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Task<A>></param>
        /// <param name="fb">Monad of IEnumerable<Task<A>></param>
        /// <returns>IEnumerable<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Task<A>> fa, IEnumerable<Task<B>> fb) =>
            FSeq< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MSeq< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Task<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Task<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Task<A>> ma) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Task<B>> BindT< A, B>(this Set<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Set<B>></returns>
        [Pure]
        public static Task<Set<B>> Traverse< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Task<A>>, traverses the inner
        /// values of type A, and returns Task<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Set<A>></returns>
        [Pure]
        public static Task<Set<A>> Sequence< A>(this Set<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Task<B>> MapT< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Task<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Task<A>> ma, Action<A> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Task<A>> FilterT< A>(this Set<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Task<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Task<A>> Where< A>(this Set<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Task<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Task<B>> Select< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Task<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Task<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Task<C>> SelectMany< A, B, C>(
            this Set<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                    .Inst.Bind<MSet<Task<C>>, Set<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTask<B>).Bind<MTask<C>, Task<C>, C>(mb, b => default(MTask<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Task<A>> PlusT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Task<A>> SubtractT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Task<A>> ProductT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Task<A>> DivideT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Task<A>> AppendT<SEMI,  A>(this Set<Task<A>> x, Set<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Task<A>> x, Set<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Task<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Task<A>> x, Set<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Task<A>></param>
        /// <returns>Set<Task<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Task<A>> fa) =>
            FSet< Task<A>, Task<B>>.Inst.Apply(
                 MSet< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => FTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Task<A>></param>
        /// <param name="fb">Monad of Set<Task<A>></param>
        /// <returns>Set<Task<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Task<A>> fa, Set<Task<B>> fb) =>
            FSet< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MSet< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            FTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Try, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Try<A>> ma) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Try<B>> BindT< A, B>(this Arr<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Arr<B>></returns>
        [Pure]
        public static Try<Arr<B>> Traverse< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Arr<A>></returns>
        [Pure]
        public static Try<Arr<A>> Sequence< A>(this Arr<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Try<B>> MapT< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Try<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Try<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Try<A>> ma, Action<A> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Try<A>> FilterT< A>(this Arr<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Try<A>> Where< A>(this Arr<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Try<B>> Select< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Try<C>> SelectMany< A, B, C>(
            this Arr<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MArr<Try<C>>, Arr<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Try<A>> PlusT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Try<A>> SubtractT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Try<A>> ProductT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Try<A>> DivideT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Try<A>> AppendT<SEMI,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Try<A>></param>
        /// <returns>Arr<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Try<A>> fa) =>
            FArr< Try<A>, Try<B>>.Inst.Apply(
                 MArr< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Try<A>></param>
        /// <param name="fb">Monad of Arr<Try<A>></param>
        /// <returns>Arr<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Try<A>> fa, Arr<Try<B>> fb) =>
            FArr< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MArr< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Try<A>> ma) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Try<B>> BindT< A, B>(this HashSet<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Try<A>>, traverses the inner
        /// values of type A, and returns Try<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<HashSet<B>></returns>
        [Pure]
        public static Try<HashSet<B>> Traverse< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Try<A>>, traverses the inner
        /// values of type A, and returns Try<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<HashSet<A>></returns>
        [Pure]
        public static Try<HashSet<A>> Sequence< A>(this HashSet<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Try<B>> MapT< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Try<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Try<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Try<A>> ma, Action<A> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Try<A>> FilterT< A>(this HashSet<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Try<A>> Where< A>(this HashSet<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Try<B>> Select< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Try<C>> SelectMany< A, B, C>(
            this HashSet<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MHashSet<Try<C>>, HashSet<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Try<A>> PlusT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Try<A>> SubtractT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Try<A>> ProductT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Try<A>> DivideT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Try<A>> AppendT<SEMI,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Try<A>></param>
        /// <returns>HashSet<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Try<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Try<A>> fa) =>
            FHashSet< Try<A>, Try<B>>.Inst.Apply(
                 MHashSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Try<A>></param>
        /// <param name="fb">Monad of HashSet<Try<A>></param>
        /// <returns>HashSet<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Try<A>> fa, HashSet<Try<B>> fb) =>
            FHashSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MHashSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Try<A>> ma) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Try<B>> BindT< A, B>(this Lst<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Lst<B>></returns>
        [Pure]
        public static Try<Lst<B>> Traverse< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Lst<A>></returns>
        [Pure]
        public static Try<Lst<A>> Sequence< A>(this Lst<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Try<B>> MapT< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Try<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Try<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Try<A>> ma, Action<A> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Try<A>> FilterT< A>(this Lst<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Try<A>> Where< A>(this Lst<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Try<B>> Select< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Try<C>> SelectMany< A, B, C>(
            this Lst<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MLst<Try<C>>, Lst<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Try<A>> PlusT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Try<A>> SubtractT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Try<A>> ProductT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Try<A>> DivideT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Try<A>> AppendT<SEMI,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Try<A>></param>
        /// <returns>Lst<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Try<A>> fa) =>
            FLst< Try<A>, Try<B>>.Inst.Apply(
                 MLst< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Try<A>></param>
        /// <param name="fb">Monad of Lst<Try<A>></param>
        /// <returns>Lst<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Try<A>> fa, Lst<Try<B>> fb) =>
            FLst< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MLst< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Try<A>> ma) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Try<B>> BindT< A, B>(this Option<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Option<B>></returns>
        [Pure]
        public static Try<Option<B>> Traverse< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Option<A>></returns>
        [Pure]
        public static Try<Option<A>> Sequence< A>(this Option<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Try<B>> MapT< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Try<A>> ma, Action<A> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Try<A>> FilterT< A>(this Option<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Try<A>> Where< A>(this Option<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Try<B>> Select< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Try<C>> SelectMany< A, B, C>(
            this Option<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MOption<Try<C>>, Option<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Try<A>> PlusT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Try<A>> SubtractT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Try<A>> ProductT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Try<A>> DivideT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Try<A>> AppendT<SEMI,  A>(this Option<Try<A>> x, Option<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Try<A>> x, Option<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Try<A>> x, Option<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Try<A>></param>
        /// <returns>Option<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Try<A>> fa) =>
            FOption< Try<A>, Try<B>>.Inst.Apply(
                 MOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Try<A>></param>
        /// <param name="fb">Monad of Option<Try<A>></param>
        /// <returns>Option<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Try<A>> fa, Option<Try<B>> fb) =>
            FOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Try<A>> ma) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> BindT< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Try<A>>, traverses the inner
        /// values of type A, and returns Try<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<OptionUnsafe<B>></returns>
        [Pure]
        public static Try<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Try<A>>, traverses the inner
        /// values of type A, and returns Try<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<OptionUnsafe<A>></returns>
        [Pure]
        public static Try<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> MapT< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Try<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> FilterT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> Where< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> Select< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Try<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MOptionUnsafe<Try<C>>, OptionUnsafe<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> PlusT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> SubtractT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> ProductT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> DivideT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> AppendT<SEMI,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Try<A>></param>
        /// <returns>OptionUnsafe<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Try<A>> fa) =>
            FOptionUnsafe< Try<A>, Try<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Try<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Try<A>></param>
        /// <returns>OptionUnsafe<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Try<A>> fa, OptionUnsafe<Try<B>> fb) =>
            FOptionUnsafe< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOptionUnsafe< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Try<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Try<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Try<A>> ma) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Try<B>> BindT<L, A, B>(this Either<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Try<A>>, traverses the inner
        /// values of type A, and returns Try<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Either<L, B>></returns>
        [Pure]
        public static Try<Either<L, B>> Traverse<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Try<A>>, traverses the inner
        /// values of type A, and returns Try<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Either<L, A>></returns>
        [Pure]
        public static Try<Either<L, A>> Sequence<L, A>(this Either<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Try<B>> MapT<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Try<A>> ma, Action<A> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Try<A>> FilterT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Try<A>> Where<L, A>(this Either<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Try<B>> Select<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Try<C>> SelectMany<L, A, B, C>(
            this Either<L, Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MEither<L, Try<C>>, Either<L, Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Try<A>> PlusT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Try<A>> SubtractT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Try<A>> ProductT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Try<A>> DivideT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Try<A>> AppendT<SEMI, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Try<A>></param>
        /// <returns>Either<L, Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Try<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Try<A>> fa) =>
            FEither<L, Try<A>, Try<B>>.Inst.Apply(
                 MEither<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Try<A>></param>
        /// <param name="fb">Monad of Either<L, Try<A>></param>
        /// <returns>Either<L, Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Try<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Try<A>> fa, Either<L, Try<B>> fb) =>
            FEither<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEither<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Try<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Try<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Try<A>> ma) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> BindT<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Try<A>>, traverses the inner
        /// values of type A, and returns Try<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Try<A>>, traverses the inner
        /// values of type A, and returns Try<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> MapT<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Try<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> FilterT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> Where<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> Select<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Try<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Try<C>>, EitherUnsafe<L, Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Try<A>></param>
        /// <returns>EitherUnsafe<L, Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Try<A>> fa) =>
            FEitherUnsafe<L, Try<A>, Try<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Try<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Try<A>></param>
        /// <returns>EitherUnsafe<L, Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Try<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Try<A>> fa, EitherUnsafe<L, Try<B>> fb) =>
            FEitherUnsafe<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Try<A>> ma) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Try<B>> BindT< A, B>(this Task<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Task<B>></returns>
        [Pure]
        public static Try<Task<B>> Traverse< A, B>(this Task<Try<A>> ma, Func<A, B> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Task<A>></returns>
        [Pure]
        public static Try<Task<A>> Sequence< A>(this Task<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Try<B>> MapT< A, B>(this Task<Try<A>> ma, Func<A, B> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Try<A>> ma, Action<A> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Try<A>> FilterT< A>(this Task<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Try<A>> Where< A>(this Task<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Try<B>> Select< A, B>(this Task<Try<A>> ma, Func<A, B> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Try<C>> SelectMany< A, B, C>(
            this Task<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MTask<Try<C>>, Task<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Try<A>> PlusT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Try<A>> SubtractT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Try<A>> ProductT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Try<A>> DivideT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Try<A>> AppendT<SEMI,  A>(this Task<Try<A>> x, Task<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Try<A>> x, Task<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Try<A>> x, Task<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Try<A>></param>
        /// <returns>Task<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Try<A>> fa) =>
            FTask< Try<A>, Try<B>>.Inst.Apply(
                 MTask< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Try<A>></param>
        /// <param name="fb">Monad of Task<Try<A>></param>
        /// <returns>Task<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Try<A>> fa, Task<Try<B>> fb) =>
            FTask< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTask< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Try<A>> ma) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Try<B>> BindT< A, B>(this Try<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Try<B>></returns>
        [Pure]
        public static Try<Try<B>> Traverse< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Try<A>></returns>
        [Pure]
        public static Try<Try<A>> Sequence< A>(this Try<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Try<B>> MapT< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Try<A>> ma, Action<A> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Try<A>> FilterT< A>(this Try<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Try<A>> Where< A>(this Try<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Try<B>> Select< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Try<C>> SelectMany< A, B, C>(
            this Try<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MTry<Try<C>>, Try<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Try<A>> PlusT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Try<A>> SubtractT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Try<A>> ProductT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Try<A>> DivideT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Try<A>> AppendT<SEMI,  A>(this Try<Try<A>> x, Try<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Try<A>> x, Try<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Try<A>> x, Try<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Try<A>></param>
        /// <returns>Try<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Try<A>> fa) =>
            FTry< Try<A>, Try<B>>.Inst.Apply(
                 MTry< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Try<A>></param>
        /// <param name="fb">Monad of Try<Try<A>></param>
        /// <returns>Try<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Try<A>> fa, Try<Try<B>> fb) =>
            FTry< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTry< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Try<A>> ma) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Try<B>> BindT< A, B>(this TryAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryAsync<B>></returns>
        [Pure]
        public static Try<TryAsync<B>> Traverse< A, B>(this TryAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryAsync<A>></returns>
        [Pure]
        public static Try<TryAsync<A>> Sequence< A>(this TryAsync<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Try<B>> MapT< A, B>(this TryAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Try<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Try<A>> FilterT< A>(this TryAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Try<A>> Where< A>(this TryAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Try<B>> Select< A, B>(this TryAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Try<C>> SelectMany< A, B, C>(
            this TryAsync<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MTryAsync<Try<C>>, TryAsync<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Try<A>> PlusT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Try<A>> SubtractT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Try<A>> ProductT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Try<A>> DivideT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Try<A>> AppendT<SEMI,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Try<A>></param>
        /// <returns>TryAsync<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Try<A>> fa) =>
            FTryAsync< Try<A>, Try<B>>.Inst.Apply(
                 MTryAsync< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Try<A>></param>
        /// <param name="fb">Monad of TryAsync<Try<A>></param>
        /// <returns>TryAsync<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Try<A>> fa, TryAsync<Try<B>> fb) =>
            FTryAsync< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Try<A>> ma) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Try<B>> BindT< A, B>(this TryOption<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOption<B>></returns>
        [Pure]
        public static Try<TryOption<B>> Traverse< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOption<A>></returns>
        [Pure]
        public static Try<TryOption<A>> Sequence< A>(this TryOption<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Try<B>> MapT< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Try<A>> ma, Action<A> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Try<A>> FilterT< A>(this TryOption<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Try<A>> Where< A>(this TryOption<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Try<B>> Select< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Try<C>> SelectMany< A, B, C>(
            this TryOption<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MTryOption<Try<C>>, TryOption<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Try<A>> PlusT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Try<A>> SubtractT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Try<A>> ProductT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Try<A>> DivideT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Try<A>> AppendT<SEMI,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Try<A>></param>
        /// <returns>TryOption<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Try<A>> fa) =>
            FTryOption< Try<A>, Try<B>>.Inst.Apply(
                 MTryOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Try<A>></param>
        /// <param name="fb">Monad of TryOption<Try<A>></param>
        /// <returns>TryOption<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Try<A>> fa, TryOption<Try<B>> fb) =>
            FTryOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Try<A>> ma) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> BindT< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOptionAsync<B>></returns>
        [Pure]
        public static Try<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Try<A>>, traverses the inner
        /// values of type A, and returns Try<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOptionAsync<A>></returns>
        [Pure]
        public static Try<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> MapT< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Try<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> FilterT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> Where< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> Select< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Try<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MTryOptionAsync<Try<C>>, TryOptionAsync<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> PlusT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> SubtractT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> ProductT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> DivideT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> AppendT<SEMI,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Try<A>></param>
        /// <returns>TryOptionAsync<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Try<A>> fa) =>
            FTryOptionAsync< Try<A>, Try<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Try<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Try<A>></param>
        /// <returns>TryOptionAsync<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Try<A>> fa, TryOptionAsync<Try<B>> fb) =>
            FTryOptionAsync< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryOptionAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Try<A>> ma) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Try<B>> BindT< A, B>(this IEnumerable<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Try<A>>, traverses the inner
        /// values of type A, and returns Try<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<IEnumerable<B>></returns>
        [Pure]
        public static Try<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Try<A>>, traverses the inner
        /// values of type A, and returns Try<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<IEnumerable<A>></returns>
        [Pure]
        public static Try<IEnumerable<A>> Sequence< A>(this IEnumerable<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Try<B>> MapT< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Try<A>> ma, Action<A> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Try<A>> FilterT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Try<A>> Where< A>(this IEnumerable<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Try<B>> Select< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Try<C>> SelectMany< A, B, C>(
            this IEnumerable<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MSeq<Try<C>>, IEnumerable<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Try<A>> PlusT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Try<A>> SubtractT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Try<A>> ProductT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Try<A>> DivideT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Try<A>> AppendT<SEMI,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Try<A>></param>
        /// <returns>IEnumerable<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Try<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Try<A>> fa) =>
            FSeq< Try<A>, Try<B>>.Inst.Apply(
                 MSeq< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Try<A>></param>
        /// <param name="fb">Monad of IEnumerable<Try<A>></param>
        /// <returns>IEnumerable<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Try<A>> fa, IEnumerable<Try<B>> fb) =>
            FSeq< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSeq< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Try<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Try<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Try<A>> ma) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Try<B>> BindT< A, B>(this Set<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Set<B>></returns>
        [Pure]
        public static Try<Set<B>> Traverse< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Try<A>>, traverses the inner
        /// values of type A, and returns Try<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Set<A>></returns>
        [Pure]
        public static Try<Set<A>> Sequence< A>(this Set<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Try<B>> MapT< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Try<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Try<A>> ma, Action<A> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Try<A>> FilterT< A>(this Set<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Try<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Try<A>> Where< A>(this Set<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Try<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Try<B>> Select< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Try<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Try<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Try<C>> SelectMany< A, B, C>(
            this Set<Try<A>> ma,
            Func<A, Try<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                    .Inst.Bind<MSet<Try<C>>, Set<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTry<B>).Bind<MTry<C>, Try<C>, C>(mb, b => default(MTry<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Try<A>> PlusT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Try<A>> SubtractT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Try<A>> ProductT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Try<A>> DivideT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Try<A>> AppendT<SEMI,  A>(this Set<Try<A>> x, Set<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Try<A>> x, Set<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Try<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Try<A>> x, Set<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Try<A>></param>
        /// <returns>Set<Try<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Try<A>> fa) =>
            FSet< Try<A>, Try<B>>.Inst.Apply(
                 MSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => FTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Try<A>></param>
        /// <param name="fb">Monad of Set<Try<A>></param>
        /// <returns>Set<Try<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Try<A>> fa, Set<Try<B>> fb) =>
            FSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            FTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for TryAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryAsyncT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<TryAsync<A>> ma) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryAsync<B>> BindT< A, B>(this Arr<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Arr<B>></returns>
        [Pure]
        public static TryAsync<Arr<B>> Traverse< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Arr<A>></returns>
        [Pure]
        public static TryAsync<Arr<A>> Sequence< A>(this Arr<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryAsync<B>> MapT< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<TryAsync<A>> ma, Action<A> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> FilterT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> Where< A>(this Arr<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryAsync<B>> Select< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryAsync<C>> SelectMany< A, B, C>(
            this Arr<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MArr<TryAsync<C>>, Arr<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryAsync<A>> PlusT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryAsync<A>> SubtractT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<TryAsync<A>> ProductT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<TryAsync<A>> DivideT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<TryAsync<A>> AppendT<SEMI,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<TryAsync<A>></param>
        /// <returns>Arr<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryAsync<A>> fa) =>
            FArr< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MArr< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<TryAsync<A>></param>
        /// <param name="fb">Monad of Arr<TryAsync<A>></param>
        /// <returns>Arr<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryAsync<A>> fa, Arr<TryAsync<B>> fb) =>
            FArr< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MArr< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<TryAsync<A>> ma) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryAsync<B>> BindT< A, B>(this HashSet<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<HashSet<B>></returns>
        [Pure]
        public static TryAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<HashSet<A>></returns>
        [Pure]
        public static TryAsync<HashSet<A>> Sequence< A>(this HashSet<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryAsync<B>> MapT< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<TryAsync<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> FilterT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> Where< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryAsync<B>> Select< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MHashSet<TryAsync<C>>, HashSet<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> PlusT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> SubtractT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> ProductT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> DivideT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> AppendT<SEMI,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<TryAsync<A>></param>
        /// <returns>HashSet<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryAsync<A>> fa) =>
            FHashSet< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MHashSet< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<TryAsync<A>></param>
        /// <param name="fb">Monad of HashSet<TryAsync<A>></param>
        /// <returns>HashSet<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryAsync<A>> fa, HashSet<TryAsync<B>> fb) =>
            FHashSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MHashSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<TryAsync<A>> ma) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryAsync<B>> BindT< A, B>(this Lst<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Lst<B>></returns>
        [Pure]
        public static TryAsync<Lst<B>> Traverse< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Lst<A>></returns>
        [Pure]
        public static TryAsync<Lst<A>> Sequence< A>(this Lst<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryAsync<B>> MapT< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<TryAsync<A>> ma, Action<A> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> FilterT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> Where< A>(this Lst<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryAsync<B>> Select< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryAsync<C>> SelectMany< A, B, C>(
            this Lst<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MLst<TryAsync<C>>, Lst<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryAsync<A>> PlusT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryAsync<A>> SubtractT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<TryAsync<A>> ProductT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<TryAsync<A>> DivideT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<TryAsync<A>> AppendT<SEMI,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<TryAsync<A>></param>
        /// <returns>Lst<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryAsync<A>> fa) =>
            FLst< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MLst< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<TryAsync<A>></param>
        /// <param name="fb">Monad of Lst<TryAsync<A>></param>
        /// <returns>Lst<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryAsync<A>> fa, Lst<TryAsync<B>> fb) =>
            FLst< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MLst< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<TryAsync<A>> ma) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryAsync<B>> BindT< A, B>(this Option<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Option<B>></returns>
        [Pure]
        public static TryAsync<Option<B>> Traverse< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Option<A>></returns>
        [Pure]
        public static TryAsync<Option<A>> Sequence< A>(this Option<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryAsync<B>> MapT< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<TryAsync<A>> ma, Action<A> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryAsync<A>> FilterT< A>(this Option<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryAsync<A>> Where< A>(this Option<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryAsync<B>> Select< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryAsync<C>> SelectMany< A, B, C>(
            this Option<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MOption<TryAsync<C>>, Option<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryAsync<A>> PlusT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryAsync<A>> SubtractT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<TryAsync<A>> ProductT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<TryAsync<A>> DivideT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<TryAsync<A>> AppendT<SEMI,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<TryAsync<A>></param>
        /// <returns>Option<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryAsync<A>> fa) =>
            FOption< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MOption< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<TryAsync<A>></param>
        /// <param name="fb">Monad of Option<TryAsync<A>></param>
        /// <returns>Option<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryAsync<A>> fa, Option<TryAsync<B>> fb) =>
            FOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<TryAsync<A>> ma) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> BindT< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<OptionUnsafe<B>></returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> MapT< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<TryAsync<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> FilterT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> Where< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> Select< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MOptionUnsafe<TryAsync<C>>, OptionUnsafe<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> PlusT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> ProductT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> DivideT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryAsync<A>></param>
        /// <returns>OptionUnsafe<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryAsync<A>> fa) =>
            FOptionUnsafe< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryAsync<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<TryAsync<A>></param>
        /// <returns>OptionUnsafe<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryAsync<A>> fa, OptionUnsafe<TryAsync<B>> fb) =>
            FOptionUnsafe< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, TryAsync<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, TryAsync<A>> ma) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryAsync<B>> BindT<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Either<L, B>></returns>
        [Pure]
        public static TryAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Either<L, A>></returns>
        [Pure]
        public static TryAsync<Either<L, A>> Sequence<L, A>(this Either<L, TryAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryAsync<B>> MapT<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, TryAsync<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> FilterT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> Where<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryAsync<B>> Select<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MEither<L, TryAsync<C>>, Either<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> PlusT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> SubtractT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> ProductT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> DivideT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> AppendT<SEMI, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, TryAsync<A>></param>
        /// <returns>Either<L, TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, TryAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryAsync<A>> fa) =>
            FEither<L, TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MEither<L, Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, TryAsync<A>></param>
        /// <param name="fb">Monad of Either<L, TryAsync<A>></param>
        /// <returns>Either<L, TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, TryAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryAsync<A>> fa, Either<L, TryAsync<B>> fb) =>
            FEither<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MEither<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, TryAsync<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> BindT<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<EitherUnsafe<L, B>></returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> Where<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> Select<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, TryAsync<C>>, EitherUnsafe<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryAsync<A>></param>
        /// <returns>EitherUnsafe<L, TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryAsync<A>> fa) =>
            FEitherUnsafe<L, TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryAsync<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, TryAsync<A>></param>
        /// <returns>EitherUnsafe<L, TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryAsync<A>> fa, EitherUnsafe<L, TryAsync<B>> fb) =>
            FEitherUnsafe<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<TryAsync<A>> ma) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryAsync<B>> BindT< A, B>(this Task<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Task<B>></returns>
        [Pure]
        public static TryAsync<Task<B>> Traverse< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Task<A>></returns>
        [Pure]
        public static TryAsync<Task<A>> Sequence< A>(this Task<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryAsync<B>> MapT< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryAsync<A>> FilterT< A>(this Task<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryAsync<A>> Where< A>(this Task<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryAsync<B>> Select< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryAsync<C>> SelectMany< A, B, C>(
            this Task<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryAsync<A>> PlusT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryAsync<A>> SubtractT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<TryAsync<A>> ProductT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<TryAsync<A>> DivideT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<TryAsync<A>> AppendT<SEMI,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<TryAsync<A>></param>
        /// <returns>Task<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryAsync<A>> fa) =>
            FTask< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTask< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<TryAsync<A>></param>
        /// <param name="fb">Monad of Task<TryAsync<A>></param>
        /// <returns>Task<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryAsync<A>> fa, Task<TryAsync<B>> fb) =>
            FTask< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTask< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<TryAsync<A>> ma) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryAsync<B>> BindT< A, B>(this Try<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Try<B>></returns>
        [Pure]
        public static TryAsync<Try<B>> Traverse< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Try<A>></returns>
        [Pure]
        public static TryAsync<Try<A>> Sequence< A>(this Try<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryAsync<B>> MapT< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryAsync<A>> FilterT< A>(this Try<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryAsync<A>> Where< A>(this Try<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryAsync<B>> Select< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryAsync<C>> SelectMany< A, B, C>(
            this Try<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MTry<TryAsync<C>>, Try<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryAsync<A>> PlusT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryAsync<A>> SubtractT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<TryAsync<A>> ProductT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<TryAsync<A>> DivideT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<TryAsync<A>> AppendT<SEMI,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<TryAsync<A>></param>
        /// <returns>Try<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryAsync<A>> fa) =>
            FTry< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTry< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<TryAsync<A>></param>
        /// <param name="fb">Monad of Try<TryAsync<A>></param>
        /// <returns>Try<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryAsync<A>> fa, Try<TryAsync<B>> fb) =>
            FTry< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTry< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<TryAsync<A>> ma) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> BindT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryAsync<B>></returns>
        [Pure]
        public static TryAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryAsync<A>></returns>
        [Pure]
        public static TryAsync<TryAsync<A>> Sequence< A>(this TryAsync<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> MapT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> FilterT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> Where< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> Select< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> PlusT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> SubtractT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> ProductT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> DivideT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> AppendT<SEMI,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryAsync<A>></param>
        /// <returns>TryAsync<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryAsync<A>> fa) =>
            FTryAsync< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryAsync< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryAsync<A>></param>
        /// <param name="fb">Monad of TryAsync<TryAsync<A>></param>
        /// <returns>TryAsync<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryAsync<A>> fa, TryAsync<TryAsync<B>> fb) =>
            FTryAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<TryAsync<A>> ma) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryAsync<B>> BindT< A, B>(this TryOption<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOption<B>></returns>
        [Pure]
        public static TryAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOption<A>></returns>
        [Pure]
        public static TryAsync<TryOption<A>> Sequence< A>(this TryOption<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryAsync<B>> MapT< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> FilterT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> Where< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryAsync<B>> Select< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MTryOption<TryAsync<C>>, TryOption<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> PlusT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> SubtractT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> ProductT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> DivideT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> AppendT<SEMI,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<TryAsync<A>></param>
        /// <returns>TryOption<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryAsync<A>> fa) =>
            FTryOption< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryOption< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<TryAsync<A>></param>
        /// <param name="fb">Monad of TryOption<TryAsync<A>></param>
        /// <returns>TryOption<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryAsync<A>> fa, TryOption<TryAsync<B>> fb) =>
            FTryOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<TryAsync<A>> ma) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> BindT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOptionAsync<B>></returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> MapT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> FilterT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> Where< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> Select< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> PlusT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> ProductT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> DivideT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryAsync<A>></param>
        /// <returns>TryOptionAsync<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryAsync<A>> fa) =>
            FTryOptionAsync< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryAsync<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<TryAsync<A>></param>
        /// <returns>TryOptionAsync<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryAsync<A>> fa, TryOptionAsync<TryAsync<B>> fb) =>
            FTryOptionAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<TryAsync<A>> ma) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> BindT< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<IEnumerable<B>></returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<IEnumerable<A>></returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> Sequence< A>(this IEnumerable<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> MapT< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<TryAsync<A>> ma, Action<A> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> FilterT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> Where< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> Select< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MSeq<TryAsync<C>>, IEnumerable<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> PlusT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> SubtractT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> ProductT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> DivideT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> AppendT<SEMI,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryAsync<A>></param>
        /// <returns>IEnumerable<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryAsync<A>> fa) =>
            FSeq< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MSeq< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryAsync<A>></param>
        /// <param name="fb">Monad of IEnumerable<TryAsync<A>></param>
        /// <returns>IEnumerable<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryAsync<A>> fa, IEnumerable<TryAsync<B>> fb) =>
            FSeq< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MSeq< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<TryAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<TryAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<TryAsync<A>> ma) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryAsync<B>> BindT< A, B>(this Set<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Set<B>></returns>
        [Pure]
        public static TryAsync<Set<B>> Traverse< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<TryAsync<A>>, traverses the inner
        /// values of type A, and returns TryAsync<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Set<A>></returns>
        [Pure]
        public static TryAsync<Set<A>> Sequence< A>(this Set<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryAsync<B>> MapT< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<TryAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<TryAsync<A>> ma, Action<A> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryAsync<A>> FilterT< A>(this Set<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryAsync<A>> Where< A>(this Set<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryAsync<B>> Select< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<TryAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryAsync<C>> SelectMany< A, B, C>(
            this Set<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                    .Inst.Bind<MSet<TryAsync<C>>, Set<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryAsync<B>).Bind<MTryAsync<C>, TryAsync<C>, C>(mb, b => default(MTryAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryAsync<A>> PlusT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryAsync<A>> SubtractT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<TryAsync<A>> ProductT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<TryAsync<A>> DivideT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<TryAsync<A>> AppendT<SEMI,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<TryAsync<A>></param>
        /// <returns>Set<TryAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryAsync<A>> fa) =>
            FSet< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MSet< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => FTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<TryAsync<A>></param>
        /// <param name="fb">Monad of Set<TryAsync<A>></param>
        /// <returns>Set<TryAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryAsync<A>> fa, Set<TryAsync<B>> fb) =>
            FSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            FTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for TryOption, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<TryOption<A>> ma) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOption<B>> BindT< A, B>(this Arr<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Arr<B>></returns>
        [Pure]
        public static TryOption<Arr<B>> Traverse< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Arr<A>></returns>
        [Pure]
        public static TryOption<Arr<A>> Sequence< A>(this Arr<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOption<B>> MapT< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<TryOption<A>> ma, Action<A> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryOption<A>> FilterT< A>(this Arr<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryOption<A>> Where< A>(this Arr<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOption<B>> Select< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOption<C>> SelectMany< A, B, C>(
            this Arr<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MArr<TryOption<C>>, Arr<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOption<A>> PlusT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOption<A>> SubtractT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<TryOption<A>> ProductT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<TryOption<A>> DivideT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<TryOption<A>> AppendT<SEMI,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<TryOption<A>></param>
        /// <returns>Arr<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryOption<A>> fa) =>
            FArr< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MArr< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<TryOption<A>></param>
        /// <param name="fb">Monad of Arr<TryOption<A>></param>
        /// <returns>Arr<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryOption<A>> fa, Arr<TryOption<B>> fb) =>
            FArr< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MArr< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<TryOption<A>> ma) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOption<B>> BindT< A, B>(this HashSet<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<HashSet<B>></returns>
        [Pure]
        public static TryOption<HashSet<B>> Traverse< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<HashSet<A>></returns>
        [Pure]
        public static TryOption<HashSet<A>> Sequence< A>(this HashSet<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOption<B>> MapT< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<TryOption<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryOption<A>> FilterT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryOption<A>> Where< A>(this HashSet<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOption<B>> Select< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOption<C>> SelectMany< A, B, C>(
            this HashSet<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MHashSet<TryOption<C>>, HashSet<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOption<A>> PlusT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOption<A>> SubtractT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<TryOption<A>> ProductT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<TryOption<A>> DivideT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<TryOption<A>> AppendT<SEMI,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<TryOption<A>></param>
        /// <returns>HashSet<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryOption<A>> fa) =>
            FHashSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MHashSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<TryOption<A>></param>
        /// <param name="fb">Monad of HashSet<TryOption<A>></param>
        /// <returns>HashSet<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryOption<A>> fa, HashSet<TryOption<B>> fb) =>
            FHashSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MHashSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<TryOption<A>> ma) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOption<B>> BindT< A, B>(this Lst<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Lst<B>></returns>
        [Pure]
        public static TryOption<Lst<B>> Traverse< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Lst<A>></returns>
        [Pure]
        public static TryOption<Lst<A>> Sequence< A>(this Lst<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOption<B>> MapT< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<TryOption<A>> ma, Action<A> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryOption<A>> FilterT< A>(this Lst<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryOption<A>> Where< A>(this Lst<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOption<B>> Select< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOption<C>> SelectMany< A, B, C>(
            this Lst<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MLst<TryOption<C>>, Lst<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOption<A>> PlusT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOption<A>> SubtractT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<TryOption<A>> ProductT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<TryOption<A>> DivideT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<TryOption<A>> AppendT<SEMI,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<TryOption<A>></param>
        /// <returns>Lst<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryOption<A>> fa) =>
            FLst< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MLst< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<TryOption<A>></param>
        /// <param name="fb">Monad of Lst<TryOption<A>></param>
        /// <returns>Lst<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryOption<A>> fa, Lst<TryOption<B>> fb) =>
            FLst< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MLst< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<TryOption<A>> ma) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOption<B>> BindT< A, B>(this Option<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Option<B>></returns>
        [Pure]
        public static TryOption<Option<B>> Traverse< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Option<A>></returns>
        [Pure]
        public static TryOption<Option<A>> Sequence< A>(this Option<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOption<B>> MapT< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<TryOption<A>> ma, Action<A> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryOption<A>> FilterT< A>(this Option<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryOption<A>> Where< A>(this Option<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOption<B>> Select< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOption<C>> SelectMany< A, B, C>(
            this Option<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MOption<TryOption<C>>, Option<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOption<A>> PlusT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOption<A>> SubtractT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<TryOption<A>> ProductT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<TryOption<A>> DivideT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<TryOption<A>> AppendT<SEMI,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<TryOption<A>></param>
        /// <returns>Option<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryOption<A>> fa) =>
            FOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<TryOption<A>></param>
        /// <param name="fb">Monad of Option<TryOption<A>></param>
        /// <returns>Option<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryOption<A>> fa, Option<TryOption<B>> fb) =>
            FOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<TryOption<A>> ma) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> BindT< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<OptionUnsafe<B>></returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<OptionUnsafe<A>></returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> MapT< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<TryOption<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> FilterT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> Where< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> Select< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOption<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MOptionUnsafe<TryOption<C>>, OptionUnsafe<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> PlusT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> ProductT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> DivideT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryOption<A>></param>
        /// <returns>OptionUnsafe<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryOption<A>> fa) =>
            FOptionUnsafe< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryOption<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<TryOption<A>></param>
        /// <returns>OptionUnsafe<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryOption<A>> fa, OptionUnsafe<TryOption<B>> fb) =>
            FOptionUnsafe< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, TryOption<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, TryOption<A>> ma) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOption<B>> BindT<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Either<L, B>></returns>
        [Pure]
        public static TryOption<Either<L, B>> Traverse<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Either<L, A>></returns>
        [Pure]
        public static TryOption<Either<L, A>> Sequence<L, A>(this Either<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOption<B>> MapT<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryOption<A>> FilterT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryOption<A>> Where<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOption<B>> Select<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOption<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MEither<L, TryOption<C>>, Either<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOption<A>> PlusT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOption<A>> SubtractT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, TryOption<A>> ProductT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, TryOption<A>> DivideT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, TryOption<A>> AppendT<SEMI, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, TryOption<A>></param>
        /// <returns>Either<L, TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, TryOption<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryOption<A>> fa) =>
            FEither<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEither<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, TryOption<A>></param>
        /// <param name="fb">Monad of Either<L, TryOption<A>></param>
        /// <returns>Either<L, TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, TryOption<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryOption<A>> fa, Either<L, TryOption<B>> fb) =>
            FEither<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEither<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, TryOption<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, TryOption<A>> ma) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> BindT<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<EitherUnsafe<L, B>></returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<EitherUnsafe<L, A>></returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> MapT<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> FilterT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> Where<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> Select<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, TryOption<C>>, EitherUnsafe<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryOption<A>></param>
        /// <returns>EitherUnsafe<L, TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryOption<A>> fa) =>
            FEitherUnsafe<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryOption<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, TryOption<A>></param>
        /// <returns>EitherUnsafe<L, TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryOption<A>> fa, EitherUnsafe<L, TryOption<B>> fb) =>
            FEitherUnsafe<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<TryOption<A>> ma) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOption<B>> BindT< A, B>(this Task<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Task<B>></returns>
        [Pure]
        public static TryOption<Task<B>> Traverse< A, B>(this Task<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Task<A>></returns>
        [Pure]
        public static TryOption<Task<A>> Sequence< A>(this Task<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOption<B>> MapT< A, B>(this Task<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<TryOption<A>> ma, Action<A> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryOption<A>> FilterT< A>(this Task<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryOption<A>> Where< A>(this Task<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOption<B>> Select< A, B>(this Task<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOption<C>> SelectMany< A, B, C>(
            this Task<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MTask<TryOption<C>>, Task<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOption<A>> PlusT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOption<A>> SubtractT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<TryOption<A>> ProductT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<TryOption<A>> DivideT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<TryOption<A>> AppendT<SEMI,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<TryOption<A>></param>
        /// <returns>Task<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryOption<A>> fa) =>
            FTask< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTask< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<TryOption<A>></param>
        /// <param name="fb">Monad of Task<TryOption<A>></param>
        /// <returns>Task<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryOption<A>> fa, Task<TryOption<B>> fb) =>
            FTask< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTask< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<TryOption<A>> ma) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOption<B>> BindT< A, B>(this Try<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Try<B>></returns>
        [Pure]
        public static TryOption<Try<B>> Traverse< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Try<A>></returns>
        [Pure]
        public static TryOption<Try<A>> Sequence< A>(this Try<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOption<B>> MapT< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<TryOption<A>> ma, Action<A> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryOption<A>> FilterT< A>(this Try<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryOption<A>> Where< A>(this Try<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOption<B>> Select< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOption<C>> SelectMany< A, B, C>(
            this Try<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MTry<TryOption<C>>, Try<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOption<A>> PlusT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOption<A>> SubtractT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<TryOption<A>> ProductT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<TryOption<A>> DivideT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<TryOption<A>> AppendT<SEMI,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<TryOption<A>></param>
        /// <returns>Try<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryOption<A>> fa) =>
            FTry< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTry< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<TryOption<A>></param>
        /// <param name="fb">Monad of Try<TryOption<A>></param>
        /// <returns>Try<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryOption<A>> fa, Try<TryOption<B>> fb) =>
            FTry< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTry< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<TryOption<A>> ma) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOption<B>> BindT< A, B>(this TryAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryAsync<B>></returns>
        [Pure]
        public static TryOption<TryAsync<B>> Traverse< A, B>(this TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryAsync<A>></returns>
        [Pure]
        public static TryOption<TryAsync<A>> Sequence< A>(this TryAsync<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOption<B>> MapT< A, B>(this TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryOption<A>> FilterT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryOption<A>> Where< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOption<B>> Select< A, B>(this TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOption<C>> SelectMany< A, B, C>(
            this TryAsync<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MTryAsync<TryOption<C>>, TryAsync<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> PlusT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> SubtractT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> ProductT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> DivideT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> AppendT<SEMI,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryOption<A>></param>
        /// <returns>TryAsync<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryOption<A>> fa) =>
            FTryAsync< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryAsync< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryOption<A>></param>
        /// <param name="fb">Monad of TryAsync<TryOption<A>></param>
        /// <returns>TryAsync<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryOption<A>> fa, TryAsync<TryOption<B>> fb) =>
            FTryAsync< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<TryOption<A>> ma) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOption<B>> BindT< A, B>(this TryOption<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOption<B>></returns>
        [Pure]
        public static TryOption<TryOption<B>> Traverse< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOption<A>></returns>
        [Pure]
        public static TryOption<TryOption<A>> Sequence< A>(this TryOption<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOption<B>> MapT< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryOption<A>> FilterT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryOption<A>> Where< A>(this TryOption<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOption<B>> Select< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOption<C>> SelectMany< A, B, C>(
            this TryOption<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MTryOption<TryOption<C>>, TryOption<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOption<A>> PlusT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOption<A>> SubtractT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<TryOption<A>> ProductT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<TryOption<A>> DivideT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<TryOption<A>> AppendT<SEMI,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<TryOption<A>></param>
        /// <returns>TryOption<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryOption<A>> fa) =>
            FTryOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<TryOption<A>></param>
        /// <param name="fb">Monad of TryOption<TryOption<A>></param>
        /// <returns>TryOption<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryOption<A>> fa, TryOption<TryOption<B>> fb) =>
            FTryOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<TryOption<A>> ma) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> BindT< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOptionAsync<B>></returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOptionAsync<A>></returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> MapT< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> FilterT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> Where< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> Select< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOption<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MTryOptionAsync<TryOption<C>>, TryOptionAsync<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> PlusT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> ProductT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> DivideT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryOption<A>></param>
        /// <returns>TryOptionAsync<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryOption<A>> fa) =>
            FTryOptionAsync< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryOption<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<TryOption<A>></param>
        /// <returns>TryOptionAsync<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryOption<A>> fa, TryOptionAsync<TryOption<B>> fb) =>
            FTryOptionAsync< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<TryOption<A>> ma) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> BindT< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<IEnumerable<B>></returns>
        [Pure]
        public static TryOption<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<IEnumerable<A>></returns>
        [Pure]
        public static TryOption<IEnumerable<A>> Sequence< A>(this IEnumerable<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> MapT< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<TryOption<A>> ma, Action<A> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> FilterT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> Where< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> Select< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOption<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MSeq<TryOption<C>>, IEnumerable<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> PlusT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> SubtractT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> ProductT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> DivideT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> AppendT<SEMI,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryOption<A>></param>
        /// <returns>IEnumerable<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryOption<A>> fa) =>
            FSeq< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSeq< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryOption<A>></param>
        /// <param name="fb">Monad of IEnumerable<TryOption<A>></param>
        /// <returns>IEnumerable<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryOption<A>> fa, IEnumerable<TryOption<B>> fb) =>
            FSeq< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSeq< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<TryOption<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<TryOption<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<TryOption<A>> ma) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOption<B>> BindT< A, B>(this Set<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Set<B>></returns>
        [Pure]
        public static TryOption<Set<B>> Traverse< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<TryOption<A>>, traverses the inner
        /// values of type A, and returns TryOption<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Set<A>></returns>
        [Pure]
        public static TryOption<Set<A>> Sequence< A>(this Set<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOption<B>> MapT< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<TryOption<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<TryOption<A>> ma, Action<A> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryOption<A>> FilterT< A>(this Set<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryOption<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryOption<A>> Where< A>(this Set<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOption<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOption<B>> Select< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOption<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<TryOption<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOption<C>> SelectMany< A, B, C>(
            this Set<TryOption<A>> ma,
            Func<A, TryOption<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                    .Inst.Bind<MSet<TryOption<C>>, Set<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOption<B>).Bind<MTryOption<C>, TryOption<C>, C>(mb, b => default(MTryOption<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOption<A>> PlusT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOption<A>> SubtractT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<TryOption<A>> ProductT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<TryOption<A>> DivideT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<TryOption<A>> AppendT<SEMI,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOption<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<TryOption<A>></param>
        /// <returns>Set<TryOption<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryOption<A>> fa) =>
            FSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => FTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<TryOption<A>></param>
        /// <param name="fb">Monad of Set<TryOption<A>></param>
        /// <returns>Set<TryOption<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryOption<A>> fa, Set<TryOption<B>> fb) =>
            FSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            FTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for TryOptionAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionAsyncT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<TryOptionAsync<A>> ma) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> BindT< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Arr<B>></returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> Traverse< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Arr<A>></returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> Sequence< A>(this Arr<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> MapT< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> FilterT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> Where< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> Select< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Arr<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MArr<TryOptionAsync<C>>, Arr<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> PlusT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> SubtractT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> ProductT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> DivideT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> AppendT<SEMI,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<TryOptionAsync<A>></param>
        /// <returns>Arr<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryOptionAsync<A>> fa) =>
            FArr< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MArr< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Arr<TryOptionAsync<A>></param>
        /// <returns>Arr<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryOptionAsync<A>> fa, Arr<TryOptionAsync<B>> fb) =>
            FArr< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MArr< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<TryOptionAsync<A>> ma) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> BindT< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<HashSet<B>></returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<HashSet<A>></returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> Sequence< A>(this HashSet<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> MapT< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> FilterT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> Where< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> Select< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MHashSet<TryOptionAsync<C>>, HashSet<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> PlusT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> SubtractT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> ProductT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> DivideT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> AppendT<SEMI,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<TryOptionAsync<A>></param>
        /// <returns>HashSet<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryOptionAsync<A>> fa) =>
            FHashSet< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MHashSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of HashSet<TryOptionAsync<A>></param>
        /// <returns>HashSet<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryOptionAsync<A>> fa, HashSet<TryOptionAsync<B>> fb) =>
            FHashSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MHashSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<TryOptionAsync<A>> ma) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> BindT< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Lst<B>></returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> Traverse< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Lst<A>></returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> Sequence< A>(this Lst<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> MapT< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> FilterT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> Where< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> Select< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Lst<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MLst<TryOptionAsync<C>>, Lst<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> PlusT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> SubtractT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> ProductT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> DivideT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> AppendT<SEMI,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<TryOptionAsync<A>></param>
        /// <returns>Lst<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryOptionAsync<A>> fa) =>
            FLst< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MLst< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Lst<TryOptionAsync<A>></param>
        /// <returns>Lst<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryOptionAsync<A>> fa, Lst<TryOptionAsync<B>> fb) =>
            FLst< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MLst< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<TryOptionAsync<A>> ma) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> BindT< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Option<B>></returns>
        [Pure]
        public static TryOptionAsync<Option<B>> Traverse< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Option<A>></returns>
        [Pure]
        public static TryOptionAsync<Option<A>> Sequence< A>(this Option<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> MapT< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> FilterT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> Where< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> Select< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Option<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MOption<TryOptionAsync<C>>, Option<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> PlusT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> SubtractT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> ProductT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> DivideT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> AppendT<SEMI,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<TryOptionAsync<A>></param>
        /// <returns>Option<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryOptionAsync<A>> fa) =>
            FOption< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Option<TryOptionAsync<A>></param>
        /// <returns>Option<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryOptionAsync<A>> fa, Option<TryOptionAsync<B>> fb) =>
            FOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<TryOptionAsync<A>> ma) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> BindT< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<OptionUnsafe<B>></returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<OptionUnsafe<A>></returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> MapT< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> FilterT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> Where< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> Select< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MOptionUnsafe<TryOptionAsync<C>>, OptionUnsafe<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> PlusT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> ProductT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> DivideT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryOptionAsync<A>></param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryOptionAsync<A>> fa) =>
            FOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<TryOptionAsync<A>></param>
        /// <returns>OptionUnsafe<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryOptionAsync<A>> fa, OptionUnsafe<TryOptionAsync<B>> fb) =>
            FOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, TryOptionAsync<A>> ma) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> BindT<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Either<L, B>></returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Either<L, A>></returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> Sequence<L, A>(this Either<L, TryOptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> MapT<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> FilterT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> Where<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> Select<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MEither<L, TryOptionAsync<C>>, Either<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> PlusT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> SubtractT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> ProductT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> DivideT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> AppendT<SEMI, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, TryOptionAsync<A>></param>
        /// <returns>Either<L, TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryOptionAsync<A>> fa) =>
            FEither<L, TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MEither<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Either<L, TryOptionAsync<A>></param>
        /// <returns>Either<L, TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryOptionAsync<A>> fa, Either<L, TryOptionAsync<B>> fb) =>
            FEither<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MEither<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> BindT<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, B>></returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<EitherUnsafe<L, A>></returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> Where<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> Select<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<C>>, EitherUnsafe<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryOptionAsync<A>></param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryOptionAsync<A>> fa) =>
            FEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, TryOptionAsync<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, TryOptionAsync<A>></param>
        /// <returns>EitherUnsafe<L, TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryOptionAsync<A>> fa, EitherUnsafe<L, TryOptionAsync<B>> fb) =>
            FEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<TryOptionAsync<A>> ma) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> BindT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Task<B>></returns>
        [Pure]
        public static TryOptionAsync<Task<B>> Traverse< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Task<A>></returns>
        [Pure]
        public static TryOptionAsync<Task<A>> Sequence< A>(this Task<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> MapT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> FilterT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> Where< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> Select< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Task<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> PlusT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> SubtractT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> ProductT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> DivideT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> AppendT<SEMI,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<TryOptionAsync<A>></param>
        /// <returns>Task<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryOptionAsync<A>> fa) =>
            FTask< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTask< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Task<TryOptionAsync<A>></param>
        /// <returns>Task<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryOptionAsync<A>> fa, Task<TryOptionAsync<B>> fb) =>
            FTask< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTask< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<TryOptionAsync<A>> ma) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> BindT< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Try<B>></returns>
        [Pure]
        public static TryOptionAsync<Try<B>> Traverse< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Try<A>></returns>
        [Pure]
        public static TryOptionAsync<Try<A>> Sequence< A>(this Try<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> MapT< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> FilterT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> Where< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> Select< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Try<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MTry<TryOptionAsync<C>>, Try<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> PlusT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> SubtractT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> ProductT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> DivideT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> AppendT<SEMI,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<TryOptionAsync<A>></param>
        /// <returns>Try<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryOptionAsync<A>> fa) =>
            FTry< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTry< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Try<TryOptionAsync<A>></param>
        /// <returns>Try<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryOptionAsync<A>> fa, Try<TryOptionAsync<B>> fb) =>
            FTry< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTry< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<TryOptionAsync<A>> ma) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> BindT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryAsync<B>></returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryAsync<A>></returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> Sequence< A>(this TryAsync<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> MapT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> FilterT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> Where< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> Select< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> PlusT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> ProductT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> DivideT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryOptionAsync<A>></param>
        /// <returns>TryAsync<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryOptionAsync<A>> fa) =>
            FTryAsync< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of TryAsync<TryOptionAsync<A>></param>
        /// <returns>TryAsync<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryOptionAsync<A>> fa, TryAsync<TryOptionAsync<B>> fb) =>
            FTryAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<TryOptionAsync<A>> ma) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> BindT< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOption<B>></returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOption<A>></returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> Sequence< A>(this TryOption<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> MapT< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> FilterT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> Where< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> Select< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MTryOption<TryOptionAsync<C>>, TryOption<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> PlusT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> ProductT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> DivideT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<TryOptionAsync<A>></param>
        /// <returns>TryOption<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryOptionAsync<A>> fa) =>
            FTryOption< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of TryOption<TryOptionAsync<A>></param>
        /// <returns>TryOption<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryOptionAsync<A>> fa, TryOption<TryOptionAsync<B>> fb) =>
            FTryOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<TryOptionAsync<A>> ma) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> BindT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>></returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>></returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> MapT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> FilterT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> Where< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> Select< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> PlusT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> ProductT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> DivideT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryOptionAsync<A>></param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryOptionAsync<A>> fa) =>
            FTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<TryOptionAsync<A>></param>
        /// <returns>TryOptionAsync<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryOptionAsync<A>> fa, TryOptionAsync<TryOptionAsync<B>> fb) =>
            FTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<TryOptionAsync<A>> ma) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> BindT< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<IEnumerable<B>></returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<IEnumerable<A>></returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> Sequence< A>(this IEnumerable<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> MapT< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> FilterT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> Where< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> Select< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MSeq<TryOptionAsync<C>>, IEnumerable<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> PlusT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> SubtractT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> ProductT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> DivideT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> AppendT<SEMI,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryOptionAsync<A>></param>
        /// <returns>IEnumerable<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryOptionAsync<A>> fa) =>
            FSeq< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MSeq< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of IEnumerable<TryOptionAsync<A>></param>
        /// <returns>IEnumerable<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryOptionAsync<A>> fa, IEnumerable<TryOptionAsync<B>> fb) =>
            FSeq< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MSeq< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<TryOptionAsync<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<TryOptionAsync<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<TryOptionAsync<A>> ma) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> BindT< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Set<B>></returns>
        [Pure]
        public static TryOptionAsync<Set<B>> Traverse< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<TryOptionAsync<A>>, traverses the inner
        /// values of type A, and returns TryOptionAsync<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Set<A>></returns>
        [Pure]
        public static TryOptionAsync<Set<A>> Sequence< A>(this Set<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> MapT< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<TryOptionAsync<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> FilterT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<TryOptionAsync<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> Where< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOptionAsync<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> Select< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<TryOptionAsync<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<TryOptionAsync<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Set<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                    .Inst.Bind<MSet<TryOptionAsync<C>>, Set<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MTryOptionAsync<B>).Bind<MTryOptionAsync<C>, TryOptionAsync<C>, C>(mb, b => default(MTryOptionAsync<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> PlusT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> SubtractT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> ProductT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> DivideT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> AppendT<SEMI,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<TryOptionAsync<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<TryOptionAsync<A>></param>
        /// <returns>Set<TryOptionAsync<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryOptionAsync<A>> fa) =>
            FSet< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => FTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<TryOptionAsync<A>></param>
        /// <param name="fb">Monad of Set<TryOptionAsync<A>></param>
        /// <returns>Set<TryOptionAsync<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryOptionAsync<A>> fa, Set<TryOptionAsync<B>> fb) =>
            FSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            FTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for IEnumerable, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class IEnumerableT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<IEnumerable<A>> ma) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<IEnumerable<B>> BindT< A, B>(this Arr<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Arr<B>></returns>
        [Pure]
        public static IEnumerable<Arr<B>> Traverse< A, B>(this Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Arr<A>></returns>
        [Pure]
        public static IEnumerable<Arr<A>> Sequence< A>(this Arr<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<IEnumerable<B>> MapT< A, B>(this Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<IEnumerable<A>> FilterT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<IEnumerable<A>> Where< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<IEnumerable<B>> Select< A, B>(this Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<IEnumerable<C>> SelectMany< A, B, C>(
            this Arr<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MArr<IEnumerable<C>>, Arr<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> PlusT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> SubtractT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> ProductT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> DivideT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> AppendT<SEMI,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<IEnumerable<A>></param>
        /// <returns>Arr<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<IEnumerable<A>> fa) =>
            FArr< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MArr< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<IEnumerable<A>></param>
        /// <param name="fb">Monad of Arr<IEnumerable<A>></param>
        /// <returns>Arr<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<IEnumerable<A>> fa, Arr<IEnumerable<B>> fb) =>
            FArr< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MArr< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<IEnumerable<A>> ma) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> BindT< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<HashSet<B>></returns>
        [Pure]
        public static IEnumerable<HashSet<B>> Traverse< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<HashSet<A>></returns>
        [Pure]
        public static IEnumerable<HashSet<A>> Sequence< A>(this HashSet<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> MapT< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> FilterT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> Where< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> Select< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<IEnumerable<C>> SelectMany< A, B, C>(
            this HashSet<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MHashSet<IEnumerable<C>>, HashSet<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> PlusT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> SubtractT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> ProductT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> DivideT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> AppendT<SEMI,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<IEnumerable<A>></param>
        /// <returns>HashSet<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<IEnumerable<A>> fa) =>
            FHashSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MHashSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<IEnumerable<A>></param>
        /// <param name="fb">Monad of HashSet<IEnumerable<A>></param>
        /// <returns>HashSet<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<IEnumerable<A>> fa, HashSet<IEnumerable<B>> fb) =>
            FHashSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MHashSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<IEnumerable<A>> ma) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<IEnumerable<B>> BindT< A, B>(this Lst<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Lst<B>></returns>
        [Pure]
        public static IEnumerable<Lst<B>> Traverse< A, B>(this Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Lst<A>></returns>
        [Pure]
        public static IEnumerable<Lst<A>> Sequence< A>(this Lst<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<IEnumerable<B>> MapT< A, B>(this Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<IEnumerable<A>> FilterT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<IEnumerable<A>> Where< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<IEnumerable<B>> Select< A, B>(this Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<IEnumerable<C>> SelectMany< A, B, C>(
            this Lst<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MLst<IEnumerable<C>>, Lst<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> PlusT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> SubtractT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> ProductT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> DivideT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> AppendT<SEMI,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<IEnumerable<A>></param>
        /// <returns>Lst<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<IEnumerable<A>> fa) =>
            FLst< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MLst< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<IEnumerable<A>></param>
        /// <param name="fb">Monad of Lst<IEnumerable<A>></param>
        /// <returns>Lst<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<IEnumerable<A>> fa, Lst<IEnumerable<B>> fb) =>
            FLst< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MLst< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<IEnumerable<A>> ma) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<IEnumerable<B>> BindT< A, B>(this Option<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Option<B>></returns>
        [Pure]
        public static IEnumerable<Option<B>> Traverse< A, B>(this Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Option<A>></returns>
        [Pure]
        public static IEnumerable<Option<A>> Sequence< A>(this Option<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<IEnumerable<B>> MapT< A, B>(this Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<IEnumerable<A>> FilterT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<IEnumerable<A>> Where< A>(this Option<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<IEnumerable<B>> Select< A, B>(this Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<IEnumerable<C>> SelectMany< A, B, C>(
            this Option<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MOption<IEnumerable<C>>, Option<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<IEnumerable<A>> PlusT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<IEnumerable<A>> SubtractT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<IEnumerable<A>> ProductT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<IEnumerable<A>> DivideT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<IEnumerable<A>> AppendT<SEMI,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<IEnumerable<A>></param>
        /// <returns>Option<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Option<IEnumerable<A>> fa) =>
            FOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<IEnumerable<A>></param>
        /// <param name="fb">Monad of Option<IEnumerable<A>></param>
        /// <returns>Option<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<IEnumerable<A>> fa, Option<IEnumerable<B>> fb) =>
            FOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<IEnumerable<A>> ma) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> BindT< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<OptionUnsafe<B>></returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<OptionUnsafe<A>></returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> MapT< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> FilterT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> Where< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> Select< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<C>> SelectMany< A, B, C>(
            this OptionUnsafe<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MOptionUnsafe<IEnumerable<C>>, OptionUnsafe<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> PlusT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> SubtractT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> ProductT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> DivideT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> AppendT<SEMI,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<IEnumerable<A>></param>
        /// <returns>OptionUnsafe<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<IEnumerable<A>> fa) =>
            FOptionUnsafe< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOptionUnsafe< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<IEnumerable<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<IEnumerable<A>></param>
        /// <returns>OptionUnsafe<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<IEnumerable<A>> fa, OptionUnsafe<IEnumerable<B>> fb) =>
            FOptionUnsafe< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOptionUnsafe< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, IEnumerable<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, IEnumerable<A>> ma) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> BindT<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Either<L, B>></returns>
        [Pure]
        public static IEnumerable<Either<L, B>> Traverse<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Either<L, A>></returns>
        [Pure]
        public static IEnumerable<Either<L, A>> Sequence<L, A>(this Either<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> MapT<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> FilterT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> Where<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> Select<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, IEnumerable<C>> SelectMany<L, A, B, C>(
            this Either<L, IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MEither<L, IEnumerable<C>>, Either<L, IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> PlusT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> SubtractT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> ProductT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> DivideT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> AppendT<SEMI, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, IEnumerable<A>></param>
        /// <returns>Either<L, IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, IEnumerable<A>> fa) =>
            FEither<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEither<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, IEnumerable<A>></param>
        /// <param name="fb">Monad of Either<L, IEnumerable<A>></param>
        /// <returns>Either<L, IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, IEnumerable<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, IEnumerable<A>> fa, Either<L, IEnumerable<B>> fb) =>
            FEither<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEither<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, IEnumerable<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> BindT<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<EitherUnsafe<L, B>></returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<EitherUnsafe<L, A>></returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> MapT<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> FilterT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> Where<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> Select<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, IEnumerable<C>>, EitherUnsafe<L, IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, IEnumerable<A>></param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, IEnumerable<A>> fa) =>
            FEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, IEnumerable<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, IEnumerable<A>></param>
        /// <returns>EitherUnsafe<L, IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, IEnumerable<A>> fa, EitherUnsafe<L, IEnumerable<B>> fb) =>
            FEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<IEnumerable<A>> ma) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<IEnumerable<B>> BindT< A, B>(this Task<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Task<B>></returns>
        [Pure]
        public static IEnumerable<Task<B>> Traverse< A, B>(this Task<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Task<A>></returns>
        [Pure]
        public static IEnumerable<Task<A>> Sequence< A>(this Task<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<IEnumerable<B>> MapT< A, B>(this Task<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<IEnumerable<A>> FilterT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<IEnumerable<A>> Where< A>(this Task<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<IEnumerable<B>> Select< A, B>(this Task<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<IEnumerable<C>> SelectMany< A, B, C>(
            this Task<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MTask<IEnumerable<C>>, Task<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<IEnumerable<A>> PlusT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<IEnumerable<A>> SubtractT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<IEnumerable<A>> ProductT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<IEnumerable<A>> DivideT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<IEnumerable<A>> AppendT<SEMI,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<IEnumerable<A>></param>
        /// <returns>Task<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Task<IEnumerable<A>> fa) =>
            FTask< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTask< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<IEnumerable<A>></param>
        /// <param name="fb">Monad of Task<IEnumerable<A>></param>
        /// <returns>Task<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<IEnumerable<A>> fa, Task<IEnumerable<B>> fb) =>
            FTask< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTask< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<IEnumerable<A>> ma) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<IEnumerable<B>> BindT< A, B>(this Try<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Try<B>></returns>
        [Pure]
        public static IEnumerable<Try<B>> Traverse< A, B>(this Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Try<A>></returns>
        [Pure]
        public static IEnumerable<Try<A>> Sequence< A>(this Try<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<IEnumerable<B>> MapT< A, B>(this Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<IEnumerable<A>> FilterT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<IEnumerable<A>> Where< A>(this Try<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<IEnumerable<B>> Select< A, B>(this Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<IEnumerable<C>> SelectMany< A, B, C>(
            this Try<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MTry<IEnumerable<C>>, Try<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<IEnumerable<A>> PlusT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<IEnumerable<A>> SubtractT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<IEnumerable<A>> ProductT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<IEnumerable<A>> DivideT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<IEnumerable<A>> AppendT<SEMI,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<IEnumerable<A>></param>
        /// <returns>Try<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Try<IEnumerable<A>> fa) =>
            FTry< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTry< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<IEnumerable<A>></param>
        /// <param name="fb">Monad of Try<IEnumerable<A>></param>
        /// <returns>Try<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<IEnumerable<A>> fa, Try<IEnumerable<B>> fb) =>
            FTry< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTry< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<IEnumerable<A>> ma) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> BindT< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryAsync<B>></returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> Traverse< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryAsync<A>></returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> Sequence< A>(this TryAsync<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> MapT< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> FilterT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> Where< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> Select< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<IEnumerable<C>> SelectMany< A, B, C>(
            this TryAsync<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MTryAsync<IEnumerable<C>>, TryAsync<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> PlusT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> SubtractT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> ProductT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> DivideT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> AppendT<SEMI,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<IEnumerable<A>></param>
        /// <returns>TryAsync<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<IEnumerable<A>> fa) =>
            FTryAsync< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryAsync< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<IEnumerable<A>></param>
        /// <param name="fb">Monad of TryAsync<IEnumerable<A>></param>
        /// <returns>TryAsync<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<IEnumerable<A>> fa, TryAsync<IEnumerable<B>> fb) =>
            FTryAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<IEnumerable<A>> ma) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> BindT< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOption<B>></returns>
        [Pure]
        public static IEnumerable<TryOption<B>> Traverse< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOption<A>></returns>
        [Pure]
        public static IEnumerable<TryOption<A>> Sequence< A>(this TryOption<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> MapT< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> FilterT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> Where< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> Select< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<IEnumerable<C>> SelectMany< A, B, C>(
            this TryOption<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MTryOption<IEnumerable<C>>, TryOption<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> PlusT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> SubtractT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> ProductT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> DivideT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> AppendT<SEMI,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<IEnumerable<A>></param>
        /// <returns>TryOption<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<IEnumerable<A>> fa) =>
            FTryOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<IEnumerable<A>></param>
        /// <param name="fb">Monad of TryOption<IEnumerable<A>></param>
        /// <returns>TryOption<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<IEnumerable<A>> fa, TryOption<IEnumerable<B>> fb) =>
            FTryOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<IEnumerable<A>> ma) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> BindT< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOptionAsync<B>></returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<TryOptionAsync<A>></returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> MapT< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> FilterT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> Where< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> Select< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<C>> SelectMany< A, B, C>(
            this TryOptionAsync<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MTryOptionAsync<IEnumerable<C>>, TryOptionAsync<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> PlusT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> SubtractT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> ProductT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> DivideT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> AppendT<SEMI,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<IEnumerable<A>></param>
        /// <returns>TryOptionAsync<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<IEnumerable<A>> fa) =>
            FTryOptionAsync< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryOptionAsync< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<IEnumerable<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<IEnumerable<A>></param>
        /// <returns>TryOptionAsync<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<IEnumerable<A>> fa, TryOptionAsync<IEnumerable<B>> fb) =>
            FTryOptionAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryOptionAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<IEnumerable<A>> ma) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> BindT< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<IEnumerable<B>></returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> Traverse< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<IEnumerable<A>></returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> Sequence< A>(this IEnumerable<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> MapT< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> FilterT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> Where< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> Select< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<IEnumerable<C>> SelectMany< A, B, C>(
            this IEnumerable<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MSeq<IEnumerable<C>>, IEnumerable<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> PlusT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> SubtractT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> ProductT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> DivideT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> AppendT<SEMI,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<IEnumerable<A>></param>
        /// <returns>IEnumerable<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<IEnumerable<A>> fa) =>
            FSeq< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSeq< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<IEnumerable<A>></param>
        /// <param name="fb">Monad of IEnumerable<IEnumerable<A>></param>
        /// <returns>IEnumerable<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<IEnumerable<A>> fa, IEnumerable<IEnumerable<B>> fb) =>
            FSeq< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSeq< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<IEnumerable<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<IEnumerable<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<IEnumerable<A>> ma) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<IEnumerable<B>> BindT< A, B>(this Set<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Set<B>></returns>
        [Pure]
        public static IEnumerable<Set<B>> Traverse< A, B>(this Set<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<IEnumerable<A>>, traverses the inner
        /// values of type A, and returns IEnumerable<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Set<A>></returns>
        [Pure]
        public static IEnumerable<Set<A>> Sequence< A>(this Set<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<IEnumerable<B>> MapT< A, B>(this Set<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<IEnumerable<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<IEnumerable<A>> FilterT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<IEnumerable<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<IEnumerable<A>> Where< A>(this Set<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<IEnumerable<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<IEnumerable<B>> Select< A, B>(this Set<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<IEnumerable<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<IEnumerable<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<IEnumerable<C>> SelectMany< A, B, C>(
            this Set<IEnumerable<A>> ma,
            Func<A, IEnumerable<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                    .Inst.Bind<MSet<IEnumerable<C>>, Set<IEnumerable<C>>, MSeq<C>, IEnumerable<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSeq<B>).Bind<MSeq<C>, IEnumerable<C>, C>(mb, b => default(MSeq<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<IEnumerable<A>> PlusT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<IEnumerable<A>> SubtractT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<IEnumerable<A>> ProductT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<IEnumerable<A>> DivideT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<IEnumerable<A>> AppendT<SEMI,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<IEnumerable<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<IEnumerable<A>></param>
        /// <returns>Set<IEnumerable<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Set<IEnumerable<A>> fa) =>
            FSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => FSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<IEnumerable<A>></param>
        /// <param name="fb">Monad of Set<IEnumerable<A>></param>
        /// <returns>Set<IEnumerable<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<IEnumerable<A>> fa, Set<IEnumerable<B>> fb) =>
            FSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            FSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Set, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class SetT_Extensions
    {
        /// <summary>
        /// Finds total of all the Num<A>s in Arr<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Arr<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Arr<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Arr<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Arr<Set<A>> ma) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Arr<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Set<B>> BindT< A, B>(this Arr<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Arr<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Arr<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Arr<B>></returns>
        [Pure]
        public static Set<Arr<B>> Traverse< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Arr<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Arr<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Arr<A>></returns>
        [Pure]
        public static Set<Arr<A>> Sequence< A>(this Arr<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Set<B>> MapT< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Set<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Set<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Arr<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Set<A>> ma, Action<A> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Set<A>> FilterT< A>(this Arr<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Arr<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Arr<Set<A>> Where< A>(this Arr<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Arr<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Arr<Set<B>> Select< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Arr<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Arr<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Set<C>> SelectMany< A, B, C>(
            this Arr<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MArr<Set<C>>, Arr<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Set<A>> PlusT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Set<A>> SubtractT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Arr<Set<A>> ProductT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Arr<Set<A>> DivideT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Arr<Set<A>> AppendT<SEMI,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Arr<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Arr<Set<A>></param>
        /// <returns>Arr<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Arr<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Set<A>> fa) =>
            FArr< Set<A>, Set<B>>.Inst.Apply(
                 MArr< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Arr<Set<A>></param>
        /// <param name="fb">Monad of Arr<Set<A>></param>
        /// <returns>Arr<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Arr<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Set<A>> fa, Arr<Set<B>> fb) =>
            FArr< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MArr< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in HashSet<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in HashSet<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the HashSet<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in HashSet<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this HashSet<Set<A>> ma) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>HashSet<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Set<B>> BindT< A, B>(this HashSet<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type HashSet<Set<A>>, traverses the inner
        /// values of type A, and returns Set<HashSet<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<HashSet<B>></returns>
        [Pure]
        public static Set<HashSet<B>> Traverse< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type HashSet<Set<A>>, traverses the inner
        /// values of type A, and returns Set<HashSet<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<HashSet<A>></returns>
        [Pure]
        public static Set<HashSet<A>> Sequence< A>(this HashSet<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Set<B>> MapT< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Set<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Set<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in HashSet<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Set<A>> ma, Action<A> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Set<A>> FilterT< A>(this HashSet<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>HashSet<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static HashSet<Set<A>> Where< A>(this HashSet<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>HashSet<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static HashSet<Set<B>> Select< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The HashSet<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>HashSet<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Set<C>> SelectMany< A, B, C>(
            this HashSet<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MHashSet<Set<C>>, HashSet<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Set<A>> PlusT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Set<A>> SubtractT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static HashSet<Set<A>> ProductT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static HashSet<Set<A>> DivideT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static HashSet<Set<A>> AppendT<SEMI,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>HashSet<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of HashSet<Set<A>></param>
        /// <returns>HashSet<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static HashSet<Set<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Set<A>> fa) =>
            FHashSet< Set<A>, Set<B>>.Inst.Apply(
                 MHashSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of HashSet<Set<A>></param>
        /// <param name="fb">Monad of HashSet<Set<A>></param>
        /// <returns>HashSet<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static HashSet<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Set<A>> fa, HashSet<Set<B>> fb) =>
            FHashSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MHashSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Lst<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Lst<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Lst<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Lst<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Lst<Set<A>> ma) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Lst<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Set<B>> BindT< A, B>(this Lst<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Lst<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Lst<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Lst<B>></returns>
        [Pure]
        public static Set<Lst<B>> Traverse< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Lst<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Lst<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Lst<A>></returns>
        [Pure]
        public static Set<Lst<A>> Sequence< A>(this Lst<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Set<B>> MapT< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Set<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Set<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Lst<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Set<A>> ma, Action<A> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Set<A>> FilterT< A>(this Lst<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Lst<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Lst<Set<A>> Where< A>(this Lst<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Lst<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Lst<Set<B>> Select< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Lst<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Lst<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Set<C>> SelectMany< A, B, C>(
            this Lst<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MLst<Set<C>>, Lst<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Set<A>> PlusT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Set<A>> SubtractT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Lst<Set<A>> ProductT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Lst<Set<A>> DivideT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Lst<Set<A>> AppendT<SEMI,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Lst<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Lst<Set<A>></param>
        /// <returns>Lst<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Lst<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Set<A>> fa) =>
            FLst< Set<A>, Set<B>>.Inst.Apply(
                 MLst< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Lst<Set<A>></param>
        /// <param name="fb">Monad of Lst<Set<A>></param>
        /// <returns>Lst<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Lst<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Set<A>> fa, Lst<Set<B>> fb) =>
            FLst< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MLst< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Option<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Option<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Option<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Option<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Option<Set<A>> ma) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Option<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Set<B>> BindT< A, B>(this Option<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Option<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Option<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Option<B>></returns>
        [Pure]
        public static Set<Option<B>> Traverse< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Option<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Option<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Option<A>></returns>
        [Pure]
        public static Set<Option<A>> Sequence< A>(this Option<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Set<B>> MapT< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Option<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Set<A>> ma, Action<A> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Set<A>> FilterT< A>(this Option<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Option<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Option<Set<A>> Where< A>(this Option<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Option<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Option<Set<B>> Select< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Option<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Option<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Set<C>> SelectMany< A, B, C>(
            this Option<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MOption<Set<C>>, Option<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Option<Set<A>> PlusT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Option<Set<A>> SubtractT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Option<Set<A>> ProductT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Option<Set<A>> DivideT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Option<Set<A>> AppendT<SEMI,  A>(this Option<Set<A>> x, Option<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Set<A>> x, Option<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Option<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Set<A>> x, Option<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Option<Set<A>></param>
        /// <returns>Option<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Option<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Set<A>> fa) =>
            FOption< Set<A>, Set<B>>.Inst.Apply(
                 MOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Option<Set<A>></param>
        /// <param name="fb">Monad of Option<Set<A>></param>
        /// <returns>Option<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Option<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Set<A>> fa, Option<Set<B>> fb) =>
            FOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in OptionUnsafe<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in OptionUnsafe<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the OptionUnsafe<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in OptionUnsafe<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Set<A>> ma) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>OptionUnsafe<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> BindT< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type OptionUnsafe<Set<A>>, traverses the inner
        /// values of type A, and returns Set<OptionUnsafe<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<OptionUnsafe<B>></returns>
        [Pure]
        public static Set<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type OptionUnsafe<Set<A>>, traverses the inner
        /// values of type A, and returns Set<OptionUnsafe<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<OptionUnsafe<A>></returns>
        [Pure]
        public static Set<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> MapT< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in OptionUnsafe<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Set<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> FilterT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>OptionUnsafe<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> Where< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>OptionUnsafe<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> Select< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The OptionUnsafe<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>OptionUnsafe<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Set<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MOptionUnsafe<Set<C>>, OptionUnsafe<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> PlusT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> SubtractT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> ProductT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> DivideT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> AppendT<SEMI,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>OptionUnsafe<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Set<A>></param>
        /// <returns>OptionUnsafe<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Set<A>> fa) =>
            FOptionUnsafe< Set<A>, Set<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of OptionUnsafe<Set<A>></param>
        /// <param name="fb">Monad of OptionUnsafe<Set<A>></param>
        /// <returns>OptionUnsafe<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static OptionUnsafe<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Set<A>> fa, OptionUnsafe<Set<B>> fb) =>
            FOptionUnsafe< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOptionUnsafe< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Either<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Either<L, Set<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Either<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Either<L, Set<A>></returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Set<A>> ma) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Either<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Set<B>> BindT<L, A, B>(this Either<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Either<L, Set<A>>, traverses the inner
        /// values of type A, and returns Set<Either<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Either<L, B>></returns>
        [Pure]
        public static Set<Either<L, B>> Traverse<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Either<L, Set<A>>, traverses the inner
        /// values of type A, and returns Set<Either<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Either<L, A>></returns>
        [Pure]
        public static Set<Either<L, A>> Sequence<L, A>(this Either<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Set<B>> MapT<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Either<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Set<A>> ma, Action<A> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Set<A>> FilterT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Either<L, Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Either<L, Set<A>> Where<L, A>(this Either<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Either<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Either<L, Set<B>> Select<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Either<L, Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Either<L, Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Set<C>> SelectMany<L, A, B, C>(
            this Either<L, Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MEither<L, Set<C>>, Either<L, Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Set<A>> PlusT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Set<A>> SubtractT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Either<L, Set<A>> ProductT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Either<L, Set<A>> DivideT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Either<L, Set<A>> AppendT<SEMI, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Either<L, Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Either<L, Set<A>></param>
        /// <returns>Either<L, Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Either<L, Set<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Set<A>> fa) =>
            FEither<L, Set<A>, Set<B>>.Inst.Apply(
                 MEither<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Either<L, Set<A>></param>
        /// <param name="fb">Monad of Either<L, Set<A>></param>
        /// <returns>Either<L, Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Either<L, Set<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Set<A>> fa, Either<L, Set<B>> fb) =>
            FEither<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEither<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in EitherUnsafe<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in EitherUnsafe<L, Set<A>></returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the EitherUnsafe<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in EitherUnsafe<L, Set<A>></returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Set<A>> ma) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>EitherUnsafe<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> BindT<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type EitherUnsafe<L, Set<A>>, traverses the inner
        /// values of type A, and returns Set<EitherUnsafe<L, B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<EitherUnsafe<L, B>></returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type EitherUnsafe<L, Set<A>>, traverses the inner
        /// values of type A, and returns Set<EitherUnsafe<L, A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse<L, A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<EitherUnsafe<L, A>></returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> MapT<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in EitherUnsafe<L, Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Set<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> FilterT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>EitherUnsafe<L, Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> Where<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>EitherUnsafe<L, Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> Select<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The EitherUnsafe<L, Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>EitherUnsafe<L, Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Set<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MEitherUnsafe<L, Set<C>>, EitherUnsafe<L, Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>EitherUnsafe<L, Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Set<A>></param>
        /// <returns>EitherUnsafe<L, Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Set<A>> fa) =>
            FEitherUnsafe<L, Set<A>, Set<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of EitherUnsafe<L, Set<A>></param>
        /// <param name="fb">Monad of EitherUnsafe<L, Set<A>></param>
        /// <returns>EitherUnsafe<L, Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static EitherUnsafe<L, Set<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Set<A>> fa, EitherUnsafe<L, Set<B>> fb) =>
            FEitherUnsafe<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Task<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Task<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Task<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Task<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Task<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Task<Set<A>> ma) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Task<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Set<B>> BindT< A, B>(this Task<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Task<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Task<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Task<B>></returns>
        [Pure]
        public static Set<Task<B>> Traverse< A, B>(this Task<Set<A>> ma, Func<A, B> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Task<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Task<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Task<A>></returns>
        [Pure]
        public static Set<Task<A>> Sequence< A>(this Task<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Set<B>> MapT< A, B>(this Task<Set<A>> ma, Func<A, B> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Task<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Task<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Task<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Task<Set<A>> ma, Action<A> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Set<A>> FilterT< A>(this Task<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Task<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Task<Set<A>> Where< A>(this Task<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Task<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Task<Set<B>> Select< A, B>(this Task<Set<A>> ma, Func<A, B> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Task<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Task<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Set<C>> SelectMany< A, B, C>(
            this Task<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MTask<Set<C>>, Task<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Task<Set<A>> PlusT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Task<Set<A>> SubtractT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Task<Set<A>> ProductT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Task<Set<A>> DivideT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Task<Set<A>> AppendT<SEMI,  A>(this Task<Set<A>> x, Task<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Task<Set<A>> x, Task<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Task<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Task<Set<A>> x, Task<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Task<Set<A>></param>
        /// <returns>Task<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Task<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Set<A>> fa) =>
            FTask< Set<A>, Set<B>>.Inst.Apply(
                 MTask< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Task<Set<A>></param>
        /// <param name="fb">Monad of Task<Set<A>></param>
        /// <returns>Task<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Task<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Set<A>> fa, Task<Set<B>> fb) =>
            FTask< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTask< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Try<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Try<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Try<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Try<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Try<Set<A>> ma) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Try<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Set<B>> BindT< A, B>(this Try<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Try<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Try<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Try<B>></returns>
        [Pure]
        public static Set<Try<B>> Traverse< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Try<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Try<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Try<A>></returns>
        [Pure]
        public static Set<Try<A>> Sequence< A>(this Try<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Set<B>> MapT< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Try<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Set<A>> ma, Action<A> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Set<A>> FilterT< A>(this Try<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Try<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Try<Set<A>> Where< A>(this Try<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Try<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Try<Set<B>> Select< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Try<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Try<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Set<C>> SelectMany< A, B, C>(
            this Try<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MTry<Set<C>>, Try<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Try<Set<A>> PlusT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Try<Set<A>> SubtractT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Try<Set<A>> ProductT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Try<Set<A>> DivideT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Try<Set<A>> AppendT<SEMI,  A>(this Try<Set<A>> x, Try<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Set<A>> x, Try<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Try<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Set<A>> x, Try<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Try<Set<A>></param>
        /// <returns>Try<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Try<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Set<A>> fa) =>
            FTry< Set<A>, Set<B>>.Inst.Apply(
                 MTry< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Try<Set<A>></param>
        /// <param name="fb">Monad of Try<Set<A>></param>
        /// <returns>Try<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Try<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Set<A>> fa, Try<Set<B>> fb) =>
            FTry< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTry< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryAsync<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryAsync<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this TryAsync<Set<A>> ma) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Set<B>> BindT< A, B>(this TryAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryAsync<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryAsync<B>></returns>
        [Pure]
        public static Set<TryAsync<B>> Traverse< A, B>(this TryAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryAsync<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryAsync<A>></returns>
        [Pure]
        public static Set<TryAsync<A>> Sequence< A>(this TryAsync<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Set<B>> MapT< A, B>(this TryAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryAsync<Set<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Set<A>> FilterT< A>(this TryAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryAsync<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryAsync<Set<A>> Where< A>(this TryAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryAsync<Set<B>> Select< A, B>(this TryAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryAsync<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryAsync<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Set<C>> SelectMany< A, B, C>(
            this TryAsync<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MTryAsync<Set<C>>, TryAsync<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Set<A>> PlusT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Set<A>> SubtractT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryAsync<Set<A>> ProductT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryAsync<Set<A>> DivideT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryAsync<Set<A>> AppendT<SEMI,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryAsync<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryAsync<Set<A>></param>
        /// <returns>TryAsync<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryAsync<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Set<A>> fa) =>
            FTryAsync< Set<A>, Set<B>>.Inst.Apply(
                 MTryAsync< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryAsync<Set<A>></param>
        /// <param name="fb">Monad of TryAsync<Set<A>></param>
        /// <returns>TryAsync<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryAsync<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Set<A>> fa, TryAsync<Set<B>> fb) =>
            FTryAsync< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOption<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOption<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOption<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOption<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOption<Set<A>> ma) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOption<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Set<B>> BindT< A, B>(this TryOption<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOption<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryOption<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOption<B>></returns>
        [Pure]
        public static Set<TryOption<B>> Traverse< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOption<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryOption<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOption<A>></returns>
        [Pure]
        public static Set<TryOption<A>> Sequence< A>(this TryOption<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Set<B>> MapT< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOption<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Set<A>> ma, Action<A> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Set<A>> FilterT< A>(this TryOption<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOption<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOption<Set<A>> Where< A>(this TryOption<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOption<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOption<Set<B>> Select< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOption<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOption<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Set<C>> SelectMany< A, B, C>(
            this TryOption<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MTryOption<Set<C>>, TryOption<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Set<A>> PlusT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Set<A>> SubtractT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOption<Set<A>> ProductT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOption<Set<A>> DivideT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOption<Set<A>> AppendT<SEMI,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOption<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOption<Set<A>></param>
        /// <returns>TryOption<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOption<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Set<A>> fa) =>
            FTryOption< Set<A>, Set<B>>.Inst.Apply(
                 MTryOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOption<Set<A>></param>
        /// <param name="fb">Monad of TryOption<Set<A>></param>
        /// <returns>TryOption<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOption<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Set<A>> fa, TryOption<Set<B>> fb) =>
            FTryOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in TryOptionAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in TryOptionAsync<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOptionAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the TryOptionAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in TryOptionAsync<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this TryOptionAsync<Set<A>> ma) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>TryOptionAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> BindT< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type TryOptionAsync<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryOptionAsync<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOptionAsync<B>></returns>
        [Pure]
        public static Set<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type TryOptionAsync<Set<A>>, traverses the inner
        /// values of type A, and returns Set<TryOptionAsync<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<TryOptionAsync<A>></returns>
        [Pure]
        public static Set<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> MapT< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in TryOptionAsync<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOptionAsync<Set<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> FilterT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>TryOptionAsync<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> Where< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>TryOptionAsync<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> Select< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The TryOptionAsync<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>TryOptionAsync<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Set<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MTryOptionAsync<Set<C>>, TryOptionAsync<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> PlusT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> SubtractT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> ProductT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> DivideT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> AppendT<SEMI,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>TryOptionAsync<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Set<A>></param>
        /// <returns>TryOptionAsync<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Set<A>> fa) =>
            FTryOptionAsync< Set<A>, Set<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of TryOptionAsync<Set<A>></param>
        /// <param name="fb">Monad of TryOptionAsync<Set<A>></param>
        /// <returns>TryOptionAsync<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static TryOptionAsync<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Set<A>> fa, TryOptionAsync<Set<B>> fb) =>
            FTryOptionAsync< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryOptionAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in IEnumerable<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in IEnumerable<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the IEnumerable<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in IEnumerable<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Set<A>> ma) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>IEnumerable<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Set<B>> BindT< A, B>(this IEnumerable<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type IEnumerable<Set<A>>, traverses the inner
        /// values of type A, and returns Set<IEnumerable<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<IEnumerable<B>></returns>
        [Pure]
        public static Set<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type IEnumerable<Set<A>>, traverses the inner
        /// values of type A, and returns Set<IEnumerable<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<IEnumerable<A>></returns>
        [Pure]
        public static Set<IEnumerable<A>> Sequence< A>(this IEnumerable<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Set<B>> MapT< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in IEnumerable<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Set<A>> ma, Action<A> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Set<A>> FilterT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>IEnumerable<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static IEnumerable<Set<A>> Where< A>(this IEnumerable<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>IEnumerable<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static IEnumerable<Set<B>> Select< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The IEnumerable<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>IEnumerable<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Set<C>> SelectMany< A, B, C>(
            this IEnumerable<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MSeq<Set<C>>, IEnumerable<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Set<A>> PlusT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Set<A>> SubtractT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static IEnumerable<Set<A>> ProductT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static IEnumerable<Set<A>> DivideT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static IEnumerable<Set<A>> AppendT<SEMI,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>IEnumerable<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Set<A>></param>
        /// <returns>IEnumerable<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static IEnumerable<Set<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Set<A>> fa) =>
            FSeq< Set<A>, Set<B>>.Inst.Apply(
                 MSeq< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of IEnumerable<Set<A>></param>
        /// <param name="fb">Monad of IEnumerable<Set<A>></param>
        /// <returns>IEnumerable<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static IEnumerable<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Set<A>> fa, IEnumerable<Set<B>> fb) =>
            FSeq< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSeq< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the Num<A>s in Set<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the sum operation on</param>
        /// <returns>Total of all Num<A>s in Set<Set<A>></returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the Set<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the count operation on</param>
        /// <returns>Number of As in Set<Set<A>></returns>
        [Pure]
        public static int CountT< A>(this Set<Set<A>> ma) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>Set<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Set<B>> BindT< A, B>(this Set<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Tarverse operation.  Takes a value of type Set<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Set<B>> (by applying a to f).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Set<B>></returns>
        [Pure]
        public static Set<Set<B>> Traverse< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type Set<Set<A>>, traverses the inner
        /// values of type A, and returns Set<Set<A>>.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling ma.Traverse< A, A>(identity).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Set<A>></returns>
        [Pure]
        public static Set<Set<A>> Sequence< A>(this Set<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Set<B>> MapT< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to f to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to Fold) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to f to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate f.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in Set<Set<A>>
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Set<A>> ma, Action<A> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Set<A>> FilterT< A>(this Set<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate f. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>Set<Set<A>> with the predicate f(a) applied</returns>
        [Pure]
        public static Set<Set<A>> Where< A>(this Set<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function f.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>Set<Set<B>> which is the result of performing f(a)</returns>
        [Pure]
        public static Set<Set<B>> Select< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The Set<Set<A>> to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>Set<Set<C>> which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Set<C>> SelectMany< A, B, C>(
            this Set<Set<A>> ma,
            Func<A, Set<B>> bind,
            Func<A, B, C> project) =>
                Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                    .Inst.Bind<MSet<Set<C>>, Set<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(MSet<B>).Bind<MSet<C>, Set<C>, C>(mb, b => default(MSet<C>).Return(project(a, b)));
                    });

        /// <summary>
        /// Adds the two inner Num<A> types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x + y</returns>
        [Pure]
        public static Set<Set<A>> PlusT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x - y</returns>
        [Pure]
        public static Set<Set<A>> SubtractT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner Num<A> types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x * y</returns>
        [Pure]
        public static Set<Set<A>> ProductT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides x by y, which are both Num<A>s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">Num<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x / y</returns>
        [Pure]
        public static Set<Set<A>> DivideT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">Semigroup<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x `append` y</returns>
        [Pure]
        public static Set<Set<A>> AppendT<SEMI,  A>(this Set<Set<A>> x, Set<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// Ord compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">Ord<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x `compare` y</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Set<A>> x, Set<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// Eq compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">Eq<A> class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>Set<Set<A>> which is the result of performing x == y</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Set<A>> x, Set<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply fa to fab
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of Set<Set<A>></param>
        /// <returns>Set<Set<B>> which is the result of performing fab(fa)</returns>
        [Pure]
        public static Set<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Set<A>> fa) =>
            FSet< Set<A>, Set<B>>.Inst.Apply(
                 MSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => FSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply fa and fb to fabc
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of Set<Set<A>></param>
        /// <param name="fb">Monad of Set<Set<A>></param>
        /// <returns>Set<Set<B>> which is the result of performing fabc(fa, fb)</returns>
        [Pure]
        public static Set<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Set<A>> fa, Set<Set<B>> fb) =>
            FSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            FSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
}
