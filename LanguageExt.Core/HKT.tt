<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
    var types = new [] {
        T("IEnumerable", "!T",        "Ctor.EnumerableCtor<!T>(FUNC)",  "self.FirstOrDefault()", "List"),
        T("Option",      "!T",        "FUNC",                           "self.IsSome ? self.Value : default(T)"),
        T("OptionUnsafe","!T",        "FUNC",                           "self.IsSome ? self.Value : default(T)"),
        T("Lst",         "!T",        "Prelude.list(FUNC)",             "self.FirstOrDefault()", "List"),
        T("Map",         "K, !T",     "Ctor.MapCtor<K,!T>(FUNC)",       "self.Values.FirstOrDefault()"),
        T("TryOption",   "!T",        "() => FUNC",                     "self.Try().Value.IfNone(default(T))"),
        T("Try",         "!T",        "() => FUNC",                     "self.Try().Value"),
        T("Either",      "L, !T",     "FUNC",                           "self.IsRight ? self.RightValue : default(T)"),
        T("EitherUnsafe","L, !T",     "FUNC",                           "self.IsRight ? self.RightValue : default(T)"),
      //T("Reader",      "Env, !T",   "Ctor.ReaderCtor<Env,!T>(FUNC)",  "default(T)"),
        T("Writer",      "Out, !T",   "Prelude.Writer<Out,!T>(FUNC)",   "self().Value"),
      //T("State",       "State, !T", "Ctor.StateCtor<State,!T>(FUNC)", "default(T)"),
    };

    var monadFuncs = new [] {
        //
        // Value
        //
        Tuple.Create(
            "internal static T Value<ARGS_T>(this TYPE self) => VALUE;",
            "internal static RETURN_ONE_T ValueT<ARGS_T>(this TYPE self) => self.MapT(x => x.Value());",
            ""),
        //
        // Sum
        //
        Tuple.Create(
            "internal static int SumT<ARGS_INT>(this TYPE_INT self) => self.Sum();",
            "public static int SumT<ARGS_INT>(this TYPE_INT self) => self.MapT(x => x.SumT()).Sum();",
            "public static int sumT<ARGS_INT>(TYPE_INT self) => self.MapT(x => x.SumT()).Sum();"),
        //
        // Count
        //
        Tuple.Create(
            "internal static int CountT<ARGS_T>(this TYPE self) => self.Count();",
            "public static int CountT<ARGS_T>(this TYPE self) => self.Map(x => x.CountT()).Sum();",
            "public static int countT<ARGS_T>(TYPE self) => self.Map(x => x.CountT()).Sum();"),
        //
        // Bind
        //
        Tuple.Create(
            "internal static RETURN_U BindT<ARGS_TU>(this TYPE self, Func<T, RETURN_U> binder) => self.Bind(binder);",
            "public static RETURN_U BindT<ARGS_TU>(this TYPE self, Func<T, INNER_U> binder) => self.MapT(x => x.BindT(binder));",
            "public static RETURN_U bindT<ARGS_TU>(TYPE self, Func<T, INNER_U> binder) => self.MapT(x => x.BindT(binder));"),
        //
        // Exists
        //
        Tuple.Create(
            "internal static bool ExistsT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Exists(pred);",
            "public static bool ExistsT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);",
            "public static bool existsT<ARGS_T>(TYPE self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);"),
        //
        // Filter
        //
        Tuple.Create(
            "internal static RETURN_T FilterT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Filter(pred);",
            "public static RETURN_T FilterT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));",
            "public static RETURN_T filterT<ARGS_T>(TYPE self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));"),
        //
        // Fold
        //
        Tuple.Create(
            "internal static V FoldT<ARGS_T, V>(this TYPE self, V state, Func<V, T, V> fold) => self.Fold(state,fold);",
            "public static V FoldT<ARGS_T, V>(this TYPE self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));",
            "public static V foldT<ARGS_T, V>(TYPE self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));"),
        //
        // ForAll
        //
        Tuple.Create(
            "internal static bool ForAllT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.ForAll(pred);",
            "public static bool ForAllT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);",
            "public static bool forAllT<ARGS_T>(TYPE self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);"),
        //
        // Iter
        //
        Tuple.Create(
            "internal static Unit IterT<ARGS_T>(this TYPE self, Action<T> action) => self.Iter(action);",
            "public static Unit IterT<ARGS_T>(this TYPE self, Action<T> action) => self.Iter(x => x.IterT(action));",
            "public static Unit iterT<ARGS_T>(TYPE self, Action<T> action) => self.Iter(x => x.IterT(action));"),
        //
        // Map
        //
        Tuple.Create(
            "internal static RETURN_U MapT<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.Map(mapper);",
            "public static RETURN_U MapT<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));",
            "public static RETURN_U mapT<ARGS_TU>(TYPE self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));"),
        //
        // Lift
        //
        Tuple.Create(
            "public static T Lift<ARGS_T>(this TYPE self) where T : struct => self.Value();",
            "public static T LiftT<ARGS_T>(this TYPE self) where T : struct => self.ValueT().Value();",
            "public static T liftT<ARGS_T>(TYPE self) where T : struct => self.ValueT().Value();"),
        //
        // LiftUnsafe
        //
        Tuple.Create(
            "public static T LiftUnsafe<ARGS_T>(this TYPE self) where T : class => self.Value();",
            "public static T LiftUnsafeT<ARGS_T>(this TYPE self) where T : class => self.ValueT().Value();",
            "public static T liftUnsafeT<ARGS_T>(TYPE self) where T : class => self.ValueT().Value();"),
   };

   var linqFuncs = new [] {
        //
        // Select
        //
        Tuple.Create(
            "internal static RETURN_U Select<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.Map(mapper);",
            "public static RETURN_U Select<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));"),
        //
        // Where
        //
        Tuple.Create(
            "internal static RETURN_T Where<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Filter(pred);",
            "public static RETURN_T Where<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));"),
        //
        // SelectMany
        //
        Tuple.Create(
            "",
            "public static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, INNER_U> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));"),
        //
        // SelectMany
        //
        //Tuple.Create(
        //    "internal static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, U> bind, Func<T,U,V> project) => self.Select(x => project(x, bind(x)));",
        //    "public static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, U> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));"),
   };
#>
using System; 
using System.Collections.Generic;
using System.Collections;
using System.Collections.Immutable;
using System.Linq;
using System.ComponentModel;
using LanguageExt;
using static LanguageExt.Prelude;
using LanguageExt.Trans;
using LanguageExt.Trans.Linq;

///
///   This code is auto-generated by HKT.tt, any manual modifications may be lost.
///

namespace LanguageExt
{
<#= GenerateOuterFuncs("TYPE", monadFuncs.Select(f => f.Item3).Where(f => f != ""), types, 2) #>
}

namespace LanguageExt.Trans
{
<#= GenerateInnerFuncs("TYPEMonad", monadFuncs.Select( f => f.Item1).Where(f => f != ""), types, 2) #>
<#= GenerateOuterFuncs("TYPETMonad", monadFuncs.Select(f => f.Item2).Where(f => f != ""), types, 2) #>

    namespace Linq
    {
<#= GenerateInnerFuncs("TYPEMonad", linqFuncs.Select( f => f.Item1).Where(f => f != ""), types, 3) #>
<#= GenerateOuterFuncs("TYPETMonad", linqFuncs.Select(f => f.Item2).Where(f => f != ""), types, 3) #>
    }

    internal static class Ctor
    {
        internal static IEnumerable<T> EnumerableCtor<T>(IEnumerable<T> m) => m;
        internal static IEnumerable<T> EnumerableCtor<T>(T v) => new T [1] {v};
        internal static Reader<Env,T> ReaderCtor<Env,T>(Reader<Env,T> rdr) => rdr;
        internal static Reader<Env,T> ReaderCtor<Env,T>(T v) => env => v;
        internal static State<S, T> StateCtor<S, T>(State<S, T> s) => s;
        internal static State<S, T> StateCtor<S, T>(T v) => s => new StateResult<S, T>(s,v);
        internal static Map<K, T> MapCtor<K, T>(Map<K, T> m) => m;
        internal static Map<K, T> MapCtor<K, T>(T v) => Map(Tuple(default(K),v));
    }
}

<#+

    public class TypeDesc
    {
        public readonly string Name;
        public readonly string Args;
        public readonly string Ctor;
        public readonly string Value;
        public readonly string TypeAlias;

        public TypeDesc(string name, string args, string ctor, string value, string typeAlias = null)
        {
            Name = name;
            Args = args;
            Ctor = ctor;
            Value = value;
            TypeAlias = typeAlias ?? Name;
        }
    }

    public TypeDesc T(string name, string args, string ctor, string value, string typeAlias = null)
    {
        return new TypeDesc(name,args,ctor,value,typeAlias);
    }

    public string GenerateInnerFuncs(string ns, IEnumerable<string> funcs, IEnumerable<TypeDesc> types, int tabs)
    {
        Func<TypeDesc, string> pre  = type => Space("public static partial class "+ns.Replace("TYPE",type.TypeAlias) +" {" ,tabs-1);
        Func<TypeDesc, string> post = type => Space("}",tabs-1);
        Func<string,string,IEnumerable<string>,string> all = (a,b,c) => String.Join("\r\n",a,String.Join("\r\n", c),b);

        return String.Join("\r\n",
                   from type in types
                   select 
                       all(
                           pre(type),
                           post(type),
                           from func in funcs
                           select Space(GenerateInnerFunc(func,type),tabs)
                       )
                   );
    }

    public string GenerateOuterFuncs(string ns,IEnumerable<string> funcs, IEnumerable<TypeDesc> types, int tabs)
    {
        Func<TypeDesc, string> pre  = type => Space("public static partial class "+ns.Replace("TYPE",type.TypeAlias) +" {" ,tabs-1);
        Func<TypeDesc, string> post = type => Space("}",tabs-1);
        Func<string,string,IEnumerable<string>,string> all = (a,b,c) => String.Join("\r\n",a,String.Join("\r\n", c),b);

        return String.Join("\r\n",
                   from outer in types
                   from inner in types
                   select 
                       all(
                           pre(outer),
                           post(outer),
                           from func in funcs
                           select Space(GenerateOuterFunc(func,outer,inner),tabs)
                       )
                   );
    }

    public string Space(string str, int tabs)
    {
        switch(tabs)
        {
            case 1: return "    "+str;
            case 2: return "        "+str;
            case 3: return "            "+str;
            case 4: return "                "+str;
            default: return "";
        }
    }

    public string TypeArgsGen(TypeDesc type, string genericArg)
    {
        return type.Args.Replace("!T",genericArg);
    }

    public string TypeGen(TypeDesc type, string genericArg, string additionalGenericArg = "")
    {
        return String.Format("{0}<{1}{2}>", type.Name, TypeArgsGen(type,genericArg), additionalGenericArg);
    }

    public string TypeGen(TypeDesc outerType, TypeDesc innerType, string genericArg, string additionalGenericArg = "")
    {
        return String.Format("{0}<{1}{2}>", outerType.Name, TypeArgsGen(innerType,genericArg), additionalGenericArg);
    }

    public string GenerateInnerFunc(string func, TypeDesc type)
    {
        var fqtype         = TypeGen(type,"T");
        var inttype        = TypeGen(type,"","int");
        var booltype       = TypeGen(type,"","bool");
        var returnTypeT    = fqtype;
        var returnTypeU    = TypeGen(type,"U");
        var returnTypeV    = TypeGen(type,"V");
        var returnTypeInt  = TypeGen(type,"int");
        var returnTypeBool = TypeGen(type,"bool");

        return func.Replace("TYPE_INT",inttype)
                   .Replace("TYPE_BOOL",booltype)
                   .Replace("TYPE",fqtype)
                   .Replace("CLASS", type.Name)
                   .Replace("RETURN_T",returnTypeT)
                   .Replace("RETURN_U", returnTypeU)
                   .Replace("RETURN_V", returnTypeV)
                   .Replace("RETURN_INT", returnTypeInt)
                   .Replace("RETURN_BOOL", returnTypeBool)
                   .Replace("ARGS_TUV", type.Args.Replace("!T","T") + ", U, V")
                   .Replace("ARGS_TU", type.Args.Replace("!T","T") + ", U")
                   .Replace("ARGS_T", type.Args.Replace("!T","T"))
                   .Replace("ARGS_INT", type.Args.Replace(", !T","").Replace("!T",""))
                   .Replace("ARGS_BOOL", type.Args.Replace(", !T","").Replace("!T",""))
                   .Replace("VALUE",type.Value)
                   .Replace("<>","");
    }

    public string GenerateOuterFunc(
        string func, 
        TypeDesc outerType, 
        TypeDesc innerType
        )
    {
        var args = String.Join(", ", (outerType.Args + "," + innerType.Args).Split(',').Select(x => x.Trim()).Distinct());

        var innerTypeT     = TypeGen(innerType,"T");
        var innerTypeU     = TypeGen(innerType,"U");
        var innerTypeV     = TypeGen(innerType,"V");
        var innerTypeInt   = TypeGen(innerType,"int");
        var innerTypeBool  = TypeGen(innerType,"bool");

        var outerTypeT     = TypeGen(outerType,innerType,"T");
        var outerTypeU     = TypeGen(outerType,innerType,"U");
        var outerTypeV     = TypeGen(outerType,innerType,"V");
        var outerTypeInt   = TypeGen(outerType,innerType,"int");
        var outerTypeBool  = TypeGen(outerType,innerType,"bool");

        var fqtype   = TypeGen(outerType,innerTypeT);
        var inttype  = TypeGen(outerType,innerTypeInt);
        var booltype = TypeGen(outerType,innerTypeBool);

        var returnSingleT    = TypeGen(outerType,"T");
        var returnSingleU    = TypeGen(outerType,"U");
        var returnSingleV    = TypeGen(outerType,"V");
        var returnSingleInt  = TypeGen(outerType,"int");
        var returnSingleBool = TypeGen(outerType,"bool");

        var returnTypeT    = TypeGen(outerType,innerTypeT);
        var returnTypeU    = TypeGen(outerType,innerTypeU);
        var returnTypeV    = TypeGen(outerType,innerTypeV);
        var returnTypeInt  = TypeGen(outerType,innerTypeInt);
        var returnTypeBool = TypeGen(outerType,innerTypeBool);

        return func.Replace("TYPE_INT",inttype)
                   .Replace("TYPE_BOOL",booltype)
                   .Replace("TYPE",fqtype)
                   .Replace("RETURN_ONE_T", returnSingleT)
                   .Replace("RETURN_ONE_U", returnSingleU)
                   .Replace("RETURN_ONE_V", returnSingleV)
                   .Replace("RETURN_ONE_INT", returnSingleInt)
                   .Replace("RETURN_ONE_BOOL", returnSingleBool)
                   .Replace("RETURN_T", returnTypeT)
                   .Replace("RETURN_U", returnTypeU)
                   .Replace("RETURN_V", returnTypeV)
                   .Replace("RETURN_INT", returnTypeInt)
                   .Replace("RETURN_BOOL", returnTypeBool)
                   .Replace("INNER_T", innerTypeT)
                   .Replace("INNER_U", innerTypeU)
                   .Replace("INNER_V", innerTypeV)
                   .Replace("INNER_INT", innerTypeInt)
                   .Replace("INNER_BOOL", innerTypeBool)
                   .Replace("OUTER_T", innerTypeT)
                   .Replace("OUTER_U", innerTypeU)
                   .Replace("OUTER_V", innerTypeV)
                   .Replace("OUTER_INT", innerTypeInt)
                   .Replace("OUTER_BOOL", innerTypeBool)
                   .Replace("ARGS_INT", args.Replace("!T, ","").Replace(", !T","").Replace("!T",""))
                   .Replace("ARGS_BOOL", args.Replace("!T, ","").Replace(", !T","").Replace("!T",""))
                   .Replace("ARGS_TUV", args.Replace("!T","T") + ", U, V")
                   .Replace("ARGS_TU", args.Replace("!T","T") + ", U")
                   .Replace("ARGS_T", args.Replace("!T","T"))
                   .Replace("<>","");    
    }
#>

