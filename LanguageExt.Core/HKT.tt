<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
    var types = new [] {
        Tuple.Create("IEnumerable", "!T",        "EnumerableCtor<!T>(FUNC)",       "default(T)"),              
        Tuple.Create("Option",      "!T",        "FUNC",                           "self.IsSome ? self.Value : default(T)"),
        Tuple.Create("OptionUnsafe","!T",        "FUNC",                           "self.IsSome ? self.Value : default(T)"),
        Tuple.Create("Lst",         "!T",        "Prelude.list(FUNC)",             "default(T)"),
        Tuple.Create("Map",         "K, !T",     "MapCtor<K,!T>(FUNC)",            "default(T)"),
        Tuple.Create("TryOption",   "!T",        "() => FUNC",                     "self.Try().Value.IfNone(default(T))"),
        Tuple.Create("Try",         "!T",        "() => FUNC",                     "self.Try().Value"),
        Tuple.Create("Either",      "L, !T",     "FUNC",                           "self.IsRight ? self.RightValue : default(T)"),
        Tuple.Create("EitherUnsafe","L, !T",     "FUNC",                           "self.IsRight ? self.RightValue : default(T)"),
      //Tuple.Create("Reader",      "Env, !T",   "ReaderCtor<Env,!T>(FUNC)",       "default(T)"),
        Tuple.Create("Writer",      "Out, !T",   "Prelude.Writer<Out,!T>(FUNC)",   "default(T)"),              
      //Tuple.Create("State",       "State, !T", "StateCtor<State,!T>(FUNC)",      "default(T)"),                
    };

    var funcs = new [] {
        //
        // Value
        //
        Tuple.Create(
            "public static T ValueT<ARGS_T>(this TYPE self) => VALUE;",
            "public static RETURN_ONE_T ValueT<ARGS_T>(this TYPE self) => self.MapT(x => x.ValueT());"),
        //
        // Sum
        //
        Tuple.Create(
            "public static int SumT<ARGS_INT>(this TYPE_INT self) => self.Sum();",
            "public static int SumT<ARGS_INT>(this TYPE_INT self) => self.MapT(x => x.SumT()).Sum();"),
        //
        // Count
        //
        Tuple.Create(
            "public static int CountT<ARGS_T>(this TYPE self) => self.Count();",
            "public static int CountT<ARGS_T>(this TYPE self) => self.Map(x => x.CountT()).Sum();"),
        //
        // Bind
        //
        Tuple.Create(
            "public static RETURN_U BindT<ARGS_TU>(this TYPE self, Func<T, RETURN_U> binder) => self.Bind(binder);",
            "public static RETURN_U BindT<ARGS_TU>(this TYPE self, Func<T, INNER_U> binder) => self.MapT(x => x.BindT(binder));"),
        //
        // Exists
        //
        Tuple.Create(
            "public static bool ExistsT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Exists(pred);",
            "public static bool ExistsT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.ExistsT(pred)).Exists(x=>x);"),
        //
        // Filter
        //
        Tuple.Create(
            "public static RETURN_T FilterT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Filter(pred);",
            "public static RETURN_T FilterT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));"),
        //
        // Fold
        //
        Tuple.Create(
            "public static V FoldT<ARGS_T, V>(this TYPE self, V state, Func<V, T, V> fold) => self.Fold(state,fold);",
            "public static V FoldT<ARGS_T, V>(this TYPE self, V state, Func<V, T, V> fold) => self.Fold(state, (s,x) => x.FoldT(s,fold));"),
        //
        // ForAll
        //
        Tuple.Create(
            "public static bool ForAllT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.ForAll(pred);",
            "public static bool ForAllT<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.ForAllT(pred)).ForAll(x=>x);"),
        //
        // Iter
        //
        Tuple.Create(
            "public static Unit IterT<ARGS_T>(this TYPE self, Action<T> action) => self.Iter(action);",
            "public static Unit IterT<ARGS_T>(this TYPE self, Action<T> action) => self.Iter(x => x.IterT(action));"),
        //
        // Map
        //
        Tuple.Create(
            "public static RETURN_U MapT<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.Map(mapper);",
            "public static RETURN_U MapT<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));"),
        //
        // Select
        //
        Tuple.Create(
            "public static RETURN_U Select<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.Map(mapper);",
            "public static RETURN_U Select<ARGS_TU>(this TYPE self, Func<T, U> mapper) => self.MapT(x => x.MapT(mapper));"),
        //
        // Where
        //
        Tuple.Create(
            "public static RETURN_T Where<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.Filter(pred);",
            "public static RETURN_T Where<ARGS_T>(this TYPE self, Func<T, bool> pred) => self.MapT(x => x.FilterT(pred));"),
        //
        // SelectMany
        //
        Tuple.Create(
            "",
            "public static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, INNER_U> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));"),
        //
        // SelectMany
        //
        //Tuple.Create(
        //    "public static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, U> bind, Func<T,U,V> project) => self.Select(x => project(x, bind(x)));",
        //    "public static RETURN_V SelectMany<ARGS_TUV>(this TYPE self, Func<T, U> bind, Func<T,U,V> project) => self.MapT(x => x.SelectMany(bind,project));"),
        //
        // Lift
        //
        Tuple.Create(
            "public static T LiftT<ARGS_T>(this TYPE self) => self.ValueT();",
            "public static T LiftT<ARGS_T>(this TYPE self) => self.ValueT().ValueT();"),
   };
#>
using System; 
using System.Collections.Generic;
using System.Collections;
using System.Collections.Immutable;
using System.Linq;
using System.ComponentModel;
using LanguageExt;
using static LanguageExt.Prelude;

namespace LanguageExt.Trans
{
    internal static partial class HKTInternal
    {
        <# foreach(var prefunc in funcs.Select( f => f.Item1))
           {
                var func = prefunc;

                foreach(var type in types)
                {
                    var fqtype         = String.Format("{0}<{1}>", type.Item1, type.Item2.Replace("!T","T"));
                    var inttype        = String.Format("{0}<{1}int>", type.Item1, type.Item2.Replace("!T",""));
                    var booltype       = String.Format("{0}<{1}bool>", type.Item1, type.Item2.Replace("!T",""));
                    var returnTypeT    = fqtype;
                    var returnTypeU    = String.Format("{0}<{1}>", type.Item1, type.Item2.Replace("!T","U"));
                    var returnTypeV    = String.Format("{0}<{1}>", type.Item1, type.Item2.Replace("!T","V"));
                    var returnTypeInt  = String.Format("{0}<{1}>", type.Item1, type.Item2.Replace("!T","int"));
                    var returnTypeBool = String.Format("{0}<{1}>", type.Item1, type.Item2.Replace("!T","bool"));

                    var sig = func.Replace("TYPE_INT",inttype)
                                  .Replace("TYPE_BOOL",booltype)
                                  .Replace("TYPE",fqtype)
                                  .Replace("CLASS", type.Item1)
                                  .Replace("RETURN_T",returnTypeT)
                                  .Replace("RETURN_U", returnTypeU)
                                  .Replace("RETURN_V", returnTypeV)
                                  .Replace("RETURN_INT", returnTypeInt)
                                  .Replace("RETURN_BOOL", returnTypeBool)
                                  .Replace("ARGS_TUV", type.Item2.Replace("!T","T") + ", U, V")
                                  .Replace("ARGS_TU", type.Item2.Replace("!T","T") + ", U")
                                  .Replace("ARGS_T", type.Item2.Replace("!T","T"))
                                  .Replace("ARGS_INT", type.Item2.Replace(", !T","").Replace("!T",""))
                                  .Replace("ARGS_BOOL", type.Item2.Replace(", !T","").Replace("!T",""))
                                  .Replace("VALUE",type.Item4)
                                  .Replace("<>","");
        #>
<#= sig #>
        <#
             
                }
           }
        #>

    }

    public static partial class HKT
    {

        <# foreach(var func in funcs.Select( f => f.Item2))
           {
               foreach(var outer in types)
               {
                   foreach(var inner in types)
                   {
                       var args = String.Join(", ", (outer.Item2 + "," + inner.Item2).Split(',').Select(x => x.Trim()).Distinct());

                       var innerTypeT     = String.Format("{0}<{1}>", inner.Item1, inner.Item2.Replace("!T","T"));
                       var innerTypeU     = String.Format("{0}<{1}>", inner.Item1, inner.Item2.Replace("!T","U"));
                       var innerTypeV     = String.Format("{0}<{1}>", inner.Item1, inner.Item2.Replace("!T","V"));
                       var innerTypeInt   = String.Format("{0}<{1}>", inner.Item1, inner.Item2.Replace("!T","int"));
                       var innerTypeBool  = String.Format("{0}<{1}>", inner.Item1, inner.Item2.Replace("!T","bool"));

                       var fqtype = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeT));
                       var inttype = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeInt));
                       var booltype = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeBool));

                       var returnSingleT    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T","T"));
                       var returnSingleU    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T","U"));
                       var returnSingleV    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T","V"));
                       var returnSingleInt  = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T","int"));
                       var returnSingleBool = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T","bool"));

                       var returnTypeT    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeT));
                       var returnTypeU    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeU));
                       var returnTypeV    = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeV));
                       var returnTypeInt  = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeInt));
                       var returnTypeBool = String.Format("{0}<{1}>", outer.Item1, outer.Item2.Replace("!T",innerTypeBool));

                       var sig = func.Replace("TYPE_INT",inttype)
                                     .Replace("TYPE_BOOL",booltype)
                                     .Replace("TYPE",fqtype)
                                     .Replace("RETURN_ONE_T", returnSingleT)
                                     .Replace("RETURN_ONE_U", returnSingleU)
                                     .Replace("RETURN_ONE_V", returnSingleV)
                                     .Replace("RETURN_ONE_INT", returnSingleInt)
                                     .Replace("RETURN_ONE_BOOL", returnSingleBool)
                                     .Replace("RETURN_T", returnTypeT)
                                     .Replace("RETURN_U", returnTypeU)
                                     .Replace("RETURN_V", returnTypeV)
                                     .Replace("RETURN_INT", returnTypeInt)
                                     .Replace("RETURN_BOOL", returnTypeBool)
                                     .Replace("INNER_T", innerTypeT)
                                     .Replace("INNER_U", innerTypeU)
                                     .Replace("INNER_V", innerTypeV)
                                     .Replace("ARGS_INT", args.Replace("!T, ","").Replace(", !T","").Replace("!T",""))
                                     .Replace("ARGS_BOOL", args.Replace("!T, ","").Replace(", !T","").Replace("!T",""))
                                     .Replace("ARGS_TUV", args.Replace("!T","T") + ", U, V")
                                     .Replace("ARGS_TU", args.Replace("!T","T") + ", U")
                                     .Replace("ARGS_T", args.Replace("!T","T"))
                                     .Replace("VALUE",inner.Item4)
                                     .Replace("<>","");
        #>
<#= sig #>
        <#     
                    }
                }
           }
        #>

        private static IEnumerable<T> EnumerableCtor<T>(IEnumerable<T> m) => m;
        private static IEnumerable<T> EnumerableCtor<T>(T v) => new T [1] {v};
        private static Reader<Env,T> ReaderCtor<Env,T>(Reader<Env,T> rdr) => rdr;
        private static Reader<Env,T> ReaderCtor<Env,T>(T v) => env => v;
        private static State<S, T> StateCtor<S, T>(State<S, T> s) => s;
        private static State<S, T> StateCtor<S, T>(T v) => s => new StateResult<S, T>(s,v);
        private static Map<K, T> MapCtor<K, T>(Map<K, T> m) => m;
        private static Map<K, T> MapCtor<K, T>(T v) => Prelude.map(Prelude.tuple(default(K),v));
   }
}