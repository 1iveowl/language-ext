// <auto-generated/>

using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    /// <summary>
    /// Async monad transformer for OptionAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionAsyncT_Async_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<OptionAsync<A>> ma,
            Func<A, OptionAsync<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<OptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<OptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<OptionAsync<A>> ma,
            Func<A, OptionAsync<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MOptionAsync<OptionAsync<C>>, OptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> Where< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> Where< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> Select< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> BindT< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> BindT< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, OptionAsync<OptionAsync<B>>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> BindT< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, Task<OptionAsync<OptionAsync<B>>>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> Sequence< A>(this OptionAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SequenceAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> MapT< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> MapT< A, B>(this OptionAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<OptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> FilterT< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> FilterT< A>(this OptionAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> PlusT<NUM,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> SubtractT<NUM,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> ProductT<NUM,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> DivideT<NUM,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> AppendT<SEMI,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<OptionAsync<A>> fa) =>
            default(ApplOptionAsync< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MOptionAsync< Func<OptionAsync<A>, OptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, OptionAsync<B>>>((OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<OptionAsync<A>> fa, OptionAsync<OptionAsync<B>> fb) =>
            default(ApplOptionAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MOptionAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>((OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionAsync<C>> SelectMany< A, B, C>(
            this Task<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionAsync<C>> SelectMany< A, B, C>(
            this Task<OptionAsync<A>> ma,
            Func<A, Task<Task<OptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionAsync<C>> SelectMany< A, B, C>(
            this Task<OptionAsync<A>> ma,
            Func<A, Task<Task<OptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionAsync<C>> SelectMany< A, B, C>(
            this Task<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTask<OptionAsync<C>>, Task<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionAsync<A>> Where< A>(this Task<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionAsync<A>> Where< A>(this Task<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> Select< A, B>(this Task<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<OptionAsync<A>> ma) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> BindT< A, B>(this Task<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> BindT< A, B>(this Task<OptionAsync<A>> ma, Func<A, Task<OptionAsync<B>>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> BindT< A, B>(this Task<OptionAsync<A>> ma, Func<A, Task<Task<OptionAsync<B>>>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Task<B>> Traverse< A, B>(this Task<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Task<B>> Traverse< A, B>(this Task<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Task&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Task<A>> Sequence< A>(this Task<OptionAsync<A>> ma) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SequenceAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> MapT< A, B>(this Task<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> MapT< A, B>(this Task<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<OptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionAsync<A>> FilterT< A>(this Task<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionAsync<A>> FilterT< A>(this Task<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<OptionAsync<A>> PlusT<NUM,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<OptionAsync<A>> SubtractT<NUM,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> ProductT<NUM,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> DivideT<NUM,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> AppendT<SEMI,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Task<OptionAsync<A>> fa) =>
            default(ApplTask< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MTask< Func<OptionAsync<A>, OptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, OptionAsync<B>>>((OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<OptionAsync<A>> fa, Task<OptionAsync<B>> fb) =>
            default(ApplTask< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MTask< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>((OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<OptionAsync<A>> ma,
            Func<A, TryAsync<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<OptionAsync<A>> ma,
            Func<A, Task<TryAsync<OptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<OptionAsync<A>> ma,
            Func<A, Task<TryAsync<OptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<OptionAsync<A>> ma,
            Func<A, TryAsync<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryAsync<OptionAsync<C>>, TryAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> Where< A>(this TryAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> Where< A>(this TryAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> Select< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> BindT< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> BindT< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, TryAsync<OptionAsync<B>>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> BindT< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, Task<TryAsync<OptionAsync<B>>>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> Sequence< A>(this TryAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SequenceAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> MapT< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> MapT< A, B>(this TryAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<OptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> FilterT< A>(this TryAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> FilterT< A>(this TryAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> PlusT<NUM,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> SubtractT<NUM,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> ProductT<NUM,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> DivideT<NUM,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> AppendT<SEMI,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<OptionAsync<A>> fa) =>
            default(ApplTryAsync< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MTryAsync< Func<OptionAsync<A>, OptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, OptionAsync<B>>>((OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<OptionAsync<A>> fa, TryAsync<OptionAsync<B>> fb) =>
            default(ApplTryAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MTryAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>((OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionAsync<A>> ma,
            Func<A, TryOptionAsync<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<OptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<OptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(await bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionAsync<A>> ma,
            Func<A, TryOptionAsync<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>).BindAsync<MTryOptionAsync<OptionAsync<C>>, TryOptionAsync<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(bind(a), b =>
            default(MOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> Where< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> Where< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> Select< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> BindT< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> BindT< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, TryOptionAsync<OptionAsync<B>>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> BindT< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, Task<TryOptionAsync<OptionAsync<B>>>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<OptionAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SequenceAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> MapT< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> MapT< A, B>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<OptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> FilterT< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> FilterT< A>(this TryOptionAsync<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> PlusT<NUM,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> SubtractT<NUM,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> ProductT<NUM,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> DivideT<NUM,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> AppendT<SEMI,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<OptionAsync<A>> fa) =>
            default(ApplTryOptionAsync< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MTryOptionAsync< Func<OptionAsync<A>, OptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, OptionAsync<B>>>((OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<OptionAsync<A>> fa, TryOptionAsync<OptionAsync<B>> fb) =>
            default(ApplTryOptionAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MTryOptionAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>((OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Task, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TaskT_Async_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Task<C>> SelectMany< A, B, C>(
            this OptionAsync<Task<A>> ma,
            Func<A, OptionAsync<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Task<C>> SelectMany< A, B, C>(
            this OptionAsync<Task<A>> ma,
            Func<A, Task<OptionAsync<Task<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Task<C>> SelectMany< A, B, C>(
            this OptionAsync<Task<A>> ma,
            Func<A, Task<OptionAsync<Task<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Task<C>> SelectMany< A, B, C>(
            this OptionAsync<Task<A>> ma,
            Func<A, OptionAsync<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MOptionAsync<Task<C>>, OptionAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Task<A>> Where< A>(this OptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Task<A>> Where< A>(this OptionAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> Select< A, B>(this OptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Task<A>> ma) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> BindT< A, B>(this OptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> BindT< A, B>(this OptionAsync<Task<A>> ma, Func<A, OptionAsync<Task<B>>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> BindT< A, B>(this OptionAsync<Task<A>> ma, Func<A, Task<OptionAsync<Task<B>>>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionAsync<B>> Traverse< A, B>(this OptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionAsync<B>> Traverse< A, B>(this OptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionAsync<A>> Sequence< A>(this OptionAsync<Task<A>> ma) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .SequenceAsync<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> MapT< A, B>(this OptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> MapT< A, B>(this OptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Task<A>> ma, Action<A> f) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Task<A>> FilterT< A>(this OptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Task<A>> FilterT< A>(this OptionAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Task<A>> PlusT<NUM,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Task<A>> SubtractT<NUM,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> ProductT<NUM,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> DivideT<NUM,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> AppendT<SEMI,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Task<A>> fa) =>
            default(ApplOptionAsync< Task<A>, Task<B>>).Apply(
                default(MOptionAsync< Func<Task<A>, Task<B>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Task<B>>>((Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Task<A>> fa, OptionAsync<Task<B>> fb) =>
            default(ApplOptionAsync< Task<A>, Task<B>, Task<C>>).Apply(
                default(MOptionAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Func<Task<B>, Task<C>>>>((Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Task<C>> SelectMany< A, B, C>(
            this Task<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Task<C>> SelectMany< A, B, C>(
            this Task<Task<A>> ma,
            Func<A, Task<Task<Task<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Task<C>> SelectMany< A, B, C>(
            this Task<Task<A>> ma,
            Func<A, Task<Task<Task<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Task<C>> SelectMany< A, B, C>(
            this Task<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTask<Task<C>>, Task<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Task<A>> Where< A>(this Task<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Task<A>> Where< A>(this Task<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> Select< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Task<A>> ma) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> BindT< A, B>(this Task<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> BindT< A, B>(this Task<Task<A>> ma, Func<A, Task<Task<B>>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> BindT< A, B>(this Task<Task<A>> ma, Func<A, Task<Task<Task<B>>>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Task<B>> Traverse< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Task<B>> Traverse< A, B>(this Task<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Task&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Task<A>> Sequence< A>(this Task<Task<A>> ma) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .SequenceAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> MapT< A, B>(this Task<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> MapT< A, B>(this Task<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Task<A>> ma, Action<A> f) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Task<A>> FilterT< A>(this Task<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Task<A>> FilterT< A>(this Task<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Task<A>> PlusT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Task<A>> SubtractT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Task<A>> ProductT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Task<A>> DivideT<NUM,  A>(this Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Task<A>> AppendT<SEMI,  A>(this Task<Task<A>> x, Task<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Task<A>> x, Task<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Task<A>> x, Task<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Task<A>> fa) =>
            default(ApplTask< Task<A>, Task<B>>).Apply(
                default(MTask< Func<Task<A>, Task<B>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Task<B>>>((Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Task<A>> fa, Task<Task<B>> fb) =>
            default(ApplTask< Task<A>, Task<B>, Task<C>>).Apply(
                default(MTask< Func<Task<A>, Func<Task<B>, Task<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Func<Task<B>, Task<C>>>>((Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Task<C>> SelectMany< A, B, C>(
            this TryAsync<Task<A>> ma,
            Func<A, TryAsync<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Task<C>> SelectMany< A, B, C>(
            this TryAsync<Task<A>> ma,
            Func<A, Task<TryAsync<Task<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Task<C>> SelectMany< A, B, C>(
            this TryAsync<Task<A>> ma,
            Func<A, Task<TryAsync<Task<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Task<C>> SelectMany< A, B, C>(
            this TryAsync<Task<A>> ma,
            Func<A, TryAsync<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryAsync<Task<C>>, TryAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Task<A>> Where< A>(this TryAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Task<A>> Where< A>(this TryAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> Select< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Task<A>> ma) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> BindT< A, B>(this TryAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> BindT< A, B>(this TryAsync<Task<A>> ma, Func<A, TryAsync<Task<B>>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> BindT< A, B>(this TryAsync<Task<A>> ma, Func<A, Task<TryAsync<Task<B>>>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryAsync<B>> Traverse< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryAsync<B>> Traverse< A, B>(this TryAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<TryAsync<A>> Sequence< A>(this TryAsync<Task<A>> ma) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .SequenceAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> MapT< A, B>(this TryAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> MapT< A, B>(this TryAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Task<A>> ma, Action<A> f) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Task<A>> FilterT< A>(this TryAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Task<A>> FilterT< A>(this TryAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Task<A>> PlusT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Task<A>> SubtractT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Task<A>> ProductT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Task<A>> DivideT<NUM,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Task<A>> AppendT<SEMI,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Task<A>> x, TryAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Task<A>> fa) =>
            default(ApplTryAsync< Task<A>, Task<B>>).Apply(
                default(MTryAsync< Func<Task<A>, Task<B>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Task<B>>>((Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Task<A>> fa, TryAsync<Task<B>> fb) =>
            default(ApplTryAsync< Task<A>, Task<B>, Task<C>>).Apply(
                default(MTryAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Func<Task<B>, Task<C>>>>((Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Task<A>> ma,
            Func<A, TryOptionAsync<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Task<A>> ma,
            Func<A, Task<TryOptionAsync<Task<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Task<A>> ma,
            Func<A, Task<TryOptionAsync<Task<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(await bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Task<A>> ma,
            Func<A, TryOptionAsync<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>).BindAsync<MTryOptionAsync<Task<C>>, TryOptionAsync<Task<C>>, MTask<C>, Task<C>, C>(bind(a), b =>
            default(MTask<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> Where< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> Where< A>(this TryOptionAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> Select< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Task<A>> ma) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> BindT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> BindT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, TryOptionAsync<Task<B>>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> BindT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, Task<TryOptionAsync<Task<B>>>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<Task<A>> ma) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .SequenceAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> MapT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> MapT< A, B>(this TryOptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Task<A>> ma, Action<A> f) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> FilterT< A>(this TryOptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> FilterT< A>(this TryOptionAsync<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> PlusT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> SubtractT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> ProductT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> DivideT<NUM,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> AppendT<SEMI,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Task<A>> fa) =>
            default(ApplTryOptionAsync< Task<A>, Task<B>>).Apply(
                default(MTryOptionAsync< Func<Task<A>, Task<B>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Task<B>>>((Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Task<A>> fa, TryOptionAsync<Task<B>> fb) =>
            default(ApplTryOptionAsync< Task<A>, Task<B>, Task<C>>).Apply(
                default(MTryOptionAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Task<A>, Func<Task<B>, Task<C>>>>((Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for TryAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryAsyncT_Async_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryAsync<A>> ma,
            Func<A, OptionAsync<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryAsync<A>> ma,
            Func<A, Task<OptionAsync<TryAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryAsync<A>> ma,
            Func<A, Task<OptionAsync<TryAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryAsync<A>> ma,
            Func<A, OptionAsync<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MOptionAsync<TryAsync<C>>, OptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> Where< A>(this OptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> Where< A>(this OptionAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> Select< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<TryAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> BindT< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> BindT< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, OptionAsync<TryAsync<B>>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> BindT< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, Task<OptionAsync<TryAsync<B>>>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> Sequence< A>(this OptionAsync<TryAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SequenceAsync<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> MapT< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> MapT< A, B>(this OptionAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<TryAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> FilterT< A>(this OptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> FilterT< A>(this OptionAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> PlusT<NUM,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> SubtractT<NUM,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> ProductT<NUM,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> DivideT<NUM,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> AppendT<SEMI,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<TryAsync<A>> fa) =>
            default(ApplOptionAsync< TryAsync<A>, TryAsync<B>>).Apply(
                default(MOptionAsync< Func<TryAsync<A>, TryAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, TryAsync<B>>>((TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<TryAsync<A>> fa, OptionAsync<TryAsync<B>> fb) =>
            default(ApplOptionAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MOptionAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>((TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryAsync<C>> SelectMany< A, B, C>(
            this Task<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryAsync<C>> SelectMany< A, B, C>(
            this Task<TryAsync<A>> ma,
            Func<A, Task<Task<TryAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryAsync<C>> SelectMany< A, B, C>(
            this Task<TryAsync<A>> ma,
            Func<A, Task<Task<TryAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryAsync<C>> SelectMany< A, B, C>(
            this Task<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTask<TryAsync<C>>, Task<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryAsync<A>> Where< A>(this Task<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryAsync<A>> Where< A>(this Task<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> Select< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<TryAsync<A>> ma) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> BindT< A, B>(this Task<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> BindT< A, B>(this Task<TryAsync<A>> ma, Func<A, Task<TryAsync<B>>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> BindT< A, B>(this Task<TryAsync<A>> ma, Func<A, Task<Task<TryAsync<B>>>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Task<B>> Traverse< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Task<B>> Traverse< A, B>(this Task<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Task&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Task<A>> Sequence< A>(this Task<TryAsync<A>> ma) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SequenceAsync<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> MapT< A, B>(this Task<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> MapT< A, B>(this Task<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<TryAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryAsync<A>> FilterT< A>(this Task<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryAsync<A>> FilterT< A>(this Task<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryAsync<A>> PlusT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryAsync<A>> SubtractT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryAsync<A>> ProductT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryAsync<A>> DivideT<NUM,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryAsync<A>> AppendT<SEMI,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<TryAsync<A>> x, Task<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryAsync<A>> fa) =>
            default(ApplTask< TryAsync<A>, TryAsync<B>>).Apply(
                default(MTask< Func<TryAsync<A>, TryAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, TryAsync<B>>>((TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryAsync<A>> fa, Task<TryAsync<B>> fb) =>
            default(ApplTask< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MTask< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>((TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryAsync<A>> ma,
            Func<A, TryAsync<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryAsync<A>> ma,
            Func<A, Task<TryAsync<TryAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryAsync<A>> ma,
            Func<A, Task<TryAsync<TryAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryAsync<A>> ma,
            Func<A, TryAsync<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryAsync<TryAsync<C>>, TryAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> Where< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> Where< A>(this TryAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> Select< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<TryAsync<A>> ma) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> BindT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> BindT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, TryAsync<TryAsync<B>>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> BindT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, Task<TryAsync<TryAsync<B>>>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> Sequence< A>(this TryAsync<TryAsync<A>> ma) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SequenceAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> MapT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> MapT< A, B>(this TryAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<TryAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> FilterT< A>(this TryAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> FilterT< A>(this TryAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> PlusT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> SubtractT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> ProductT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> DivideT<NUM,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> AppendT<SEMI,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryAsync<A>> fa) =>
            default(ApplTryAsync< TryAsync<A>, TryAsync<B>>).Apply(
                default(MTryAsync< Func<TryAsync<A>, TryAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, TryAsync<B>>>((TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryAsync<A>> fa, TryAsync<TryAsync<B>> fb) =>
            default(ApplTryAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MTryAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>((TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryAsync<A>> ma,
            Func<A, TryOptionAsync<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryAsync<A>> ma,
            Func<A, Task<TryOptionAsync<TryAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryAsync<A>> ma,
            Func<A, Task<TryOptionAsync<TryAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(await bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryAsync<A>> ma,
            Func<A, TryOptionAsync<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>).BindAsync<MTryOptionAsync<TryAsync<C>>, TryOptionAsync<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(bind(a), b =>
            default(MTryAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> Where< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> Where< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> Select< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<TryAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> BindT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> BindT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, TryOptionAsync<TryAsync<B>>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> BindT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, Task<TryOptionAsync<TryAsync<B>>>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<TryAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SequenceAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> MapT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> MapT< A, B>(this TryOptionAsync<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<TryAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> FilterT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> FilterT< A>(this TryOptionAsync<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> PlusT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> ProductT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> DivideT<NUM,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryAsync<A>> fa) =>
            default(ApplTryOptionAsync< TryAsync<A>, TryAsync<B>>).Apply(
                default(MTryOptionAsync< Func<TryAsync<A>, TryAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, TryAsync<B>>>((TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryAsync<A>> fa, TryOptionAsync<TryAsync<B>> fb) =>
            default(ApplTryOptionAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MTryOptionAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>((TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for TryOptionAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionAsyncT_Async_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryOptionAsync<A>> ma,
            Func<A, OptionAsync<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryOptionAsync<A>> ma,
            Func<A, Task<OptionAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryOptionAsync<A>> ma,
            Func<A, Task<OptionAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionAsync<TryOptionAsync<A>> ma,
            Func<A, OptionAsync<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MOptionAsync<TryOptionAsync<C>>, OptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> Where< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> Where< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> Select< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> BindT< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> BindT< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, OptionAsync<TryOptionAsync<B>>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> BindT< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, Task<OptionAsync<TryOptionAsync<B>>>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> Traverse< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> Sequence< A>(this OptionAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SequenceAsync<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> MapT< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> MapT< A, B>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> FilterT< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> FilterT< A>(this OptionAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> PlusT<NUM,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> SubtractT<NUM,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> ProductT<NUM,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> DivideT<NUM,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> AppendT<SEMI,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<TryOptionAsync<A>> fa) =>
            default(ApplOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MOptionAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, TryOptionAsync<B>>>((TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<TryOptionAsync<A>> fa, OptionAsync<TryOptionAsync<B>> fb) =>
            default(ApplOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MOptionAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>((TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Task<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Task<TryOptionAsync<A>> ma,
            Func<A, Task<Task<TryOptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Task<TryOptionAsync<A>> ma,
            Func<A, Task<Task<TryOptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Task<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTask<TryOptionAsync<C>>, Task<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> Where< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> Where< A>(this Task<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> Select< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> BindT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> BindT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, Task<TryOptionAsync<B>>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> BindT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, Task<Task<TryOptionAsync<B>>>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> Traverse< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Task&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> Traverse< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Task&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> Sequence< A>(this Task<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SequenceAsync<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> MapT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> MapT< A, B>(this Task<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> FilterT< A>(this Task<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> FilterT< A>(this Task<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> PlusT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> SubtractT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> ProductT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> DivideT<NUM,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> AppendT<SEMI,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryOptionAsync<A>> fa) =>
            default(ApplTask< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MTask< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, TryOptionAsync<B>>>((TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryOptionAsync<A>> fa, Task<TryOptionAsync<B>> fb) =>
            default(ApplTask< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MTask< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>((TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryOptionAsync<A>> ma,
            Func<A, TryAsync<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryOptionAsync<A>> ma,
            Func<A, Task<TryAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryOptionAsync<A>> ma,
            Func<A, Task<TryAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryAsync<TryOptionAsync<A>> ma,
            Func<A, TryAsync<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryAsync<TryOptionAsync<C>>, TryAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> Where< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> Where< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> Select< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> BindT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> BindT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, TryAsync<TryOptionAsync<B>>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> BindT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, Task<TryAsync<TryOptionAsync<B>>>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> Traverse< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> Sequence< A>(this TryAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SequenceAsync<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> MapT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> MapT< A, B>(this TryAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> FilterT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> FilterT< A>(this TryAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> PlusT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> ProductT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> DivideT<NUM,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryOptionAsync<A>> fa) =>
            default(ApplTryAsync< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MTryAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, TryOptionAsync<B>>>((TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryOptionAsync<A>> fa, TryAsync<TryOptionAsync<B>> fb) =>
            default(ApplTryAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MTryAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>((TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, C> project) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b).AsTask())));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<TryOptionAsync<B>>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, async a =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(await bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, a =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>).BindAsync<MTryOptionAsync<TryOptionAsync<C>>, TryOptionAsync<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(bind(a), b =>
            default(MTryOptionAsync<C>).ReturnAsync(project(a, b))));


        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> Where< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> Where< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> Select< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).SumAsync(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).CountAsync(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> BindT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> BindT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<TryOptionAsync<B>>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> BindT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, Task<TryOptionAsync<TryOptionAsync<B>>>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> Traverse< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> Sequence< A>(this TryOptionAsync<TryOptionAsync<A>> ma) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SequenceAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> MapT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> MapT< A, B>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> FilterT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> FilterT< A>(this TryOptionAsync<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).ZeroAsync());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> PlusT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> ProductT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> DivideT<NUM,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryOptionAsync<A>> fa) =>
            default(ApplTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MTryOptionAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, TryOptionAsync<B>>>((TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryOptionAsync<A>> fa, TryOptionAsync<TryOptionAsync<B>> fb) =>
            default(ApplTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MTryOptionAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>((TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b))), fa, fb);

    }
}
