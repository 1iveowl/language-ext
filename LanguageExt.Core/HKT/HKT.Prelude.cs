using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Arr<A>> ma) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> bindT< A, B>(Arr<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Arr<B>>`</returns>
        [Pure]
        public static Arr<Arr<B>> traverse< A, B>(Arr<Arr<A>> ma, Func<A, B> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Arr<A>>`</returns>
        [Pure]
        public static Arr<Arr<A>> sequence< A>(Arr<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> mapT< A, B>(Arr<Arr<A>> ma, Func<A, B> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Arr<A>> ma, Action<A> f) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Arr<A>> filterT< A>(Arr<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Arr<A>> plusT<NUM,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Arr<A>> subtractT<NUM,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Arr<A>> productT<NUM,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Arr<A>> divideT<NUM,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Arr<A>> appendT<SEMI,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Arr<A>> x, Arr<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Arr<A>>`</param>
        /// <returns>`Arr<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Arr<B>> applyT< A, B>(Func<A, B> fab, Arr<Arr<A>> fa) =>
            ApplArr< Arr<A>, Arr<B>>.Inst.Apply(
                 MArr< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Arr<A>>`</param>
        /// <param name="fb">Monad of `Arr<Arr<A>>`</param>
        /// <returns>`Arr<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Arr<A>> fa, Arr<Arr<B>> fb) =>
            ApplArr< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MArr< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<HashSet<A>> ma) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> bindT< A, B>(Arr<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Arr<B>>`</returns>
        [Pure]
        public static HashSet<Arr<B>> traverse< A, B>(Arr<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Arr<A>>`</returns>
        [Pure]
        public static HashSet<Arr<A>> sequence< A>(Arr<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> mapT< A, B>(Arr<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<HashSet<A>> ma, Action<A> f) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<HashSet<A>> filterT< A>(Arr<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<HashSet<A>> plusT<NUM,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<HashSet<A>> subtractT<NUM,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<HashSet<A>> productT<NUM,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<HashSet<A>> divideT<NUM,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<HashSet<A>> appendT<SEMI,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<HashSet<A>> x, Arr<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<HashSet<A>>`</param>
        /// <returns>`Arr<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<HashSet<B>> applyT< A, B>(Func<A, B> fab, Arr<HashSet<A>> fa) =>
            ApplArr< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MArr< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Arr<HashSet<A>>`</param>
        /// <returns>`Arr<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<HashSet<A>> fa, Arr<HashSet<B>> fb) =>
            ApplArr< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MArr< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Lst<A>> ma) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> bindT< A, B>(Arr<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Arr<B>>`</returns>
        [Pure]
        public static Lst<Arr<B>> traverse< A, B>(Arr<Lst<A>> ma, Func<A, B> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Arr<A>>`</returns>
        [Pure]
        public static Lst<Arr<A>> sequence< A>(Arr<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> mapT< A, B>(Arr<Lst<A>> ma, Func<A, B> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Lst<A>> ma, Action<A> f) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Lst<A>> filterT< A>(Arr<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Lst<A>> plusT<NUM,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Lst<A>> subtractT<NUM,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Lst<A>> productT<NUM,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Lst<A>> divideT<NUM,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Lst<A>> appendT<SEMI,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Lst<A>> x, Arr<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Lst<A>>`</param>
        /// <returns>`Arr<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Lst<B>> applyT< A, B>(Func<A, B> fab, Arr<Lst<A>> fa) =>
            ApplArr< Lst<A>, Lst<B>>.Inst.Apply(
                 MArr< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Lst<A>>`</param>
        /// <param name="fb">Monad of `Arr<Lst<A>>`</param>
        /// <returns>`Arr<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Lst<A>> fa, Arr<Lst<B>> fb) =>
            ApplArr< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MArr< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Option<A>> ma) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> bindT< A, B>(Arr<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Arr<B>>`</returns>
        [Pure]
        public static Option<Arr<B>> traverse< A, B>(Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Arr<A>>`</returns>
        [Pure]
        public static Option<Arr<A>> sequence< A>(Arr<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> mapT< A, B>(Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Option<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Option<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Option<A>> ma, Action<A> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Option<A>> filterT< A>(Arr<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Option<A>> plusT<NUM,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Option<A>> subtractT<NUM,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Option<A>> productT<NUM,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Option<A>> divideT<NUM,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Option<A>> appendT<SEMI,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Option<A>> x, Arr<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Option<A>>`</param>
        /// <returns>`Arr<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Option<B>> applyT< A, B>(Func<A, B> fab, Arr<Option<A>> fa) =>
            ApplArr< Option<A>, Option<B>>.Inst.Apply(
                 MArr< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Option<A>>`</param>
        /// <param name="fb">Monad of `Arr<Option<A>>`</param>
        /// <returns>`Arr<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Option<A>> fa, Arr<Option<B>> fb) =>
            ApplArr< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MArr< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<OptionAsync<A>> ma) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> bindT< A, B>(Arr<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Arr<B>>`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> traverse< A, B>(Arr<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Arr<A>>`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> sequence< A>(Arr<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> mapT< A, B>(Arr<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionAsync<A>> filterT< A>(Arr<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<OptionAsync<A>> plusT<NUM,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<OptionAsync<A>> subtractT<NUM,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> productT<NUM,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> divideT<NUM,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> appendT<SEMI,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<OptionAsync<A>>`</param>
        /// <returns>`Arr<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Arr<OptionAsync<A>> fa) =>
            ApplArr< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MArr< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Arr<OptionAsync<A>>`</param>
        /// <returns>`Arr<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<OptionAsync<A>> fa, Arr<OptionAsync<B>> fb) =>
            ApplArr< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MArr< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<OptionUnsafe<A>> ma) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> bindT< A, B>(Arr<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Arr<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> traverse< A, B>(Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Arr<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> sequence< A>(Arr<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> mapT< A, B>(Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> filterT< A>(Arr<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> plusT<NUM,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> subtractT<NUM,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> productT<NUM,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> divideT<NUM,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> appendT<SEMI,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<OptionUnsafe<A>>`</param>
        /// <returns>`Arr<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Arr<OptionUnsafe<A>> fa) =>
            ApplArr< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MArr< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Arr<OptionUnsafe<A>>`</param>
        /// <returns>`Arr<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<OptionUnsafe<A>> fa, Arr<OptionUnsafe<B>> fb) =>
            ApplArr< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MArr< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Arr<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Arr<Either<L, A>> ma) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> bindT<L, A, B>(Arr<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Arr<B>>`</returns>
        [Pure]
        public static Either<L, Arr<B>> traverse<L, A, B>(Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Arr<A>>`</returns>
        [Pure]
        public static Either<L, Arr<A>> sequence<L, A>(Arr<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> mapT<L, A, B>(Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Arr<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Arr<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Arr<Either<L, A>> ma, Action<A> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Either<L, A>> filterT<L, A>(Arr<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Either<L, A>> plusT<NUM, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Either<L, A>> subtractT<NUM, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Either<L, A>> productT<NUM, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Either<L, A>> divideT<NUM, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Either<L, A>> appendT<SEMI, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Arr<Either<L, A>> x, Arr<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Either<L, A>>`</param>
        /// <returns>`Arr<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Arr<Either<L, A>> fa) =>
            ApplArr< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MArr< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Arr<Either<L, A>>`</param>
        /// <returns>`Arr<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Arr<Either<L, A>> fa, Arr<Either<L, B>> fb) =>
            ApplArr< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MArr< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Arr<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Arr<EitherUnsafe<L, A>> ma) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> bindT<L, A, B>(Arr<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Arr<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> traverse<L, A, B>(Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> sequence<L, A>(Arr<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> mapT<L, A, B>(Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Arr<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> filterT<L, A>(Arr<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> plusT<NUM, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> productT<NUM, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> divideT<NUM, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<EitherUnsafe<L, A>>`</param>
        /// <returns>`Arr<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Arr<EitherUnsafe<L, A>> fa) =>
            ApplArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MArr< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Arr<EitherUnsafe<L, A>>`</param>
        /// <returns>`Arr<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Arr<EitherUnsafe<L, A>> fa, Arr<EitherUnsafe<L, B>> fb) =>
            ApplArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MArr< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Task<A>> ma) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> bindT< A, B>(Arr<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Arr<B>>`</returns>
        [Pure]
        public static Task<Arr<B>> traverse< A, B>(Arr<Task<A>> ma, Func<A, B> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Arr<A>>`</returns>
        [Pure]
        public static Task<Arr<A>> sequence< A>(Arr<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> mapT< A, B>(Arr<Task<A>> ma, Func<A, B> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Task<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Task<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Task<A>> ma, Action<A> f) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Task<A>> filterT< A>(Arr<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Task<A>> plusT<NUM,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Task<A>> subtractT<NUM,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Task<A>> productT<NUM,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Task<A>> divideT<NUM,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Task<A>> appendT<SEMI,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Task<A>> x, Arr<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Task<A>>`</param>
        /// <returns>`Arr<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Task<B>> applyT< A, B>(Func<A, B> fab, Arr<Task<A>> fa) =>
            ApplArr< Task<A>, Task<B>>.Inst.Apply(
                 MArr< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Task<A>>`</param>
        /// <param name="fb">Monad of `Arr<Task<A>>`</param>
        /// <returns>`Arr<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Task<A>> fa, Arr<Task<B>> fb) =>
            ApplArr< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MArr< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Try<A>> ma) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> bindT< A, B>(Arr<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Arr<B>>`</returns>
        [Pure]
        public static Try<Arr<B>> traverse< A, B>(Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Arr<A>>`</returns>
        [Pure]
        public static Try<Arr<A>> sequence< A>(Arr<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> mapT< A, B>(Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Try<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Try<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Try<A>> ma, Action<A> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Try<A>> filterT< A>(Arr<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Try<A>> plusT<NUM,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Try<A>> subtractT<NUM,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Try<A>> productT<NUM,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Try<A>> divideT<NUM,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Try<A>> appendT<SEMI,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Try<A>> x, Arr<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Try<A>>`</param>
        /// <returns>`Arr<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Try<B>> applyT< A, B>(Func<A, B> fab, Arr<Try<A>> fa) =>
            ApplArr< Try<A>, Try<B>>.Inst.Apply(
                 MArr< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Try<A>>`</param>
        /// <param name="fb">Monad of `Arr<Try<A>>`</param>
        /// <returns>`Arr<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Try<A>> fa, Arr<Try<B>> fb) =>
            ApplArr< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MArr< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<TryAsync<A>> ma) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> bindT< A, B>(Arr<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Arr<B>>`</returns>
        [Pure]
        public static TryAsync<Arr<B>> traverse< A, B>(Arr<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Arr<A>>`</returns>
        [Pure]
        public static TryAsync<Arr<A>> sequence< A>(Arr<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> mapT< A, B>(Arr<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<TryAsync<A>> ma, Action<A> f) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> filterT< A>(Arr<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryAsync<A>> plusT<NUM,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryAsync<A>> subtractT<NUM,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> productT<NUM,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> divideT<NUM,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> appendT<SEMI,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<TryAsync<A>>`</param>
        /// <returns>`Arr<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Arr<TryAsync<A>> fa) =>
            ApplArr< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MArr< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Arr<TryAsync<A>>`</param>
        /// <returns>`Arr<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<TryAsync<A>> fa, Arr<TryAsync<B>> fb) =>
            ApplArr< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MArr< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<TryOption<A>> ma) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> bindT< A, B>(Arr<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Arr<B>>`</returns>
        [Pure]
        public static TryOption<Arr<B>> traverse< A, B>(Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Arr<A>>`</returns>
        [Pure]
        public static TryOption<Arr<A>> sequence< A>(Arr<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> mapT< A, B>(Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<TryOption<A>> ma, Action<A> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOption<A>> filterT< A>(Arr<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOption<A>> plusT<NUM,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOption<A>> subtractT<NUM,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryOption<A>> productT<NUM,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryOption<A>> divideT<NUM,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryOption<A>> appendT<SEMI,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<TryOption<A>> x, Arr<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<TryOption<A>>`</param>
        /// <returns>`Arr<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryOption<B>> applyT< A, B>(Func<A, B> fab, Arr<TryOption<A>> fa) =>
            ApplArr< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MArr< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Arr<TryOption<A>>`</param>
        /// <returns>`Arr<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<TryOption<A>> fa, Arr<TryOption<B>> fb) =>
            ApplArr< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MArr< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<TryOptionAsync<A>> ma) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> bindT< A, B>(Arr<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Arr<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> traverse< A, B>(Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Arr<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> sequence< A>(Arr<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> mapT< A, B>(Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> filterT< A>(Arr<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> plusT<NUM,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> subtractT<NUM,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> productT<NUM,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> divideT<NUM,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> appendT<SEMI,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<TryOptionAsync<A>>`</param>
        /// <returns>`Arr<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Arr<TryOptionAsync<A>> fa) =>
            ApplArr< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MArr< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Arr<TryOptionAsync<A>>`</param>
        /// <returns>`Arr<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<TryOptionAsync<A>> fa, Arr<TryOptionAsync<B>> fb) =>
            ApplArr< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MArr< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<IEnumerable<A>> ma) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> bindT< A, B>(Arr<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Arr<B>>`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> traverse< A, B>(Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Arr<A>>`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> sequence< A>(Arr<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> mapT< A, B>(Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<IEnumerable<A>> filterT< A>(Arr<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> plusT<NUM,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> subtractT<NUM,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> productT<NUM,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> divideT<NUM,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> appendT<SEMI,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<IEnumerable<A>>`</param>
        /// <returns>`Arr<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Arr<IEnumerable<A>> fa) =>
            ApplArr< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MArr< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Arr<IEnumerable<A>>`</param>
        /// <returns>`Arr<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<IEnumerable<A>> fa, Arr<IEnumerable<B>> fb) =>
            ApplArr< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MArr< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Arr<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Arr<Set<A>> ma) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> bindT< A, B>(Arr<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Arr<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Arr<B>>`</returns>
        [Pure]
        public static Set<Arr<B>> traverse< A, B>(Arr<Set<A>> ma, Func<A, B> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Arr<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Arr<A>>`</returns>
        [Pure]
        public static Set<Arr<A>> sequence< A>(Arr<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> mapT< A, B>(Arr<Set<A>> ma, Func<A, B> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Arr<Set<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Arr<Set<A>> ma, Func<A, bool> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Arr<Set<A>> ma, Action<A> f) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Set<A>> filterT< A>(Arr<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Set<A>> plusT<NUM,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Set<A>> subtractT<NUM,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Set<A>> productT<NUM,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Set<A>> divideT<NUM,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Set<A>> appendT<SEMI,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Arr<Set<A>> x, Arr<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr<Set<A>>`</param>
        /// <returns>`Arr<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Set<B>> applyT< A, B>(Func<A, B> fab, Arr<Set<A>> fa) =>
            ApplArr< Set<A>, Set<B>>.Inst.Apply(
                 MArr< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr<Set<A>>`</param>
        /// <param name="fb">Monad of `Arr<Set<A>>`</param>
        /// <returns>`Arr<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Arr<Set<A>> fa, Arr<Set<B>> fb) =>
            ApplArr< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MArr< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Arr<A>> ma) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> bindT< A, B>(HashSet<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<HashSet<B>>`</returns>
        [Pure]
        public static Arr<HashSet<B>> traverse< A, B>(HashSet<Arr<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<HashSet<A>>`</returns>
        [Pure]
        public static Arr<HashSet<A>> sequence< A>(HashSet<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> mapT< A, B>(HashSet<Arr<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Arr<A>> ma, Action<A> f) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Arr<A>> filterT< A>(HashSet<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Arr<A>> plusT<NUM,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Arr<A>> subtractT<NUM,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Arr<A>> productT<NUM,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Arr<A>> divideT<NUM,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Arr<A>> appendT<SEMI,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Arr<A>> x, HashSet<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Arr<A>>`</param>
        /// <returns>`HashSet<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Arr<B>> applyT< A, B>(Func<A, B> fab, HashSet<Arr<A>> fa) =>
            ApplHashSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MHashSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Arr<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Arr<A>>`</param>
        /// <returns>`HashSet<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Arr<A>> fa, HashSet<Arr<B>> fb) =>
            ApplHashSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MHashSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<HashSet<A>> ma) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> bindT< A, B>(HashSet<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<HashSet<B>>`</returns>
        [Pure]
        public static HashSet<HashSet<B>> traverse< A, B>(HashSet<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<HashSet<A>>`</returns>
        [Pure]
        public static HashSet<HashSet<A>> sequence< A>(HashSet<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> mapT< A, B>(HashSet<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<HashSet<A>> ma, Action<A> f) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<HashSet<A>> filterT< A>(HashSet<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<HashSet<A>> plusT<NUM,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<HashSet<A>> subtractT<NUM,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> productT<NUM,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> divideT<NUM,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> appendT<SEMI,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<HashSet<A>>`</param>
        /// <returns>`HashSet<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> applyT< A, B>(Func<A, B> fab, HashSet<HashSet<A>> fa) =>
            ApplHashSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MHashSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<HashSet<A>>`</param>
        /// <param name="fb">Monad of `HashSet<HashSet<A>>`</param>
        /// <returns>`HashSet<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<HashSet<A>> fa, HashSet<HashSet<B>> fb) =>
            ApplHashSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MHashSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Lst<A>> ma) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> bindT< A, B>(HashSet<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<HashSet<B>>`</returns>
        [Pure]
        public static Lst<HashSet<B>> traverse< A, B>(HashSet<Lst<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<HashSet<A>>`</returns>
        [Pure]
        public static Lst<HashSet<A>> sequence< A>(HashSet<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> mapT< A, B>(HashSet<Lst<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Lst<A>> ma, Action<A> f) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Lst<A>> filterT< A>(HashSet<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Lst<A>> plusT<NUM,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Lst<A>> subtractT<NUM,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Lst<A>> productT<NUM,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Lst<A>> divideT<NUM,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Lst<A>> appendT<SEMI,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Lst<A>> x, HashSet<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Lst<A>>`</param>
        /// <returns>`HashSet<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Lst<B>> applyT< A, B>(Func<A, B> fab, HashSet<Lst<A>> fa) =>
            ApplHashSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MHashSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Lst<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Lst<A>>`</param>
        /// <returns>`HashSet<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Lst<A>> fa, HashSet<Lst<B>> fb) =>
            ApplHashSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MHashSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Option<A>> ma) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> bindT< A, B>(HashSet<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<HashSet<B>>`</returns>
        [Pure]
        public static Option<HashSet<B>> traverse< A, B>(HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<HashSet<A>>`</returns>
        [Pure]
        public static Option<HashSet<A>> sequence< A>(HashSet<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> mapT< A, B>(HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Option<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Option<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Option<A>> ma, Action<A> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Option<A>> filterT< A>(HashSet<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Option<A>> plusT<NUM,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Option<A>> subtractT<NUM,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Option<A>> productT<NUM,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Option<A>> divideT<NUM,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Option<A>> appendT<SEMI,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Option<A>> x, HashSet<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Option<A>>`</param>
        /// <returns>`HashSet<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Option<B>> applyT< A, B>(Func<A, B> fab, HashSet<Option<A>> fa) =>
            ApplHashSet< Option<A>, Option<B>>.Inst.Apply(
                 MHashSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Option<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Option<A>>`</param>
        /// <returns>`HashSet<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Option<A>> fa, HashSet<Option<B>> fb) =>
            ApplHashSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MHashSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<OptionAsync<A>> ma) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> bindT< A, B>(HashSet<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<HashSet<B>>`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> traverse< A, B>(HashSet<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> sequence< A>(HashSet<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> mapT< A, B>(HashSet<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> filterT< A>(HashSet<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> plusT<NUM,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> subtractT<NUM,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> productT<NUM,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> divideT<NUM,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> appendT<SEMI,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<OptionAsync<A>>`</param>
        /// <returns>`HashSet<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, HashSet<OptionAsync<A>> fa) =>
            ApplHashSet< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MHashSet< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `HashSet<OptionAsync<A>>`</param>
        /// <returns>`HashSet<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<OptionAsync<A>> fa, HashSet<OptionAsync<B>> fb) =>
            ApplHashSet< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MHashSet< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<OptionUnsafe<A>> ma) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> bindT< A, B>(HashSet<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<HashSet<B>>`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> traverse< A, B>(HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<HashSet<A>>`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> sequence< A>(HashSet<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> mapT< A, B>(HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> filterT< A>(HashSet<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> plusT<NUM,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> subtractT<NUM,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> productT<NUM,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> divideT<NUM,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> appendT<SEMI,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<OptionUnsafe<A>>`</param>
        /// <returns>`HashSet<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, HashSet<OptionUnsafe<A>> fa) =>
            ApplHashSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MHashSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `HashSet<OptionUnsafe<A>>`</param>
        /// <returns>`HashSet<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<OptionUnsafe<A>> fa, HashSet<OptionUnsafe<B>> fb) =>
            ApplHashSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MHashSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(HashSet<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(HashSet<Either<L, A>> ma) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> bindT<L, A, B>(HashSet<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, HashSet<B>>`</returns>
        [Pure]
        public static Either<L, HashSet<B>> traverse<L, A, B>(HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, HashSet<A>>`</returns>
        [Pure]
        public static Either<L, HashSet<A>> sequence<L, A>(HashSet<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> mapT<L, A, B>(HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(HashSet<Either<L, A>> ma, Action<A> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Either<L, A>> filterT<L, A>(HashSet<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Either<L, A>> plusT<NUM, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Either<L, A>> subtractT<NUM, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> productT<NUM, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> divideT<NUM, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> appendT<SEMI, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Either<L, A>>`</param>
        /// <returns>`HashSet<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, HashSet<Either<L, A>> fa) =>
            ApplHashSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MHashSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Either<L, A>>`</param>
        /// <param name="fb">Monad of `HashSet<Either<L, A>>`</param>
        /// <returns>`HashSet<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, HashSet<Either<L, A>> fa, HashSet<Either<L, B>> fb) =>
            ApplHashSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MHashSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(HashSet<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(HashSet<EitherUnsafe<L, A>> ma) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> bindT<L, A, B>(HashSet<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, HashSet<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> traverse<L, A, B>(HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> sequence<L, A>(HashSet<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> mapT<L, A, B>(HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(HashSet<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> filterT<L, A>(HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> plusT<NUM, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> subtractT<NUM, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> productT<NUM, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> divideT<NUM, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> appendT<SEMI, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<EitherUnsafe<L, A>>`</param>
        /// <returns>`HashSet<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, HashSet<EitherUnsafe<L, A>> fa) =>
            ApplHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MHashSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `HashSet<EitherUnsafe<L, A>>`</param>
        /// <returns>`HashSet<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, HashSet<EitherUnsafe<L, A>> fa, HashSet<EitherUnsafe<L, B>> fb) =>
            ApplHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MHashSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Task<A>> ma) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> bindT< A, B>(HashSet<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<HashSet<B>>`</returns>
        [Pure]
        public static Task<HashSet<B>> traverse< A, B>(HashSet<Task<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<HashSet<A>>`</returns>
        [Pure]
        public static Task<HashSet<A>> sequence< A>(HashSet<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> mapT< A, B>(HashSet<Task<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Task<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Task<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Task<A>> ma, Action<A> f) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Task<A>> filterT< A>(HashSet<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Task<A>> plusT<NUM,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Task<A>> subtractT<NUM,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Task<A>> productT<NUM,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Task<A>> divideT<NUM,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Task<A>> appendT<SEMI,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Task<A>> x, HashSet<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Task<A>>`</param>
        /// <returns>`HashSet<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Task<B>> applyT< A, B>(Func<A, B> fab, HashSet<Task<A>> fa) =>
            ApplHashSet< Task<A>, Task<B>>.Inst.Apply(
                 MHashSet< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Task<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Task<A>>`</param>
        /// <returns>`HashSet<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Task<A>> fa, HashSet<Task<B>> fb) =>
            ApplHashSet< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MHashSet< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Try<A>> ma) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> bindT< A, B>(HashSet<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<HashSet<B>>`</returns>
        [Pure]
        public static Try<HashSet<B>> traverse< A, B>(HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<HashSet<A>>`</returns>
        [Pure]
        public static Try<HashSet<A>> sequence< A>(HashSet<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> mapT< A, B>(HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Try<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Try<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Try<A>> ma, Action<A> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Try<A>> filterT< A>(HashSet<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Try<A>> plusT<NUM,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Try<A>> subtractT<NUM,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Try<A>> productT<NUM,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Try<A>> divideT<NUM,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Try<A>> appendT<SEMI,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Try<A>> x, HashSet<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Try<A>>`</param>
        /// <returns>`HashSet<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Try<B>> applyT< A, B>(Func<A, B> fab, HashSet<Try<A>> fa) =>
            ApplHashSet< Try<A>, Try<B>>.Inst.Apply(
                 MHashSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Try<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Try<A>>`</param>
        /// <returns>`HashSet<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Try<A>> fa, HashSet<Try<B>> fb) =>
            ApplHashSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MHashSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<TryAsync<A>> ma) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> bindT< A, B>(HashSet<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<HashSet<B>>`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> traverse< A, B>(HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<HashSet<A>>`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> sequence< A>(HashSet<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> mapT< A, B>(HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<TryAsync<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> filterT< A>(HashSet<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> plusT<NUM,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> subtractT<NUM,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> productT<NUM,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> divideT<NUM,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> appendT<SEMI,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryAsync<A>>`</param>
        /// <returns>`HashSet<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> applyT< A, B>(Func<A, B> fab, HashSet<TryAsync<A>> fa) =>
            ApplHashSet< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MHashSet< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `HashSet<TryAsync<A>>`</param>
        /// <returns>`HashSet<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<TryAsync<A>> fa, HashSet<TryAsync<B>> fb) =>
            ApplHashSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MHashSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<TryOption<A>> ma) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> bindT< A, B>(HashSet<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<HashSet<B>>`</returns>
        [Pure]
        public static TryOption<HashSet<B>> traverse< A, B>(HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<HashSet<A>>`</returns>
        [Pure]
        public static TryOption<HashSet<A>> sequence< A>(HashSet<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> mapT< A, B>(HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<TryOption<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOption<A>> filterT< A>(HashSet<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOption<A>> plusT<NUM,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOption<A>> subtractT<NUM,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> productT<NUM,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> divideT<NUM,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> appendT<SEMI,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryOption<A>>`</param>
        /// <returns>`HashSet<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> applyT< A, B>(Func<A, B> fab, HashSet<TryOption<A>> fa) =>
            ApplHashSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MHashSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryOption<A>>`</param>
        /// <param name="fb">Monad of `HashSet<TryOption<A>>`</param>
        /// <returns>`HashSet<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<TryOption<A>> fa, HashSet<TryOption<B>> fb) =>
            ApplHashSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MHashSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<TryOptionAsync<A>> ma) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> bindT< A, B>(HashSet<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<HashSet<B>>`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> traverse< A, B>(HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> sequence< A>(HashSet<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> mapT< A, B>(HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> filterT< A>(HashSet<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> plusT<NUM,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> subtractT<NUM,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> productT<NUM,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> divideT<NUM,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> appendT<SEMI,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryOptionAsync<A>>`</param>
        /// <returns>`HashSet<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, HashSet<TryOptionAsync<A>> fa) =>
            ApplHashSet< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MHashSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `HashSet<TryOptionAsync<A>>`</param>
        /// <returns>`HashSet<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<TryOptionAsync<A>> fa, HashSet<TryOptionAsync<B>> fb) =>
            ApplHashSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MHashSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<IEnumerable<A>> ma) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> bindT< A, B>(HashSet<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<HashSet<B>>`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> traverse< A, B>(HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<HashSet<A>>`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> sequence< A>(HashSet<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> mapT< A, B>(HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> filterT< A>(HashSet<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> plusT<NUM,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> subtractT<NUM,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> productT<NUM,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> divideT<NUM,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> appendT<SEMI,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<IEnumerable<A>>`</param>
        /// <returns>`HashSet<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, HashSet<IEnumerable<A>> fa) =>
            ApplHashSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MHashSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `HashSet<IEnumerable<A>>`</param>
        /// <returns>`HashSet<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<IEnumerable<A>> fa, HashSet<IEnumerable<B>> fb) =>
            ApplHashSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MHashSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(HashSet<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(HashSet<Set<A>> ma) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> bindT< A, B>(HashSet<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<HashSet<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<HashSet<B>>`</returns>
        [Pure]
        public static Set<HashSet<B>> traverse< A, B>(HashSet<Set<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<HashSet<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<HashSet<A>>`</returns>
        [Pure]
        public static Set<HashSet<A>> sequence< A>(HashSet<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> mapT< A, B>(HashSet<Set<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(HashSet<Set<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(HashSet<Set<A>> ma, Func<A, bool> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(HashSet<Set<A>> ma, Action<A> f) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Set<A>> filterT< A>(HashSet<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Set<A>> plusT<NUM,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Set<A>> subtractT<NUM,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Set<A>> productT<NUM,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Set<A>> divideT<NUM,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Set<A>> appendT<SEMI,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(HashSet<Set<A>> x, HashSet<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet<Set<A>>`</param>
        /// <returns>`HashSet<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Set<B>> applyT< A, B>(Func<A, B> fab, HashSet<Set<A>> fa) =>
            ApplHashSet< Set<A>, Set<B>>.Inst.Apply(
                 MHashSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet<Set<A>>`</param>
        /// <param name="fb">Monad of `HashSet<Set<A>>`</param>
        /// <returns>`HashSet<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, HashSet<Set<A>> fa, HashSet<Set<B>> fb) =>
            ApplHashSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MHashSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Arr<A>> ma) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> bindT< A, B>(Lst<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Lst<B>>`</returns>
        [Pure]
        public static Arr<Lst<B>> traverse< A, B>(Lst<Arr<A>> ma, Func<A, B> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Lst<A>>`</returns>
        [Pure]
        public static Arr<Lst<A>> sequence< A>(Lst<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> mapT< A, B>(Lst<Arr<A>> ma, Func<A, B> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Arr<A>> ma, Action<A> f) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Arr<A>> filterT< A>(Lst<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Arr<A>> plusT<NUM,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Arr<A>> subtractT<NUM,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Arr<A>> productT<NUM,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Arr<A>> divideT<NUM,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Arr<A>> appendT<SEMI,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Arr<A>> x, Lst<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Arr<A>>`</param>
        /// <returns>`Lst<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Arr<B>> applyT< A, B>(Func<A, B> fab, Lst<Arr<A>> fa) =>
            ApplLst< Arr<A>, Arr<B>>.Inst.Apply(
                 MLst< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Arr<A>>`</param>
        /// <param name="fb">Monad of `Lst<Arr<A>>`</param>
        /// <returns>`Lst<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Arr<A>> fa, Lst<Arr<B>> fb) =>
            ApplLst< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MLst< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<HashSet<A>> ma) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> bindT< A, B>(Lst<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Lst<B>>`</returns>
        [Pure]
        public static HashSet<Lst<B>> traverse< A, B>(Lst<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Lst<A>>`</returns>
        [Pure]
        public static HashSet<Lst<A>> sequence< A>(Lst<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> mapT< A, B>(Lst<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<HashSet<A>> ma, Action<A> f) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<HashSet<A>> filterT< A>(Lst<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<HashSet<A>> plusT<NUM,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<HashSet<A>> subtractT<NUM,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<HashSet<A>> productT<NUM,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<HashSet<A>> divideT<NUM,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<HashSet<A>> appendT<SEMI,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<HashSet<A>> x, Lst<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<HashSet<A>>`</param>
        /// <returns>`Lst<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<HashSet<B>> applyT< A, B>(Func<A, B> fab, Lst<HashSet<A>> fa) =>
            ApplLst< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MLst< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Lst<HashSet<A>>`</param>
        /// <returns>`Lst<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<HashSet<A>> fa, Lst<HashSet<B>> fb) =>
            ApplLst< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MLst< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Lst<A>> ma) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> bindT< A, B>(Lst<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Lst<B>>`</returns>
        [Pure]
        public static Lst<Lst<B>> traverse< A, B>(Lst<Lst<A>> ma, Func<A, B> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Lst<A>>`</returns>
        [Pure]
        public static Lst<Lst<A>> sequence< A>(Lst<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> mapT< A, B>(Lst<Lst<A>> ma, Func<A, B> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Lst<A>> ma, Action<A> f) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Lst<A>> filterT< A>(Lst<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Lst<A>> plusT<NUM,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Lst<A>> subtractT<NUM,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Lst<A>> productT<NUM,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Lst<A>> divideT<NUM,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Lst<A>> appendT<SEMI,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Lst<A>> x, Lst<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Lst<A>>`</param>
        /// <returns>`Lst<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Lst<B>> applyT< A, B>(Func<A, B> fab, Lst<Lst<A>> fa) =>
            ApplLst< Lst<A>, Lst<B>>.Inst.Apply(
                 MLst< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Lst<A>>`</param>
        /// <param name="fb">Monad of `Lst<Lst<A>>`</param>
        /// <returns>`Lst<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Lst<A>> fa, Lst<Lst<B>> fb) =>
            ApplLst< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MLst< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Option<A>> ma) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> bindT< A, B>(Lst<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Lst<B>>`</returns>
        [Pure]
        public static Option<Lst<B>> traverse< A, B>(Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Lst<A>>`</returns>
        [Pure]
        public static Option<Lst<A>> sequence< A>(Lst<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> mapT< A, B>(Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Option<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Option<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Option<A>> ma, Action<A> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Option<A>> filterT< A>(Lst<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Option<A>> plusT<NUM,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Option<A>> subtractT<NUM,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Option<A>> productT<NUM,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Option<A>> divideT<NUM,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Option<A>> appendT<SEMI,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Option<A>> x, Lst<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Option<A>>`</param>
        /// <returns>`Lst<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Option<B>> applyT< A, B>(Func<A, B> fab, Lst<Option<A>> fa) =>
            ApplLst< Option<A>, Option<B>>.Inst.Apply(
                 MLst< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Option<A>>`</param>
        /// <param name="fb">Monad of `Lst<Option<A>>`</param>
        /// <returns>`Lst<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Option<A>> fa, Lst<Option<B>> fb) =>
            ApplLst< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MLst< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<OptionAsync<A>> ma) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> bindT< A, B>(Lst<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Lst<B>>`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> traverse< A, B>(Lst<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Lst<A>>`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> sequence< A>(Lst<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> mapT< A, B>(Lst<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionAsync<A>> filterT< A>(Lst<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<OptionAsync<A>> plusT<NUM,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<OptionAsync<A>> subtractT<NUM,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> productT<NUM,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> divideT<NUM,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> appendT<SEMI,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<OptionAsync<A>>`</param>
        /// <returns>`Lst<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Lst<OptionAsync<A>> fa) =>
            ApplLst< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MLst< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Lst<OptionAsync<A>>`</param>
        /// <returns>`Lst<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<OptionAsync<A>> fa, Lst<OptionAsync<B>> fb) =>
            ApplLst< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MLst< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<OptionUnsafe<A>> ma) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> bindT< A, B>(Lst<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Lst<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> traverse< A, B>(Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Lst<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> sequence< A>(Lst<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> mapT< A, B>(Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> filterT< A>(Lst<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> plusT<NUM,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> subtractT<NUM,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> productT<NUM,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> divideT<NUM,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> appendT<SEMI,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<OptionUnsafe<A>>`</param>
        /// <returns>`Lst<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Lst<OptionUnsafe<A>> fa) =>
            ApplLst< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MLst< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Lst<OptionUnsafe<A>>`</param>
        /// <returns>`Lst<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<OptionUnsafe<A>> fa, Lst<OptionUnsafe<B>> fb) =>
            ApplLst< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MLst< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Lst<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Lst<Either<L, A>> ma) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> bindT<L, A, B>(Lst<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Lst<B>>`</returns>
        [Pure]
        public static Either<L, Lst<B>> traverse<L, A, B>(Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Lst<A>>`</returns>
        [Pure]
        public static Either<L, Lst<A>> sequence<L, A>(Lst<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> mapT<L, A, B>(Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Lst<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Lst<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Lst<Either<L, A>> ma, Action<A> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Either<L, A>> filterT<L, A>(Lst<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Either<L, A>> plusT<NUM, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Either<L, A>> subtractT<NUM, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Either<L, A>> productT<NUM, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Either<L, A>> divideT<NUM, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Either<L, A>> appendT<SEMI, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Lst<Either<L, A>> x, Lst<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Either<L, A>>`</param>
        /// <returns>`Lst<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Lst<Either<L, A>> fa) =>
            ApplLst< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MLst< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Lst<Either<L, A>>`</param>
        /// <returns>`Lst<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Lst<Either<L, A>> fa, Lst<Either<L, B>> fb) =>
            ApplLst< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MLst< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Lst<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Lst<EitherUnsafe<L, A>> ma) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> bindT<L, A, B>(Lst<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Lst<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> traverse<L, A, B>(Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> sequence<L, A>(Lst<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> mapT<L, A, B>(Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Lst<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> filterT<L, A>(Lst<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> plusT<NUM, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> productT<NUM, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> divideT<NUM, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<EitherUnsafe<L, A>>`</param>
        /// <returns>`Lst<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Lst<EitherUnsafe<L, A>> fa) =>
            ApplLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MLst< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Lst<EitherUnsafe<L, A>>`</param>
        /// <returns>`Lst<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Lst<EitherUnsafe<L, A>> fa, Lst<EitherUnsafe<L, B>> fb) =>
            ApplLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MLst< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Task<A>> ma) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> bindT< A, B>(Lst<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Lst<B>>`</returns>
        [Pure]
        public static Task<Lst<B>> traverse< A, B>(Lst<Task<A>> ma, Func<A, B> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Lst<A>>`</returns>
        [Pure]
        public static Task<Lst<A>> sequence< A>(Lst<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> mapT< A, B>(Lst<Task<A>> ma, Func<A, B> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Task<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Task<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Task<A>> ma, Action<A> f) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Task<A>> filterT< A>(Lst<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Task<A>> plusT<NUM,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Task<A>> subtractT<NUM,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Task<A>> productT<NUM,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Task<A>> divideT<NUM,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Task<A>> appendT<SEMI,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Task<A>> x, Lst<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Task<A>>`</param>
        /// <returns>`Lst<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Task<B>> applyT< A, B>(Func<A, B> fab, Lst<Task<A>> fa) =>
            ApplLst< Task<A>, Task<B>>.Inst.Apply(
                 MLst< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Task<A>>`</param>
        /// <param name="fb">Monad of `Lst<Task<A>>`</param>
        /// <returns>`Lst<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Task<A>> fa, Lst<Task<B>> fb) =>
            ApplLst< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MLst< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Try<A>> ma) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> bindT< A, B>(Lst<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Lst<B>>`</returns>
        [Pure]
        public static Try<Lst<B>> traverse< A, B>(Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Lst<A>>`</returns>
        [Pure]
        public static Try<Lst<A>> sequence< A>(Lst<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> mapT< A, B>(Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Try<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Try<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Try<A>> ma, Action<A> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Try<A>> filterT< A>(Lst<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Try<A>> plusT<NUM,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Try<A>> subtractT<NUM,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Try<A>> productT<NUM,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Try<A>> divideT<NUM,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Try<A>> appendT<SEMI,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Try<A>> x, Lst<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Try<A>>`</param>
        /// <returns>`Lst<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Try<B>> applyT< A, B>(Func<A, B> fab, Lst<Try<A>> fa) =>
            ApplLst< Try<A>, Try<B>>.Inst.Apply(
                 MLst< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Try<A>>`</param>
        /// <param name="fb">Monad of `Lst<Try<A>>`</param>
        /// <returns>`Lst<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Try<A>> fa, Lst<Try<B>> fb) =>
            ApplLst< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MLst< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<TryAsync<A>> ma) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> bindT< A, B>(Lst<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Lst<B>>`</returns>
        [Pure]
        public static TryAsync<Lst<B>> traverse< A, B>(Lst<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Lst<A>>`</returns>
        [Pure]
        public static TryAsync<Lst<A>> sequence< A>(Lst<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> mapT< A, B>(Lst<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<TryAsync<A>> ma, Action<A> f) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> filterT< A>(Lst<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryAsync<A>> plusT<NUM,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryAsync<A>> subtractT<NUM,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> productT<NUM,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> divideT<NUM,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> appendT<SEMI,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<TryAsync<A>>`</param>
        /// <returns>`Lst<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Lst<TryAsync<A>> fa) =>
            ApplLst< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MLst< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Lst<TryAsync<A>>`</param>
        /// <returns>`Lst<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<TryAsync<A>> fa, Lst<TryAsync<B>> fb) =>
            ApplLst< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MLst< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<TryOption<A>> ma) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> bindT< A, B>(Lst<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Lst<B>>`</returns>
        [Pure]
        public static TryOption<Lst<B>> traverse< A, B>(Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Lst<A>>`</returns>
        [Pure]
        public static TryOption<Lst<A>> sequence< A>(Lst<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> mapT< A, B>(Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<TryOption<A>> ma, Action<A> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOption<A>> filterT< A>(Lst<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOption<A>> plusT<NUM,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOption<A>> subtractT<NUM,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryOption<A>> productT<NUM,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryOption<A>> divideT<NUM,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryOption<A>> appendT<SEMI,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<TryOption<A>> x, Lst<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<TryOption<A>>`</param>
        /// <returns>`Lst<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryOption<B>> applyT< A, B>(Func<A, B> fab, Lst<TryOption<A>> fa) =>
            ApplLst< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MLst< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Lst<TryOption<A>>`</param>
        /// <returns>`Lst<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<TryOption<A>> fa, Lst<TryOption<B>> fb) =>
            ApplLst< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MLst< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<TryOptionAsync<A>> ma) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> bindT< A, B>(Lst<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Lst<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> traverse< A, B>(Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Lst<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> sequence< A>(Lst<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> mapT< A, B>(Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> filterT< A>(Lst<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> plusT<NUM,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> subtractT<NUM,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> productT<NUM,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> divideT<NUM,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> appendT<SEMI,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<TryOptionAsync<A>>`</param>
        /// <returns>`Lst<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Lst<TryOptionAsync<A>> fa) =>
            ApplLst< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MLst< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Lst<TryOptionAsync<A>>`</param>
        /// <returns>`Lst<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<TryOptionAsync<A>> fa, Lst<TryOptionAsync<B>> fb) =>
            ApplLst< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MLst< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<IEnumerable<A>> ma) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> bindT< A, B>(Lst<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Lst<B>>`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> traverse< A, B>(Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Lst<A>>`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> sequence< A>(Lst<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> mapT< A, B>(Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<IEnumerable<A>> filterT< A>(Lst<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> plusT<NUM,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> subtractT<NUM,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> productT<NUM,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> divideT<NUM,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> appendT<SEMI,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<IEnumerable<A>>`</param>
        /// <returns>`Lst<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Lst<IEnumerable<A>> fa) =>
            ApplLst< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MLst< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Lst<IEnumerable<A>>`</param>
        /// <returns>`Lst<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<IEnumerable<A>> fa, Lst<IEnumerable<B>> fb) =>
            ApplLst< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MLst< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Lst<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Lst<Set<A>> ma) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> bindT< A, B>(Lst<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Lst<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Lst<B>>`</returns>
        [Pure]
        public static Set<Lst<B>> traverse< A, B>(Lst<Set<A>> ma, Func<A, B> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Lst<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Lst<A>>`</returns>
        [Pure]
        public static Set<Lst<A>> sequence< A>(Lst<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> mapT< A, B>(Lst<Set<A>> ma, Func<A, B> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Lst<Set<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Lst<Set<A>> ma, Func<A, bool> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Lst<Set<A>> ma, Action<A> f) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Set<A>> filterT< A>(Lst<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Set<A>> plusT<NUM,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Set<A>> subtractT<NUM,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Set<A>> productT<NUM,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Set<A>> divideT<NUM,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Set<A>> appendT<SEMI,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Lst<Set<A>> x, Lst<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst<Set<A>>`</param>
        /// <returns>`Lst<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Set<B>> applyT< A, B>(Func<A, B> fab, Lst<Set<A>> fa) =>
            ApplLst< Set<A>, Set<B>>.Inst.Apply(
                 MLst< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst<Set<A>>`</param>
        /// <param name="fb">Monad of `Lst<Set<A>>`</param>
        /// <returns>`Lst<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Lst<Set<A>> fa, Lst<Set<B>> fb) =>
            ApplLst< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MLst< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Arr<A>> ma) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> bindT< A, B>(Option<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Option<B>>`</returns>
        [Pure]
        public static Arr<Option<B>> traverse< A, B>(Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Option<A>>`</returns>
        [Pure]
        public static Arr<Option<A>> sequence< A>(Option<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> mapT< A, B>(Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Arr<A>> ma, Action<A> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Arr<A>> filterT< A>(Option<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Arr<A>> plusT<NUM,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Arr<A>> subtractT<NUM,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Arr<A>> productT<NUM,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Arr<A>> divideT<NUM,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Arr<A>> appendT<SEMI,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Arr<A>> x, Option<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Arr<A>>`</param>
        /// <returns>`Option<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Arr<B>> applyT< A, B>(Func<A, B> fab, Option<Arr<A>> fa) =>
            ApplOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Arr<A>>`</param>
        /// <param name="fb">Monad of `Option<Arr<A>>`</param>
        /// <returns>`Option<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Arr<A>> fa, Option<Arr<B>> fb) =>
            ApplOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<HashSet<A>> ma) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> bindT< A, B>(Option<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Option<B>>`</returns>
        [Pure]
        public static HashSet<Option<B>> traverse< A, B>(Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Option<A>>`</returns>
        [Pure]
        public static HashSet<Option<A>> sequence< A>(Option<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> mapT< A, B>(Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<HashSet<A>> ma, Action<A> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<HashSet<A>> filterT< A>(Option<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<HashSet<A>> plusT<NUM,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<HashSet<A>> subtractT<NUM,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<HashSet<A>> productT<NUM,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<HashSet<A>> divideT<NUM,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<HashSet<A>> appendT<SEMI,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<HashSet<A>> x, Option<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<HashSet<A>>`</param>
        /// <returns>`Option<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<HashSet<B>> applyT< A, B>(Func<A, B> fab, Option<HashSet<A>> fa) =>
            ApplOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Option<HashSet<A>>`</param>
        /// <returns>`Option<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<HashSet<A>> fa, Option<HashSet<B>> fb) =>
            ApplOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Lst<A>> ma) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> bindT< A, B>(Option<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Option<B>>`</returns>
        [Pure]
        public static Lst<Option<B>> traverse< A, B>(Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Option<A>>`</returns>
        [Pure]
        public static Lst<Option<A>> sequence< A>(Option<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> mapT< A, B>(Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Lst<A>> ma, Action<A> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Lst<A>> filterT< A>(Option<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Lst<A>> plusT<NUM,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Lst<A>> subtractT<NUM,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Lst<A>> productT<NUM,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Lst<A>> divideT<NUM,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Lst<A>> appendT<SEMI,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Lst<A>> x, Option<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Lst<A>>`</param>
        /// <returns>`Option<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Lst<B>> applyT< A, B>(Func<A, B> fab, Option<Lst<A>> fa) =>
            ApplOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Lst<A>>`</param>
        /// <param name="fb">Monad of `Option<Lst<A>>`</param>
        /// <returns>`Option<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Lst<A>> fa, Option<Lst<B>> fb) =>
            ApplOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Option<A>> ma) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> bindT< A, B>(Option<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Option<B>>`</returns>
        [Pure]
        public static Option<Option<B>> traverse< A, B>(Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Option<A>>`</returns>
        [Pure]
        public static Option<Option<A>> sequence< A>(Option<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> mapT< A, B>(Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Option<A>> ma, Action<A> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Option<A>> filterT< A>(Option<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Option<A>> plusT<NUM,  A>(Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Option<A>> subtractT<NUM,  A>(Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Option<A>> productT<NUM,  A>(Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Option<A>> divideT<NUM,  A>(Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Option<A>> appendT<SEMI,  A>(Option<Option<A>> x, Option<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Option<A>> x, Option<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Option<A>> x, Option<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Option<A>>`</param>
        /// <returns>`Option<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Option<B>> applyT< A, B>(Func<A, B> fab, Option<Option<A>> fa) =>
            ApplOption< Option<A>, Option<B>>.Inst.Apply(
                 MOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Option<A>>`</param>
        /// <param name="fb">Monad of `Option<Option<A>>`</param>
        /// <returns>`Option<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Option<A>> fa, Option<Option<B>> fb) =>
            ApplOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<OptionAsync<A>> ma) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> bindT< A, B>(Option<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Option<B>>`</returns>
        [Pure]
        public static OptionAsync<Option<B>> traverse< A, B>(Option<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Option<A>>`</returns>
        [Pure]
        public static OptionAsync<Option<A>> sequence< A>(Option<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> mapT< A, B>(Option<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionAsync<A>> filterT< A>(Option<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<OptionAsync<A>> plusT<NUM,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<OptionAsync<A>> subtractT<NUM,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> productT<NUM,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> divideT<NUM,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> appendT<SEMI,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<OptionAsync<A>>`</param>
        /// <returns>`Option<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Option<OptionAsync<A>> fa) =>
            ApplOption< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MOption< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Option<OptionAsync<A>>`</param>
        /// <returns>`Option<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<OptionAsync<A>> fa, Option<OptionAsync<B>> fb) =>
            ApplOption< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MOption< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<OptionUnsafe<A>> ma) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> bindT< A, B>(Option<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Option<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> traverse< A, B>(Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Option<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> sequence< A>(Option<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> mapT< A, B>(Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> filterT< A>(Option<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> plusT<NUM,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> subtractT<NUM,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> productT<NUM,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> divideT<NUM,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> appendT<SEMI,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<OptionUnsafe<A>>`</param>
        /// <returns>`Option<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Option<OptionUnsafe<A>> fa) =>
            ApplOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Option<OptionUnsafe<A>>`</param>
        /// <returns>`Option<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<OptionUnsafe<A>> fa, Option<OptionUnsafe<B>> fb) =>
            ApplOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Option<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Option<Either<L, A>> ma) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> bindT<L, A, B>(Option<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Option<B>>`</returns>
        [Pure]
        public static Either<L, Option<B>> traverse<L, A, B>(Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Option<A>>`</returns>
        [Pure]
        public static Either<L, Option<A>> sequence<L, A>(Option<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> mapT<L, A, B>(Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Option<Either<L, A>> ma, Action<A> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Either<L, A>> filterT<L, A>(Option<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Either<L, A>> plusT<NUM, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Either<L, A>> subtractT<NUM, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Either<L, A>> productT<NUM, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Either<L, A>> divideT<NUM, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Either<L, A>> appendT<SEMI, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Option<Either<L, A>> x, Option<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Either<L, A>>`</param>
        /// <returns>`Option<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Option<Either<L, A>> fa) =>
            ApplOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Option<Either<L, A>>`</param>
        /// <returns>`Option<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Option<Either<L, A>> fa, Option<Either<L, B>> fb) =>
            ApplOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Option<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Option<EitherUnsafe<L, A>> ma) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> bindT<L, A, B>(Option<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Option<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> traverse<L, A, B>(Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Option<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> sequence<L, A>(Option<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> mapT<L, A, B>(Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Option<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> filterT<L, A>(Option<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> plusT<NUM, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> productT<NUM, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> divideT<NUM, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<EitherUnsafe<L, A>>`</param>
        /// <returns>`Option<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Option<EitherUnsafe<L, A>> fa) =>
            ApplOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Option<EitherUnsafe<L, A>>`</param>
        /// <returns>`Option<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Option<EitherUnsafe<L, A>> fa, Option<EitherUnsafe<L, B>> fb) =>
            ApplOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Task<A>> ma) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> bindT< A, B>(Option<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Option<B>>`</returns>
        [Pure]
        public static Task<Option<B>> traverse< A, B>(Option<Task<A>> ma, Func<A, B> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Option<A>>`</returns>
        [Pure]
        public static Task<Option<A>> sequence< A>(Option<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> mapT< A, B>(Option<Task<A>> ma, Func<A, B> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Task<A>> ma, Action<A> f) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Task<A>> filterT< A>(Option<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Task<A>> plusT<NUM,  A>(Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Task<A>> subtractT<NUM,  A>(Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Task<A>> productT<NUM,  A>(Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Task<A>> divideT<NUM,  A>(Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Task<A>> appendT<SEMI,  A>(Option<Task<A>> x, Option<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Task<A>> x, Option<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Task<A>> x, Option<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Task<A>>`</param>
        /// <returns>`Option<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Task<B>> applyT< A, B>(Func<A, B> fab, Option<Task<A>> fa) =>
            ApplOption< Task<A>, Task<B>>.Inst.Apply(
                 MOption< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Task<A>>`</param>
        /// <param name="fb">Monad of `Option<Task<A>>`</param>
        /// <returns>`Option<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Task<A>> fa, Option<Task<B>> fb) =>
            ApplOption< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MOption< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Try<A>> ma) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> bindT< A, B>(Option<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Option<B>>`</returns>
        [Pure]
        public static Try<Option<B>> traverse< A, B>(Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Option<A>>`</returns>
        [Pure]
        public static Try<Option<A>> sequence< A>(Option<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> mapT< A, B>(Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Try<A>> ma, Action<A> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Try<A>> filterT< A>(Option<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Try<A>> plusT<NUM,  A>(Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Try<A>> subtractT<NUM,  A>(Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Try<A>> productT<NUM,  A>(Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Try<A>> divideT<NUM,  A>(Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Try<A>> appendT<SEMI,  A>(Option<Try<A>> x, Option<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Try<A>> x, Option<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Try<A>> x, Option<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Try<A>>`</param>
        /// <returns>`Option<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Try<B>> applyT< A, B>(Func<A, B> fab, Option<Try<A>> fa) =>
            ApplOption< Try<A>, Try<B>>.Inst.Apply(
                 MOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Try<A>>`</param>
        /// <param name="fb">Monad of `Option<Try<A>>`</param>
        /// <returns>`Option<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Try<A>> fa, Option<Try<B>> fb) =>
            ApplOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<TryAsync<A>> ma) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> bindT< A, B>(Option<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Option<B>>`</returns>
        [Pure]
        public static TryAsync<Option<B>> traverse< A, B>(Option<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Option<A>>`</returns>
        [Pure]
        public static TryAsync<Option<A>> sequence< A>(Option<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> mapT< A, B>(Option<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<TryAsync<A>> ma, Action<A> f) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryAsync<A>> filterT< A>(Option<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryAsync<A>> plusT<NUM,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryAsync<A>> subtractT<NUM,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryAsync<A>> productT<NUM,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryAsync<A>> divideT<NUM,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryAsync<A>> appendT<SEMI,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<TryAsync<A>> x, Option<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<TryAsync<A>>`</param>
        /// <returns>`Option<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Option<TryAsync<A>> fa) =>
            ApplOption< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MOption< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Option<TryAsync<A>>`</param>
        /// <returns>`Option<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<TryAsync<A>> fa, Option<TryAsync<B>> fb) =>
            ApplOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<TryOption<A>> ma) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> bindT< A, B>(Option<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Option<B>>`</returns>
        [Pure]
        public static TryOption<Option<B>> traverse< A, B>(Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Option<A>>`</returns>
        [Pure]
        public static TryOption<Option<A>> sequence< A>(Option<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> mapT< A, B>(Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<TryOption<A>> ma, Action<A> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOption<A>> filterT< A>(Option<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOption<A>> plusT<NUM,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOption<A>> subtractT<NUM,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryOption<A>> productT<NUM,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryOption<A>> divideT<NUM,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryOption<A>> appendT<SEMI,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<TryOption<A>> x, Option<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<TryOption<A>>`</param>
        /// <returns>`Option<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryOption<B>> applyT< A, B>(Func<A, B> fab, Option<TryOption<A>> fa) =>
            ApplOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Option<TryOption<A>>`</param>
        /// <returns>`Option<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<TryOption<A>> fa, Option<TryOption<B>> fb) =>
            ApplOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<TryOptionAsync<A>> ma) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> bindT< A, B>(Option<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Option<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> traverse< A, B>(Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Option<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> sequence< A>(Option<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> mapT< A, B>(Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> filterT< A>(Option<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> plusT<NUM,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> subtractT<NUM,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> productT<NUM,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> divideT<NUM,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> appendT<SEMI,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<TryOptionAsync<A>>`</param>
        /// <returns>`Option<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Option<TryOptionAsync<A>> fa) =>
            ApplOption< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Option<TryOptionAsync<A>>`</param>
        /// <returns>`Option<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<TryOptionAsync<A>> fa, Option<TryOptionAsync<B>> fb) =>
            ApplOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<IEnumerable<A>> ma) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> bindT< A, B>(Option<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Option<B>>`</returns>
        [Pure]
        public static IEnumerable<Option<B>> traverse< A, B>(Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Option<A>>`</returns>
        [Pure]
        public static IEnumerable<Option<A>> sequence< A>(Option<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> mapT< A, B>(Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<IEnumerable<A>> filterT< A>(Option<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<IEnumerable<A>> plusT<NUM,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<IEnumerable<A>> subtractT<NUM,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> productT<NUM,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> divideT<NUM,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> appendT<SEMI,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<IEnumerable<A>>`</param>
        /// <returns>`Option<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Option<IEnumerable<A>> fa) =>
            ApplOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Option<IEnumerable<A>>`</param>
        /// <returns>`Option<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<IEnumerable<A>> fa, Option<IEnumerable<B>> fb) =>
            ApplOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Option<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Option<Set<A>> ma) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> bindT< A, B>(Option<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Option<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Option<B>>`</returns>
        [Pure]
        public static Set<Option<B>> traverse< A, B>(Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Option<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Option<A>>`</returns>
        [Pure]
        public static Set<Option<A>> sequence< A>(Option<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> mapT< A, B>(Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Option<Set<A>> ma, Action<A> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Set<A>> filterT< A>(Option<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Set<A>> plusT<NUM,  A>(Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Set<A>> subtractT<NUM,  A>(Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Set<A>> productT<NUM,  A>(Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Set<A>> divideT<NUM,  A>(Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Set<A>> appendT<SEMI,  A>(Option<Set<A>> x, Option<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Option<Set<A>> x, Option<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Option<Set<A>> x, Option<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option<Set<A>>`</param>
        /// <returns>`Option<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Set<B>> applyT< A, B>(Func<A, B> fab, Option<Set<A>> fa) =>
            ApplOption< Set<A>, Set<B>>.Inst.Apply(
                 MOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option<Set<A>>`</param>
        /// <param name="fb">Monad of `Option<Set<A>>`</param>
        /// <returns>`Option<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Option<Set<A>> fa, Option<Set<B>> fb) =>
            ApplOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Arr<A>> ma) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> bindT< A, B>(OptionAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionAsync<B>>`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> traverse< A, B>(OptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionAsync<A>>`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> sequence< A>(OptionAsync<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> mapT< A, B>(OptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Arr<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Arr<A>> filterT< A>(OptionAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Arr<A>> plusT<NUM,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Arr<A>> subtractT<NUM,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> productT<NUM,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> divideT<NUM,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> appendT<SEMI,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Arr<A>>`</param>
        /// <returns>`OptionAsync<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Arr<A>> fa) =>
            ApplOptionAsync< Arr<A>, Arr<B>>.Inst.Apply(
                 MOptionAsync< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Arr<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Arr<A>>`</param>
        /// <returns>`OptionAsync<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Arr<A>> fa, OptionAsync<Arr<B>> fb) =>
            ApplOptionAsync< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOptionAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<HashSet<A>> ma) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> bindT< A, B>(OptionAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionAsync<B>>`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> traverse< A, B>(OptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionAsync<A>>`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> sequence< A>(OptionAsync<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> mapT< A, B>(OptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<HashSet<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> filterT< A>(OptionAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> plusT<NUM,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> subtractT<NUM,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> productT<NUM,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> divideT<NUM,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> appendT<SEMI,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<HashSet<A>>`</param>
        /// <returns>`OptionAsync<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<HashSet<A>> fa) =>
            ApplOptionAsync< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOptionAsync< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<HashSet<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<HashSet<A>>`</param>
        /// <returns>`OptionAsync<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<HashSet<A>> fa, OptionAsync<HashSet<B>> fb) =>
            ApplOptionAsync< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOptionAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Lst<A>> ma) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> bindT< A, B>(OptionAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionAsync<B>>`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> traverse< A, B>(OptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionAsync<A>>`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> sequence< A>(OptionAsync<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> mapT< A, B>(OptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Lst<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Lst<A>> filterT< A>(OptionAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Lst<A>> plusT<NUM,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Lst<A>> subtractT<NUM,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> productT<NUM,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> divideT<NUM,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> appendT<SEMI,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Lst<A>>`</param>
        /// <returns>`OptionAsync<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Lst<A>> fa) =>
            ApplOptionAsync< Lst<A>, Lst<B>>.Inst.Apply(
                 MOptionAsync< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Lst<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Lst<A>>`</param>
        /// <returns>`OptionAsync<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Lst<A>> fa, OptionAsync<Lst<B>> fb) =>
            ApplOptionAsync< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOptionAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Option<A>> ma) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> bindT< A, B>(OptionAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionAsync<B>>`</returns>
        [Pure]
        public static Option<OptionAsync<B>> traverse< A, B>(OptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionAsync<A>>`</returns>
        [Pure]
        public static Option<OptionAsync<A>> sequence< A>(OptionAsync<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> mapT< A, B>(OptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Option<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Option<A>> filterT< A>(OptionAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Option<A>> plusT<NUM,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Option<A>> subtractT<NUM,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> productT<NUM,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> divideT<NUM,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> appendT<SEMI,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Option<A>>`</param>
        /// <returns>`OptionAsync<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Option<A>> fa) =>
            ApplOptionAsync< Option<A>, Option<B>>.Inst.Apply(
                 MOptionAsync< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Option<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Option<A>>`</param>
        /// <returns>`OptionAsync<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Option<A>> fa, OptionAsync<Option<B>> fb) =>
            ApplOptionAsync< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOptionAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<OptionAsync<A>> ma) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> bindT< A, B>(OptionAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionAsync<B>>`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> traverse< A, B>(OptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> sequence< A>(OptionAsync<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> mapT< A, B>(OptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MOptionAsync<OptionAsync<B>>, OptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> filterT< A>(OptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOptionAsync<OptionAsync<A>>, OptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> plusT<NUM,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> subtractT<NUM,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> productT<NUM,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> divideT<NUM,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<A>> appendT<SEMI,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<OptionAsync<A>> x, OptionAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<OptionAsync<A>>`</param>
        /// <returns>`OptionAsync<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<OptionAsync<A>> fa) =>
            ApplOptionAsync< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MOptionAsync< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<OptionAsync<A>>`</param>
        /// <returns>`OptionAsync<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<OptionAsync<A>> fa, OptionAsync<OptionAsync<B>> fb) =>
            ApplOptionAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MOptionAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<OptionUnsafe<A>> ma) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> bindT< A, B>(OptionAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionAsync<B>>`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> traverse< A, B>(OptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> sequence< A>(OptionAsync<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> mapT< A, B>(OptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> filterT< A>(OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> plusT<NUM,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> subtractT<NUM,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> productT<NUM,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> divideT<NUM,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> appendT<SEMI,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<OptionUnsafe<A>>`</param>
        /// <returns>`OptionAsync<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<OptionUnsafe<A>> fa) =>
            ApplOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOptionAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<OptionUnsafe<A>>`</param>
        /// <returns>`OptionAsync<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<OptionUnsafe<A>> fa, OptionAsync<OptionUnsafe<B>> fb) =>
            ApplOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOptionAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(OptionAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(OptionAsync<Either<L, A>> ma) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> bindT<L, A, B>(OptionAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionAsync<B>>`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> traverse<L, A, B>(OptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionAsync<A>>`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> sequence<L, A>(OptionAsync<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> mapT<L, A, B>(OptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(OptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(OptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(OptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(OptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(OptionAsync<Either<L, A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> filterT<L, A>(OptionAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> plusT<NUM, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> subtractT<NUM, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> productT<NUM, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> divideT<NUM, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> appendT<SEMI, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Either<L, A>>`</param>
        /// <returns>`OptionAsync<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, OptionAsync<Either<L, A>> fa) =>
            ApplOptionAsync< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOptionAsync< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Either<L, A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Either<L, A>>`</param>
        /// <returns>`OptionAsync<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, OptionAsync<Either<L, A>> fa, OptionAsync<Either<L, B>> fb) =>
            ApplOptionAsync< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOptionAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(OptionAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(OptionAsync<EitherUnsafe<L, A>> ma) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> bindT<L, A, B>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> traverse<L, A, B>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> sequence<L, A>(OptionAsync<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> mapT<L, A, B>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(OptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(OptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(OptionAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> filterT<L, A>(OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> plusT<NUM, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> subtractT<NUM, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> productT<NUM, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> divideT<NUM, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> appendT<SEMI, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, OptionAsync<EitherUnsafe<L, A>> fa) =>
            ApplOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOptionAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, OptionAsync<EitherUnsafe<L, A>> fa, OptionAsync<EitherUnsafe<L, B>> fb) =>
            ApplOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOptionAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Task<A>> ma) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> bindT< A, B>(OptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionAsync<B>>`</returns>
        [Pure]
        public static Task<OptionAsync<B>> traverse< A, B>(OptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionAsync<A>>`</returns>
        [Pure]
        public static Task<OptionAsync<A>> sequence< A>(OptionAsync<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> mapT< A, B>(OptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Task<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Task<A>> filterT< A>(OptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionAsync<Task<A>>, OptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Task<A>> plusT<NUM,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Task<A>> subtractT<NUM,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> productT<NUM,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> divideT<NUM,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Task<A>> appendT<SEMI,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Task<A>> x, OptionAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Task<A>>`</param>
        /// <returns>`OptionAsync<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Task<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Task<A>> fa) =>
            ApplOptionAsync< Task<A>, Task<B>>.Inst.Apply(
                 MOptionAsync< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Task<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Task<A>>`</param>
        /// <returns>`OptionAsync<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Task<A>> fa, OptionAsync<Task<B>> fb) =>
            ApplOptionAsync< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MOptionAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Try<A>> ma) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> bindT< A, B>(OptionAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionAsync<B>>`</returns>
        [Pure]
        public static Try<OptionAsync<B>> traverse< A, B>(OptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionAsync<A>>`</returns>
        [Pure]
        public static Try<OptionAsync<A>> sequence< A>(OptionAsync<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> mapT< A, B>(OptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Try<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Try<A>> filterT< A>(OptionAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Try<A>> plusT<NUM,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Try<A>> subtractT<NUM,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> productT<NUM,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> divideT<NUM,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> appendT<SEMI,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Try<A>>`</param>
        /// <returns>`OptionAsync<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Try<A>> fa) =>
            ApplOptionAsync< Try<A>, Try<B>>.Inst.Apply(
                 MOptionAsync< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Try<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Try<A>>`</param>
        /// <returns>`OptionAsync<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Try<A>> fa, OptionAsync<Try<B>> fb) =>
            ApplOptionAsync< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOptionAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<TryAsync<A>> ma) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> bindT< A, B>(OptionAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionAsync<B>>`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> traverse< A, B>(OptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> sequence< A>(OptionAsync<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> mapT< A, B>(OptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<TryAsync<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> filterT< A>(OptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionAsync<TryAsync<A>>, OptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> plusT<NUM,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> subtractT<NUM,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> productT<NUM,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> divideT<NUM,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> appendT<SEMI,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<TryAsync<A>> x, OptionAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryAsync<A>>`</param>
        /// <returns>`OptionAsync<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<TryAsync<A>> fa) =>
            ApplOptionAsync< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MOptionAsync< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<TryAsync<A>>`</param>
        /// <returns>`OptionAsync<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<TryAsync<A>> fa, OptionAsync<TryAsync<B>> fb) =>
            ApplOptionAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MOptionAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<TryOption<A>> ma) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> bindT< A, B>(OptionAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionAsync<B>>`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> traverse< A, B>(OptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionAsync<A>>`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> sequence< A>(OptionAsync<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> mapT< A, B>(OptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<TryOption<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> filterT< A>(OptionAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> plusT<NUM,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> subtractT<NUM,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> productT<NUM,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> divideT<NUM,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> appendT<SEMI,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryOption<A>>`</param>
        /// <returns>`OptionAsync<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<TryOption<A>> fa) =>
            ApplOptionAsync< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOptionAsync< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryOption<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<TryOption<A>>`</param>
        /// <returns>`OptionAsync<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<TryOption<A>> fa, OptionAsync<TryOption<B>> fb) =>
            ApplOptionAsync< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOptionAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<TryOptionAsync<A>> ma) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> bindT< A, B>(OptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionAsync<B>>`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> traverse< A, B>(OptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> sequence< A>(OptionAsync<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> mapT< A, B>(OptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> filterT< A>(OptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionAsync<TryOptionAsync<A>>, OptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> plusT<NUM,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> subtractT<NUM,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> productT<NUM,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> divideT<NUM,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> appendT<SEMI,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<TryOptionAsync<A>> x, OptionAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryOptionAsync<A>>`</param>
        /// <returns>`OptionAsync<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<TryOptionAsync<A>> fa) =>
            ApplOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MOptionAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<TryOptionAsync<A>>`</param>
        /// <returns>`OptionAsync<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<TryOptionAsync<A>> fa, OptionAsync<TryOptionAsync<B>> fb) =>
            ApplOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MOptionAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<IEnumerable<A>> ma) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> bindT< A, B>(OptionAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionAsync<B>>`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> traverse< A, B>(OptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionAsync<A>>`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> sequence< A>(OptionAsync<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> mapT< A, B>(OptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> filterT< A>(OptionAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> plusT<NUM,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> subtractT<NUM,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> productT<NUM,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> divideT<NUM,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> appendT<SEMI,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<IEnumerable<A>>`</param>
        /// <returns>`OptionAsync<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<IEnumerable<A>> fa) =>
            ApplOptionAsync< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOptionAsync< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<IEnumerable<A>>`</param>
        /// <returns>`OptionAsync<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<IEnumerable<A>> fa, OptionAsync<IEnumerable<B>> fb) =>
            ApplOptionAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOptionAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionAsync<Set<A>> ma) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> bindT< A, B>(OptionAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<OptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionAsync<B>>`</returns>
        [Pure]
        public static Set<OptionAsync<B>> traverse< A, B>(OptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<OptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionAsync<A>>`</returns>
        [Pure]
        public static Set<OptionAsync<A>> sequence< A>(OptionAsync<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> mapT< A, B>(OptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionAsync<Set<A>> ma, Action<A> f) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Set<A>> filterT< A>(OptionAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Set<A>> plusT<NUM,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Set<A>> subtractT<NUM,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> productT<NUM,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> divideT<NUM,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> appendT<SEMI,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Set<A>>`</param>
        /// <returns>`OptionAsync<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> applyT< A, B>(Func<A, B> fab, OptionAsync<Set<A>> fa) =>
            ApplOptionAsync< Set<A>, Set<B>>.Inst.Apply(
                 MOptionAsync< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync<Set<A>>`</param>
        /// <param name="fb">Monad of `OptionAsync<Set<A>>`</param>
        /// <returns>`OptionAsync<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionAsync<Set<A>> fa, OptionAsync<Set<B>> fb) =>
            ApplOptionAsync< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOptionAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Arr<A>> ma) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> bindT< A, B>(OptionUnsafe<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> mapT< A, B>(OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Arr<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> filterT< A>(OptionUnsafe<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> plusT<NUM,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> subtractT<NUM,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> productT<NUM,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> divideT<NUM,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> appendT<SEMI,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Arr<A>>`</param>
        /// <returns>`OptionUnsafe<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Arr<A>> fa) =>
            ApplOptionUnsafe< Arr<A>, Arr<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Arr<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Arr<A>>`</param>
        /// <returns>`OptionUnsafe<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Arr<A>> fa, OptionUnsafe<Arr<B>> fb) =>
            ApplOptionUnsafe< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOptionUnsafe< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<HashSet<A>> ma) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> bindT< A, B>(OptionUnsafe<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionUnsafe<B>>`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<OptionUnsafe<A>>`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> sequence< A>(OptionUnsafe<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> mapT< A, B>(OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<HashSet<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> filterT< A>(OptionUnsafe<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> plusT<NUM,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> subtractT<NUM,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> productT<NUM,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> divideT<NUM,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> appendT<SEMI,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<HashSet<A>>`</param>
        /// <returns>`OptionUnsafe<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<HashSet<A>> fa) =>
            ApplOptionUnsafe< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOptionUnsafe< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<HashSet<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<HashSet<A>>`</param>
        /// <returns>`OptionUnsafe<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<HashSet<A>> fa, OptionUnsafe<HashSet<B>> fb) =>
            ApplOptionUnsafe< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOptionUnsafe< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Lst<A>> ma) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> bindT< A, B>(OptionUnsafe<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> mapT< A, B>(OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Lst<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> filterT< A>(OptionUnsafe<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> plusT<NUM,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> subtractT<NUM,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> productT<NUM,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> divideT<NUM,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> appendT<SEMI,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Lst<A>>`</param>
        /// <returns>`OptionUnsafe<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Lst<A>> fa) =>
            ApplOptionUnsafe< Lst<A>, Lst<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Lst<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Lst<A>>`</param>
        /// <returns>`OptionUnsafe<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Lst<A>> fa, OptionUnsafe<Lst<B>> fb) =>
            ApplOptionUnsafe< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOptionUnsafe< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Option<A>> ma) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> bindT< A, B>(OptionUnsafe<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> mapT< A, B>(OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Option<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> filterT< A>(OptionUnsafe<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> plusT<NUM,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> subtractT<NUM,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> productT<NUM,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> divideT<NUM,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> appendT<SEMI,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Option<A>>`</param>
        /// <returns>`OptionUnsafe<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Option<A>> fa) =>
            ApplOptionUnsafe< Option<A>, Option<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Option<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Option<A>>`</param>
        /// <returns>`OptionUnsafe<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Option<A>> fa, OptionUnsafe<Option<B>> fb) =>
            ApplOptionUnsafe< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOptionUnsafe< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<OptionAsync<A>> ma) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> bindT< A, B>(OptionUnsafe<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionUnsafe<B>>`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> sequence< A>(OptionUnsafe<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> mapT< A, B>(OptionUnsafe<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> filterT< A>(OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> plusT<NUM,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> subtractT<NUM,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> productT<NUM,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> divideT<NUM,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> appendT<SEMI,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<OptionAsync<A>>`</param>
        /// <returns>`OptionUnsafe<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<OptionAsync<A>> fa) =>
            ApplOptionUnsafe< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MOptionUnsafe< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<OptionAsync<A>>`</param>
        /// <returns>`OptionUnsafe<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<OptionAsync<A>> fa, OptionUnsafe<OptionAsync<B>> fb) =>
            ApplOptionUnsafe< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MOptionUnsafe< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<OptionUnsafe<A>> ma) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> bindT< A, B>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<B>>`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> sequence< A>(OptionUnsafe<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> mapT< A, B>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> filterT< A>(OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> plusT<NUM,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> subtractT<NUM,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> productT<NUM,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> divideT<NUM,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> appendT<SEMI,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<OptionUnsafe<A>>`</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<OptionUnsafe<A>> fa) =>
            ApplOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOptionUnsafe< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<OptionUnsafe<A>>`</param>
        /// <returns>`OptionUnsafe<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<OptionUnsafe<A>> fa, OptionUnsafe<OptionUnsafe<B>> fb) =>
            ApplOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOptionUnsafe< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(OptionUnsafe<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(OptionUnsafe<Either<L, A>> ma) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> bindT<L, A, B>(OptionUnsafe<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionUnsafe<B>>`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> traverse<L, A, B>(OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> sequence<L, A>(OptionUnsafe<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> mapT<L, A, B>(OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(OptionUnsafe<Either<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> filterT<L, A>(OptionUnsafe<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> plusT<NUM, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> subtractT<NUM, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> productT<NUM, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> divideT<NUM, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> appendT<SEMI, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Either<L, A>>`</param>
        /// <returns>`OptionUnsafe<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, OptionUnsafe<Either<L, A>> fa) =>
            ApplOptionUnsafe< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Either<L, A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Either<L, A>>`</param>
        /// <returns>`OptionUnsafe<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Either<L, A>> fa, OptionUnsafe<Either<L, B>> fb) =>
            ApplOptionUnsafe< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> bindT<L, A, B>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> traverse<L, A, B>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> sequence<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> mapT<L, A, B>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> filterT<L, A>(OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> plusT<NUM, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> subtractT<NUM, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> productT<NUM, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> divideT<NUM, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> appendT<SEMI, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<EitherUnsafe<L, A>>`</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, OptionUnsafe<EitherUnsafe<L, A>> fa) =>
            ApplOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<EitherUnsafe<L, A>>`</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, OptionUnsafe<EitherUnsafe<L, A>> fa, OptionUnsafe<EitherUnsafe<L, B>> fb) =>
            ApplOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Task<A>> ma) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> bindT< A, B>(OptionUnsafe<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> mapT< A, B>(OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Task<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> filterT< A>(OptionUnsafe<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> plusT<NUM,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> subtractT<NUM,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> productT<NUM,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> divideT<NUM,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> appendT<SEMI,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Task<A>>`</param>
        /// <returns>`OptionUnsafe<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Task<A>> fa) =>
            ApplOptionUnsafe< Task<A>, Task<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Task<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Task<A>>`</param>
        /// <returns>`OptionUnsafe<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Task<A>> fa, OptionUnsafe<Task<B>> fb) =>
            ApplOptionUnsafe< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MOptionUnsafe< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Try<A>> ma) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> bindT< A, B>(OptionUnsafe<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> mapT< A, B>(OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Try<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> filterT< A>(OptionUnsafe<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> plusT<NUM,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> subtractT<NUM,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> productT<NUM,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> divideT<NUM,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> appendT<SEMI,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Try<A>>`</param>
        /// <returns>`OptionUnsafe<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Try<A>> fa) =>
            ApplOptionUnsafe< Try<A>, Try<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Try<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Try<A>>`</param>
        /// <returns>`OptionUnsafe<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Try<A>> fa, OptionUnsafe<Try<B>> fb) =>
            ApplOptionUnsafe< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOptionUnsafe< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<TryAsync<A>> ma) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> bindT< A, B>(OptionUnsafe<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionUnsafe<B>>`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> sequence< A>(OptionUnsafe<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> mapT< A, B>(OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<TryAsync<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> filterT< A>(OptionUnsafe<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> plusT<NUM,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> subtractT<NUM,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> productT<NUM,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> divideT<NUM,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> appendT<SEMI,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryAsync<A>>`</param>
        /// <returns>`OptionUnsafe<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<TryAsync<A>> fa) =>
            ApplOptionUnsafe< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<TryAsync<A>>`</param>
        /// <returns>`OptionUnsafe<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<TryAsync<A>> fa, OptionUnsafe<TryAsync<B>> fb) =>
            ApplOptionUnsafe< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<TryOption<A>> ma) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> bindT< A, B>(OptionUnsafe<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionUnsafe<B>>`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionUnsafe<A>>`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> sequence< A>(OptionUnsafe<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> mapT< A, B>(OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<TryOption<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> filterT< A>(OptionUnsafe<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> plusT<NUM,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> subtractT<NUM,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> productT<NUM,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> divideT<NUM,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> appendT<SEMI,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryOption<A>>`</param>
        /// <returns>`OptionUnsafe<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<TryOption<A>> fa) =>
            ApplOptionUnsafe< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryOption<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<TryOption<A>>`</param>
        /// <returns>`OptionUnsafe<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<TryOption<A>> fa, OptionUnsafe<TryOption<B>> fb) =>
            ApplOptionUnsafe< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<TryOptionAsync<A>> ma) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> bindT< A, B>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<B>>`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> sequence< A>(OptionUnsafe<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> mapT< A, B>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> filterT< A>(OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> plusT<NUM,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> subtractT<NUM,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> productT<NUM,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> divideT<NUM,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> appendT<SEMI,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryOptionAsync<A>>`</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<TryOptionAsync<A>> fa) =>
            ApplOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<TryOptionAsync<A>>`</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<TryOptionAsync<A>> fa, OptionUnsafe<TryOptionAsync<B>> fb) =>
            ApplOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<IEnumerable<A>> ma) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> bindT< A, B>(OptionUnsafe<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionUnsafe<B>>`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> sequence< A>(OptionUnsafe<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> mapT< A, B>(OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> filterT< A>(OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> plusT<NUM,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> subtractT<NUM,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> productT<NUM,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> divideT<NUM,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> appendT<SEMI,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<IEnumerable<A>>`</param>
        /// <returns>`OptionUnsafe<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<IEnumerable<A>> fa) =>
            ApplOptionUnsafe< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOptionUnsafe< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<IEnumerable<A>>`</param>
        /// <returns>`OptionUnsafe<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<IEnumerable<A>> fa, OptionUnsafe<IEnumerable<B>> fb) =>
            ApplOptionUnsafe< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOptionUnsafe< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(OptionUnsafe<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(OptionUnsafe<Set<A>> ma) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> bindT< A, B>(OptionUnsafe<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<OptionUnsafe<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionUnsafe<B>>`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> traverse< A, B>(OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<OptionUnsafe<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionUnsafe<A>>`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> sequence< A>(OptionUnsafe<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> mapT< A, B>(OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(OptionUnsafe<Set<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> filterT< A>(OptionUnsafe<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> plusT<NUM,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> subtractT<NUM,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> productT<NUM,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> divideT<NUM,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> appendT<SEMI,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Set<A>>`</param>
        /// <returns>`OptionUnsafe<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> applyT< A, B>(Func<A, B> fab, OptionUnsafe<Set<A>> fa) =>
            ApplOptionUnsafe< Set<A>, Set<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe<Set<A>>`</param>
        /// <param name="fb">Monad of `OptionUnsafe<Set<A>>`</param>
        /// <returns>`OptionUnsafe<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, OptionUnsafe<Set<A>> fa, OptionUnsafe<Set<B>> fb) =>
            ApplOptionUnsafe< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOptionUnsafe< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Arr<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Arr<A>> ma) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> bindT<L, A, B>(Either<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Either<L, B>>`</returns>
        [Pure]
        public static Arr<Either<L, B>> traverse<L, A, B>(Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Either<L, A>>`</returns>
        [Pure]
        public static Arr<Either<L, A>> sequence<L, A>(Either<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> mapT<L, A, B>(Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Arr<A>> filterT<L, A>(Either<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Arr<A>> plusT<NUM, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Arr<A>> subtractT<NUM, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Arr<A>> productT<NUM, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Arr<A>> divideT<NUM, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Arr<A>> appendT<SEMI, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Arr<A>> x, Either<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Arr<A>>`</param>
        /// <returns>`Either<L, Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Arr<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Arr<A>> fa) =>
            ApplEither<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEither<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Arr<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Arr<A>>`</param>
        /// <returns>`Either<L, Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Arr<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Arr<A>> fa, Either<L, Arr<B>> fb) =>
            ApplEither<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEither<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, HashSet<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, HashSet<A>> ma) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> bindT<L, A, B>(Either<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Either<L, B>>`</returns>
        [Pure]
        public static HashSet<Either<L, B>> traverse<L, A, B>(Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Either<L, A>>`</returns>
        [Pure]
        public static HashSet<Either<L, A>> sequence<L, A>(Either<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> mapT<L, A, B>(Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, HashSet<A>> filterT<L, A>(Either<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, HashSet<A>> plusT<NUM, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, HashSet<A>> subtractT<NUM, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> productT<NUM, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> divideT<NUM, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> appendT<SEMI, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, HashSet<A>>`</param>
        /// <returns>`Either<L, HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, HashSet<A>> fa) =>
            ApplEither<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEither<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, HashSet<A>>`</param>
        /// <param name="fb">Monad of `Either<L, HashSet<A>>`</param>
        /// <returns>`Either<L, HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, HashSet<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, HashSet<A>> fa, Either<L, HashSet<B>> fb) =>
            ApplEither<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEither<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Lst<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Lst<A>> ma) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> bindT<L, A, B>(Either<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Either<L, B>>`</returns>
        [Pure]
        public static Lst<Either<L, B>> traverse<L, A, B>(Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Either<L, A>>`</returns>
        [Pure]
        public static Lst<Either<L, A>> sequence<L, A>(Either<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> mapT<L, A, B>(Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Lst<A>> filterT<L, A>(Either<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Lst<A>> plusT<NUM, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Lst<A>> subtractT<NUM, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Lst<A>> productT<NUM, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Lst<A>> divideT<NUM, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Lst<A>> appendT<SEMI, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Lst<A>> x, Either<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Lst<A>>`</param>
        /// <returns>`Either<L, Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Lst<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Lst<A>> fa) =>
            ApplEither<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEither<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Lst<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Lst<A>>`</param>
        /// <returns>`Either<L, Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Lst<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Lst<A>> fa, Either<L, Lst<B>> fb) =>
            ApplEither<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEither<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Option<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Option<A>> ma) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> bindT<L, A, B>(Either<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Either<L, B>>`</returns>
        [Pure]
        public static Option<Either<L, B>> traverse<L, A, B>(Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Either<L, A>>`</returns>
        [Pure]
        public static Option<Either<L, A>> sequence<L, A>(Either<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> mapT<L, A, B>(Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Option<A>> ma, Action<A> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Option<A>> filterT<L, A>(Either<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Option<A>> plusT<NUM, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Option<A>> subtractT<NUM, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Option<A>> productT<NUM, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Option<A>> divideT<NUM, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Option<A>> appendT<SEMI, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Option<A>> x, Either<L, Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Option<A>>`</param>
        /// <returns>`Either<L, Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Option<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Option<A>> fa) =>
            ApplEither<L, Option<A>, Option<B>>.Inst.Apply(
                 MEither<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Option<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Option<A>>`</param>
        /// <returns>`Either<L, Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Option<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Option<A>> fa, Either<L, Option<B>> fb) =>
            ApplEither<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEither<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, OptionAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, OptionAsync<A>> ma) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> bindT<L, A, B>(Either<L, OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Either<L, B>>`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> traverse<L, A, B>(Either<L, OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> sequence<L, A>(Either<L, OptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> mapT<L, A, B>(Either<L, OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, OptionAsync<A>> ma, Action<A> f) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> filterT<L, A>(Either<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> plusT<NUM, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> subtractT<NUM, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> productT<NUM, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> divideT<NUM, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> appendT<SEMI, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, OptionAsync<A>>`</param>
        /// <returns>`Either<L, OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, OptionAsync<A>> fa) =>
            ApplEither<L, OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MEither<L, Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Either<L, OptionAsync<A>>`</param>
        /// <returns>`Either<L, OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, OptionAsync<A>> fa, Either<L, OptionAsync<B>> fb) =>
            ApplEither<L, OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MEither<L, Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, OptionUnsafe<A>> ma) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> bindT<L, A, B>(Either<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Either<L, B>>`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> traverse<L, A, B>(Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Either<L, A>>`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> sequence<L, A>(Either<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> mapT<L, A, B>(Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> filterT<L, A>(Either<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> plusT<NUM, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> subtractT<NUM, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> productT<NUM, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> divideT<NUM, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> appendT<SEMI, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, OptionUnsafe<A>>`</param>
        /// <returns>`Either<L, OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, OptionUnsafe<A>> fa) =>
            ApplEither<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEither<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Either<L, OptionUnsafe<A>>`</param>
        /// <returns>`Either<L, OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, OptionUnsafe<A>> fa, Either<L, OptionUnsafe<B>> fb) =>
            ApplEither<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEither<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Either<L, A>> ma) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> bindT<L, A, B>(Either<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Either<L, B>>`</returns>
        [Pure]
        public static Either<L, Either<L, B>> traverse<L, A, B>(Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Either<L, A>>`</returns>
        [Pure]
        public static Either<L, Either<L, A>> sequence<L, A>(Either<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> mapT<L, A, B>(Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Either<L, A>> filterT<L, A>(Either<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Either<L, A>> plusT<NUM, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Either<L, A>> subtractT<NUM, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> productT<NUM, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> divideT<NUM, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> appendT<SEMI, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Either<L, A>>`</param>
        /// <returns>`Either<L, Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Either<L, A>> fa) =>
            ApplEither<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEither<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Either<L, A>>`</param>
        /// <param name="fb">Monad of `Either<L, Either<L, A>>`</param>
        /// <returns>`Either<L, Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Either<L, A>> fa, Either<L, Either<L, B>> fb) =>
            ApplEither<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEither<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> bindT<L, A, B>(Either<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Either<L, B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> traverse<L, A, B>(Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> sequence<L, A>(Either<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> mapT<L, A, B>(Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> filterT<L, A>(Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> plusT<NUM, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> subtractT<NUM, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> productT<NUM, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> divideT<NUM, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> appendT<SEMI, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, EitherUnsafe<L, A>>`</param>
        /// <returns>`Either<L, EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Either<L, EitherUnsafe<L, A>> fa) =>
            ApplEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEither<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Either<L, EitherUnsafe<L, A>>`</param>
        /// <returns>`Either<L, EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, EitherUnsafe<L, A>> fa, Either<L, EitherUnsafe<L, B>> fb) =>
            ApplEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEither<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Task<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Task<A>> ma) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> bindT<L, A, B>(Either<L, Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Either<L, B>>`</returns>
        [Pure]
        public static Task<Either<L, B>> traverse<L, A, B>(Either<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Either<L, A>>`</returns>
        [Pure]
        public static Task<Either<L, A>> sequence<L, A>(Either<L, Task<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> mapT<L, A, B>(Either<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Task<A>> ma, Action<A> f) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Task<A>> filterT<L, A>(Either<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Task<A>> plusT<NUM, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Task<A>> subtractT<NUM, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Task<A>> productT<NUM, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Task<A>> divideT<NUM, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Task<A>> appendT<SEMI, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Task<A>> x, Either<L, Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Task<A>>`</param>
        /// <returns>`Either<L, Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Task<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Task<A>> fa) =>
            ApplEither<L, Task<A>, Task<B>>.Inst.Apply(
                 MEither<L, Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Task<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Task<A>>`</param>
        /// <returns>`Either<L, Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Task<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Task<A>> fa, Either<L, Task<B>> fb) =>
            ApplEither<L, Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MEither<L, Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Try<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Try<A>> ma) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> bindT<L, A, B>(Either<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Either<L, B>>`</returns>
        [Pure]
        public static Try<Either<L, B>> traverse<L, A, B>(Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Either<L, A>>`</returns>
        [Pure]
        public static Try<Either<L, A>> sequence<L, A>(Either<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> mapT<L, A, B>(Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Try<A>> ma, Action<A> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Try<A>> filterT<L, A>(Either<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Try<A>> plusT<NUM, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Try<A>> subtractT<NUM, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Try<A>> productT<NUM, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Try<A>> divideT<NUM, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Try<A>> appendT<SEMI, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Try<A>> x, Either<L, Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Try<A>>`</param>
        /// <returns>`Either<L, Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Try<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Try<A>> fa) =>
            ApplEither<L, Try<A>, Try<B>>.Inst.Apply(
                 MEither<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Try<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Try<A>>`</param>
        /// <returns>`Either<L, Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Try<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Try<A>> fa, Either<L, Try<B>> fb) =>
            ApplEither<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEither<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, TryAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, TryAsync<A>> ma) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> bindT<L, A, B>(Either<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Either<L, B>>`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> traverse<L, A, B>(Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Either<L, A>>`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> sequence<L, A>(Either<L, TryAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> mapT<L, A, B>(Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, TryAsync<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> filterT<L, A>(Either<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> plusT<NUM, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> subtractT<NUM, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> productT<NUM, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> divideT<NUM, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> appendT<SEMI, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryAsync<A>>`</param>
        /// <returns>`Either<L, TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, TryAsync<A>> fa) =>
            ApplEither<L, TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MEither<L, Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Either<L, TryAsync<A>>`</param>
        /// <returns>`Either<L, TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, TryAsync<A>> fa, Either<L, TryAsync<B>> fb) =>
            ApplEither<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MEither<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, TryOption<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, TryOption<A>> ma) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> bindT<L, A, B>(Either<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Either<L, B>>`</returns>
        [Pure]
        public static TryOption<Either<L, B>> traverse<L, A, B>(Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Either<L, A>>`</returns>
        [Pure]
        public static TryOption<Either<L, A>> sequence<L, A>(Either<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> mapT<L, A, B>(Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOption<A>> filterT<L, A>(Either<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOption<A>> plusT<NUM, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOption<A>> subtractT<NUM, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> productT<NUM, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> divideT<NUM, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> appendT<SEMI, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryOption<A>>`</param>
        /// <returns>`Either<L, TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, TryOption<A>> fa) =>
            ApplEither<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEither<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryOption<A>>`</param>
        /// <param name="fb">Monad of `Either<L, TryOption<A>>`</param>
        /// <returns>`Either<L, TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryOption<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, TryOption<A>> fa, Either<L, TryOption<B>> fb) =>
            ApplEither<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEither<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, TryOptionAsync<A>> ma) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> bindT<L, A, B>(Either<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Either<L, B>>`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> traverse<L, A, B>(Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> sequence<L, A>(Either<L, TryOptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> mapT<L, A, B>(Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> filterT<L, A>(Either<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> plusT<NUM, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> subtractT<NUM, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> productT<NUM, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> divideT<NUM, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> appendT<SEMI, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryOptionAsync<A>>`</param>
        /// <returns>`Either<L, TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, TryOptionAsync<A>> fa) =>
            ApplEither<L, TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MEither<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Either<L, TryOptionAsync<A>>`</param>
        /// <returns>`Either<L, TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, TryOptionAsync<A>> fa, Either<L, TryOptionAsync<B>> fb) =>
            ApplEither<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MEither<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, IEnumerable<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, IEnumerable<A>> ma) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> bindT<L, A, B>(Either<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Either<L, B>>`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> traverse<L, A, B>(Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Either<L, A>>`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> sequence<L, A>(Either<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> mapT<L, A, B>(Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> filterT<L, A>(Either<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> plusT<NUM, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> subtractT<NUM, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> productT<NUM, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> divideT<NUM, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> appendT<SEMI, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, IEnumerable<A>>`</param>
        /// <returns>`Either<L, IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, IEnumerable<A>> fa) =>
            ApplEither<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEither<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Either<L, IEnumerable<A>>`</param>
        /// <returns>`Either<L, IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, IEnumerable<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, IEnumerable<A>> fa, Either<L, IEnumerable<B>> fb) =>
            ApplEither<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEither<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either<L, Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Either<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either<L, Set<A>>`</returns>
        [Pure]
        public static int countT<L, A>(Either<L, Set<A>> ma) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either<L, Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> bindT<L, A, B>(Either<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either<L, Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Either<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Either<L, B>>`</returns>
        [Pure]
        public static Set<Either<L, B>> traverse<L, A, B>(Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either<L, Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Either<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Either<L, A>>`</returns>
        [Pure]
        public static Set<Either<L, A>> sequence<L, A>(Either<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> mapT<L, A, B>(Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Either<L, Set<A>> ma, Action<A> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either<L, Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Set<A>> filterT<L, A>(Either<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Set<A>> plusT<NUM, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Set<A>> subtractT<NUM, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Set<A>> productT<NUM, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Set<A>> divideT<NUM, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Set<A>> appendT<SEMI, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either<L, Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Either<L, Set<A>> x, Either<L, Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either<L, Set<A>>`</param>
        /// <returns>`Either<L, Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Set<B>> applyT<L, A, B>(Func<A, B> fab, Either<L, Set<A>> fa) =>
            ApplEither<L, Set<A>, Set<B>>.Inst.Apply(
                 MEither<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either<L, Set<A>>`</param>
        /// <param name="fb">Monad of `Either<L, Set<A>>`</param>
        /// <returns>`Either<L, Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Set<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Either<L, Set<A>> fa, Either<L, Set<B>> fb) =>
            ApplEither<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEither<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Arr<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Arr<A>> ma) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> bindT<L, A, B>(EitherUnsafe<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> mapT<L, A, B>(EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> filterT<L, A>(EitherUnsafe<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> plusT<NUM, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> productT<NUM, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> divideT<NUM, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Arr<A>>`</param>
        /// <returns>`EitherUnsafe<L, Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Arr<A>> fa) =>
            ApplEitherUnsafe<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Arr<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Arr<A>>`</param>
        /// <returns>`EitherUnsafe<L, Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Arr<A>> fa, EitherUnsafe<L, Arr<B>> fb) =>
            ApplEitherUnsafe<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, HashSet<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, HashSet<A>> ma) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> bindT<L, A, B>(EitherUnsafe<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> mapT<L, A, B>(EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> filterT<L, A>(EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> plusT<NUM, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> subtractT<NUM, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> productT<NUM, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> divideT<NUM, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> appendT<SEMI, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, HashSet<A>>`</param>
        /// <returns>`EitherUnsafe<L, HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, HashSet<A>> fa) =>
            ApplEitherUnsafe<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, HashSet<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, HashSet<A>>`</param>
        /// <returns>`EitherUnsafe<L, HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, HashSet<A>> fa, EitherUnsafe<L, HashSet<B>> fb) =>
            ApplEitherUnsafe<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Lst<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Lst<A>> ma) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> bindT<L, A, B>(EitherUnsafe<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> mapT<L, A, B>(EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> filterT<L, A>(EitherUnsafe<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> plusT<NUM, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> productT<NUM, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> divideT<NUM, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Lst<A>>`</param>
        /// <returns>`EitherUnsafe<L, Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Lst<A>> fa) =>
            ApplEitherUnsafe<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Lst<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Lst<A>>`</param>
        /// <returns>`EitherUnsafe<L, Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Lst<A>> fa, EitherUnsafe<L, Lst<B>> fb) =>
            ApplEitherUnsafe<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Option<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Option<A>> ma) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> bindT<L, A, B>(EitherUnsafe<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> mapT<L, A, B>(EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Option<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> filterT<L, A>(EitherUnsafe<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> plusT<NUM, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> productT<NUM, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> divideT<NUM, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Option<A>>`</param>
        /// <returns>`EitherUnsafe<L, Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Option<A>> fa) =>
            ApplEitherUnsafe<L, Option<A>, Option<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Option<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Option<A>>`</param>
        /// <returns>`EitherUnsafe<L, Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Option<A>> fa, EitherUnsafe<L, Option<B>> fb) =>
            ApplEitherUnsafe<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, OptionAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, OptionAsync<A>> ma) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> bindT<L, A, B>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, OptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> mapT<L, A, B>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, OptionAsync<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> filterT<L, A>(EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> plusT<NUM, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> subtractT<NUM, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> productT<NUM, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> divideT<NUM, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> appendT<SEMI, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, OptionAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, OptionAsync<A>> fa) =>
            ApplEitherUnsafe<L, OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, OptionAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, OptionAsync<A>> fa, EitherUnsafe<L, OptionAsync<B>> fb) =>
            ApplEitherUnsafe<L, OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> bindT<L, A, B>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> mapT<L, A, B>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> filterT<L, A>(EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> plusT<NUM, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> subtractT<NUM, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> productT<NUM, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> divideT<NUM, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> appendT<SEMI, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, OptionUnsafe<A>>`</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, OptionUnsafe<A>> fa) =>
            ApplEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, OptionUnsafe<A>>`</param>
        /// <returns>`EitherUnsafe<L, OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, OptionUnsafe<A>> fa, EitherUnsafe<L, OptionUnsafe<B>> fb) =>
            ApplEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Either<L, A>> ma) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> bindT<L, A, B>(EitherUnsafe<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> mapT<L, A, B>(EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> filterT<L, A>(EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> plusT<NUM, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> subtractT<NUM, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> productT<NUM, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> divideT<NUM, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> appendT<SEMI, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Either<L, A>>`</param>
        /// <returns>`EitherUnsafe<L, Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Either<L, A>> fa) =>
            ApplEitherUnsafe<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Either<L, A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Either<L, A>>`</param>
        /// <returns>`EitherUnsafe<L, Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Either<L, A>> fa, EitherUnsafe<L, Either<L, B>> fb) =>
            ApplEitherUnsafe<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> bindT<L, A, B>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> mapT<L, A, B>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> filterT<L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> plusT<NUM, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> subtractT<NUM, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> productT<NUM, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> divideT<NUM, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> appendT<SEMI, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, EitherUnsafe<L, A>>`</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, EitherUnsafe<L, A>> fa) =>
            ApplEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, EitherUnsafe<L, A>>`</param>
        /// <returns>`EitherUnsafe<L, EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, EitherUnsafe<L, A>> fa, EitherUnsafe<L, EitherUnsafe<L, B>> fb) =>
            ApplEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Task<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Task<A>> ma) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> bindT<L, A, B>(EitherUnsafe<L, Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Task<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> mapT<L, A, B>(EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Task<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> filterT<L, A>(EitherUnsafe<L, Task<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> plusT<NUM, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> productT<NUM, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> divideT<NUM, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Task<A>>`</param>
        /// <returns>`EitherUnsafe<L, Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Task<A>> fa) =>
            ApplEitherUnsafe<L, Task<A>, Task<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Task<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Task<A>>`</param>
        /// <returns>`EitherUnsafe<L, Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Task<A>> fa, EitherUnsafe<L, Task<B>> fb) =>
            ApplEitherUnsafe<L, Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Try<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Try<A>> ma) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> bindT<L, A, B>(EitherUnsafe<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> mapT<L, A, B>(EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Try<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> filterT<L, A>(EitherUnsafe<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> plusT<NUM, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> productT<NUM, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> divideT<NUM, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Try<A>>`</param>
        /// <returns>`EitherUnsafe<L, Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Try<A>> fa) =>
            ApplEitherUnsafe<L, Try<A>, Try<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Try<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Try<A>>`</param>
        /// <returns>`EitherUnsafe<L, Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Try<A>> fa, EitherUnsafe<L, Try<B>> fb) =>
            ApplEitherUnsafe<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, TryAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, TryAsync<A>> ma) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> bindT<L, A, B>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, TryAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> mapT<L, A, B>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, TryAsync<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> filterT<L, A>(EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> plusT<NUM, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> subtractT<NUM, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> productT<NUM, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> divideT<NUM, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> appendT<SEMI, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, TryAsync<A>> fa) =>
            ApplEitherUnsafe<L, TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryAsync<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, TryAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, TryAsync<A>> fa, EitherUnsafe<L, TryAsync<B>> fb) =>
            ApplEitherUnsafe<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, TryOption<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, TryOption<A>> ma) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> bindT<L, A, B>(EitherUnsafe<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> mapT<L, A, B>(EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> filterT<L, A>(EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> plusT<NUM, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> subtractT<NUM, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> productT<NUM, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> divideT<NUM, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> appendT<SEMI, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryOption<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, TryOption<A>> fa) =>
            ApplEitherUnsafe<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryOption<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, TryOption<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, TryOption<A>> fa, EitherUnsafe<L, TryOption<B>> fb) =>
            ApplEitherUnsafe<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> bindT<L, A, B>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> mapT<L, A, B>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> filterT<L, A>(EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> plusT<NUM, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> subtractT<NUM, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> productT<NUM, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> divideT<NUM, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> appendT<SEMI, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryOptionAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, TryOptionAsync<A>> fa) =>
            ApplEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, TryOptionAsync<A>>`</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, TryOptionAsync<A>> fa, EitherUnsafe<L, TryOptionAsync<B>> fb) =>
            ApplEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, IEnumerable<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, IEnumerable<A>> ma) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> bindT<L, A, B>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> mapT<L, A, B>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> filterT<L, A>(EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> plusT<NUM, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> subtractT<NUM, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> productT<NUM, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> divideT<NUM, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> appendT<SEMI, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, IEnumerable<A>>`</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, IEnumerable<A>> fa) =>
            ApplEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, IEnumerable<A>>`</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, IEnumerable<A>> fa, EitherUnsafe<L, IEnumerable<B>> fb) =>
            ApplEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe<L, Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(EitherUnsafe<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe<L, Set<A>>`</returns>
        [Pure]
        public static int countT<L, A>(EitherUnsafe<L, Set<A>> ma) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe<L, Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> bindT<L, A, B>(EitherUnsafe<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe<L, Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<EitherUnsafe<L, B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<EitherUnsafe<L, B>>`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> traverse<L, A, B>(EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe<L, Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<EitherUnsafe<L, A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> sequence<L, A>(EitherUnsafe<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> mapT<L, A, B>(EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe<L, Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(EitherUnsafe<L, Set<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe<L, Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> filterT<L, A>(EitherUnsafe<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> plusT<NUM, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> subtractT<NUM, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> productT<NUM, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> divideT<NUM, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> appendT<SEMI, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe<L, Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Set<A>>`</param>
        /// <returns>`EitherUnsafe<L, Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> applyT<L, A, B>(Func<A, B> fab, EitherUnsafe<L, Set<A>> fa) =>
            ApplEitherUnsafe<L, Set<A>, Set<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe<L, Set<A>>`</param>
        /// <param name="fb">Monad of `EitherUnsafe<L, Set<A>>`</param>
        /// <returns>`EitherUnsafe<L, Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<C>> applyT<L, A, B, C>(Func<A, B, C> fabc, EitherUnsafe<L, Set<A>> fa, EitherUnsafe<L, Set<B>> fb) =>
            ApplEitherUnsafe<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Arr<A>> ma) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Arr<B>> bindT< A, B>(Task<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Task<B>>`</returns>
        [Pure]
        public static Arr<Task<B>> traverse< A, B>(Task<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Task<A>>`</returns>
        [Pure]
        public static Arr<Task<A>> sequence< A>(Task<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Arr<B>> mapT< A, B>(Task<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Arr<A>> ma, Action<A> f) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Arr<A>> filterT< A>(Task<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Arr<A>> plusT<NUM,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Arr<A>> subtractT<NUM,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Arr<A>> productT<NUM,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Arr<A>> divideT<NUM,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Arr<A>> appendT<SEMI,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Arr<A>> x, Task<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Arr<A>>`</param>
        /// <returns>`Task<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Arr<B>> applyT< A, B>(Func<A, B> fab, Task<Arr<A>> fa) =>
            ApplTask< Arr<A>, Arr<B>>.Inst.Apply(
                 MTask< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Arr<A>>`</param>
        /// <param name="fb">Monad of `Task<Arr<A>>`</param>
        /// <returns>`Task<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Arr<A>> fa, Task<Arr<B>> fb) =>
            ApplTask< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTask< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<HashSet<A>> ma) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<HashSet<B>> bindT< A, B>(Task<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Task<B>>`</returns>
        [Pure]
        public static HashSet<Task<B>> traverse< A, B>(Task<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Task<A>>`</returns>
        [Pure]
        public static HashSet<Task<A>> sequence< A>(Task<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<HashSet<B>> mapT< A, B>(Task<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<HashSet<A>> ma, Action<A> f) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<HashSet<A>> filterT< A>(Task<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<HashSet<A>> plusT<NUM,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<HashSet<A>> subtractT<NUM,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<HashSet<A>> productT<NUM,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<HashSet<A>> divideT<NUM,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<HashSet<A>> appendT<SEMI,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<HashSet<A>> x, Task<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<HashSet<A>>`</param>
        /// <returns>`Task<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<HashSet<B>> applyT< A, B>(Func<A, B> fab, Task<HashSet<A>> fa) =>
            ApplTask< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTask< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Task<HashSet<A>>`</param>
        /// <returns>`Task<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<HashSet<A>> fa, Task<HashSet<B>> fb) =>
            ApplTask< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTask< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Lst<A>> ma) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Lst<B>> bindT< A, B>(Task<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Task<B>>`</returns>
        [Pure]
        public static Lst<Task<B>> traverse< A, B>(Task<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Task<A>>`</returns>
        [Pure]
        public static Lst<Task<A>> sequence< A>(Task<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Lst<B>> mapT< A, B>(Task<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Lst<A>> ma, Action<A> f) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Lst<A>> filterT< A>(Task<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Lst<A>> plusT<NUM,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Lst<A>> subtractT<NUM,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Lst<A>> productT<NUM,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Lst<A>> divideT<NUM,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Lst<A>> appendT<SEMI,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Lst<A>> x, Task<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Lst<A>>`</param>
        /// <returns>`Task<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Lst<B>> applyT< A, B>(Func<A, B> fab, Task<Lst<A>> fa) =>
            ApplTask< Lst<A>, Lst<B>>.Inst.Apply(
                 MTask< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Lst<A>>`</param>
        /// <param name="fb">Monad of `Task<Lst<A>>`</param>
        /// <returns>`Task<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Lst<A>> fa, Task<Lst<B>> fb) =>
            ApplTask< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTask< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Option<A>> ma) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Option<B>> bindT< A, B>(Task<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Task<B>>`</returns>
        [Pure]
        public static Option<Task<B>> traverse< A, B>(Task<Option<A>> ma, Func<A, B> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Task<A>>`</returns>
        [Pure]
        public static Option<Task<A>> sequence< A>(Task<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Option<B>> mapT< A, B>(Task<Option<A>> ma, Func<A, B> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Option<A>> ma, Action<A> f) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Option<A>> filterT< A>(Task<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Option<A>> plusT<NUM,  A>(Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Option<A>> subtractT<NUM,  A>(Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Option<A>> productT<NUM,  A>(Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Option<A>> divideT<NUM,  A>(Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Option<A>> appendT<SEMI,  A>(Task<Option<A>> x, Task<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Option<A>> x, Task<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Option<A>> x, Task<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Option<A>>`</param>
        /// <returns>`Task<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Option<B>> applyT< A, B>(Func<A, B> fab, Task<Option<A>> fa) =>
            ApplTask< Option<A>, Option<B>>.Inst.Apply(
                 MTask< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Option<A>>`</param>
        /// <param name="fb">Monad of `Task<Option<A>>`</param>
        /// <returns>`Task<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Option<A>> fa, Task<Option<B>> fb) =>
            ApplTask< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTask< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<OptionAsync<A>> ma) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> bindT< A, B>(Task<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Task<B>>`</returns>
        [Pure]
        public static OptionAsync<Task<B>> traverse< A, B>(Task<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Task<B>>, OptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Task<A>>`</returns>
        [Pure]
        public static OptionAsync<Task<A>> sequence< A>(Task<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> mapT< A, B>(Task<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MTask<OptionAsync<B>>, Task<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionAsync<A>> filterT< A>(Task<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTask<OptionAsync<A>>, Task<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<OptionAsync<A>> plusT<NUM,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<OptionAsync<A>> subtractT<NUM,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> productT<NUM,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> divideT<NUM,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<OptionAsync<A>> appendT<SEMI,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<OptionAsync<A>> x, Task<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<OptionAsync<A>>`</param>
        /// <returns>`Task<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Task<OptionAsync<A>> fa) =>
            ApplTask< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MTask< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Task<OptionAsync<A>>`</param>
        /// <returns>`Task<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<OptionAsync<A>> fa, Task<OptionAsync<B>> fb) =>
            ApplTask< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MTask< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<OptionUnsafe<A>> ma) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> bindT< A, B>(Task<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Task<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> traverse< A, B>(Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Task<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> sequence< A>(Task<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> mapT< A, B>(Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> filterT< A>(Task<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> plusT<NUM,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> subtractT<NUM,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> productT<NUM,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> divideT<NUM,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> appendT<SEMI,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<OptionUnsafe<A>>`</param>
        /// <returns>`Task<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Task<OptionUnsafe<A>> fa) =>
            ApplTask< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTask< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Task<OptionUnsafe<A>>`</param>
        /// <returns>`Task<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<OptionUnsafe<A>> fa, Task<OptionUnsafe<B>> fb) =>
            ApplTask< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTask< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Task<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Task<Either<L, A>> ma) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Either<L, B>> bindT<L, A, B>(Task<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Task<B>>`</returns>
        [Pure]
        public static Either<L, Task<B>> traverse<L, A, B>(Task<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Task<A>>`</returns>
        [Pure]
        public static Either<L, Task<A>> sequence<L, A>(Task<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Either<L, B>> mapT<L, A, B>(Task<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Task<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Task<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Task<Either<L, A>> ma, Action<A> f) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Either<L, A>> filterT<L, A>(Task<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Either<L, A>> plusT<NUM, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Either<L, A>> subtractT<NUM, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Either<L, A>> productT<NUM, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Either<L, A>> divideT<NUM, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Either<L, A>> appendT<SEMI, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Task<Either<L, A>> x, Task<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Either<L, A>>`</param>
        /// <returns>`Task<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Task<Either<L, A>> fa) =>
            ApplTask< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTask< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Task<Either<L, A>>`</param>
        /// <returns>`Task<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Task<Either<L, A>> fa, Task<Either<L, B>> fb) =>
            ApplTask< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTask< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Task<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Task<EitherUnsafe<L, A>> ma) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> bindT<L, A, B>(Task<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Task<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> traverse<L, A, B>(Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Task<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> sequence<L, A>(Task<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> mapT<L, A, B>(Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Task<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> filterT<L, A>(Task<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> plusT<NUM, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> productT<NUM, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> divideT<NUM, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<EitherUnsafe<L, A>>`</param>
        /// <returns>`Task<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Task<EitherUnsafe<L, A>> fa) =>
            ApplTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTask< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Task<EitherUnsafe<L, A>>`</param>
        /// <returns>`Task<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Task<EitherUnsafe<L, A>> fa, Task<EitherUnsafe<L, B>> fb) =>
            ApplTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTask< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Task<A>> ma) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> bindT< A, B>(Task<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Task<B>>`</returns>
        [Pure]
        public static Task<Task<B>> traverse< A, B>(Task<Task<A>> ma, Func<A, B> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Task<A>>`</returns>
        [Pure]
        public static Task<Task<A>> sequence< A>(Task<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Task<B>> mapT< A, B>(Task<Task<A>> ma, Func<A, B> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTask<Task<B>>, Task<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Task<A>> ma, Action<A> f) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Task<A>> filterT< A>(Task<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTask<Task<A>>, Task<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Task<A>> plusT<NUM,  A>(Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Task<A>> subtractT<NUM,  A>(Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Task<A>> productT<NUM,  A>(Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Task<A>> divideT<NUM,  A>(Task<Task<A>> x, Task<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Task<A>> appendT<SEMI,  A>(Task<Task<A>> x, Task<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Task<A>> x, Task<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Task<A>> x, Task<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Task<A>>`</param>
        /// <returns>`Task<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Task<B>> applyT< A, B>(Func<A, B> fab, Task<Task<A>> fa) =>
            ApplTask< Task<A>, Task<B>>.Inst.Apply(
                 MTask< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Task<A>>`</param>
        /// <param name="fb">Monad of `Task<Task<A>>`</param>
        /// <returns>`Task<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Task<A>> fa, Task<Task<B>> fb) =>
            ApplTask< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTask< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Try<A>> ma) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Try<B>> bindT< A, B>(Task<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Task<B>>`</returns>
        [Pure]
        public static Try<Task<B>> traverse< A, B>(Task<Try<A>> ma, Func<A, B> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Task<A>>`</returns>
        [Pure]
        public static Try<Task<A>> sequence< A>(Task<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Try<B>> mapT< A, B>(Task<Try<A>> ma, Func<A, B> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Try<A>> ma, Action<A> f) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Try<A>> filterT< A>(Task<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Try<A>> plusT<NUM,  A>(Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Try<A>> subtractT<NUM,  A>(Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Try<A>> productT<NUM,  A>(Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Try<A>> divideT<NUM,  A>(Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Try<A>> appendT<SEMI,  A>(Task<Try<A>> x, Task<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Try<A>> x, Task<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Try<A>> x, Task<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Try<A>>`</param>
        /// <returns>`Task<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Try<B>> applyT< A, B>(Func<A, B> fab, Task<Try<A>> fa) =>
            ApplTask< Try<A>, Try<B>>.Inst.Apply(
                 MTask< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Try<A>>`</param>
        /// <param name="fb">Monad of `Task<Try<A>>`</param>
        /// <returns>`Task<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Try<A>> fa, Task<Try<B>> fb) =>
            ApplTask< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTask< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<TryAsync<A>> ma) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> bindT< A, B>(Task<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Task<B>>`</returns>
        [Pure]
        public static TryAsync<Task<B>> traverse< A, B>(Task<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Task<A>>`</returns>
        [Pure]
        public static TryAsync<Task<A>> sequence< A>(Task<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryAsync<B>> mapT< A, B>(Task<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryAsync<A>> filterT< A>(Task<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTask<TryAsync<A>>, Task<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryAsync<A>> plusT<NUM,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryAsync<A>> subtractT<NUM,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryAsync<A>> productT<NUM,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryAsync<A>> divideT<NUM,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryAsync<A>> appendT<SEMI,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<TryAsync<A>> x, Task<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<TryAsync<A>>`</param>
        /// <returns>`Task<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Task<TryAsync<A>> fa) =>
            ApplTask< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTask< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Task<TryAsync<A>>`</param>
        /// <returns>`Task<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<TryAsync<A>> fa, Task<TryAsync<B>> fb) =>
            ApplTask< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTask< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<TryOption<A>> ma) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOption<B>> bindT< A, B>(Task<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Task<B>>`</returns>
        [Pure]
        public static TryOption<Task<B>> traverse< A, B>(Task<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Task<A>>`</returns>
        [Pure]
        public static TryOption<Task<A>> sequence< A>(Task<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOption<B>> mapT< A, B>(Task<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<TryOption<A>> ma, Action<A> f) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOption<A>> filterT< A>(Task<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOption<A>> plusT<NUM,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOption<A>> subtractT<NUM,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryOption<A>> productT<NUM,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryOption<A>> divideT<NUM,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryOption<A>> appendT<SEMI,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<TryOption<A>> x, Task<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<TryOption<A>>`</param>
        /// <returns>`Task<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryOption<B>> applyT< A, B>(Func<A, B> fab, Task<TryOption<A>> fa) =>
            ApplTask< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTask< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Task<TryOption<A>>`</param>
        /// <returns>`Task<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<TryOption<A>> fa, Task<TryOption<B>> fb) =>
            ApplTask< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTask< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<TryOptionAsync<A>> ma) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> bindT< A, B>(Task<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Task<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> traverse< A, B>(Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Task<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> sequence< A>(Task<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> mapT< A, B>(Task<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> filterT< A>(Task<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTask<TryOptionAsync<A>>, Task<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> plusT<NUM,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> subtractT<NUM,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> productT<NUM,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> divideT<NUM,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> appendT<SEMI,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<TryOptionAsync<A>> x, Task<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<TryOptionAsync<A>>`</param>
        /// <returns>`Task<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Task<TryOptionAsync<A>> fa) =>
            ApplTask< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTask< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Task<TryOptionAsync<A>>`</param>
        /// <returns>`Task<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<TryOptionAsync<A>> fa, Task<TryOptionAsync<B>> fb) =>
            ApplTask< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTask< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<IEnumerable<A>> ma) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> bindT< A, B>(Task<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Task<B>>`</returns>
        [Pure]
        public static IEnumerable<Task<B>> traverse< A, B>(Task<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Task<A>>`</returns>
        [Pure]
        public static IEnumerable<Task<A>> sequence< A>(Task<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> mapT< A, B>(Task<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<IEnumerable<A>> filterT< A>(Task<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<IEnumerable<A>> plusT<NUM,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<IEnumerable<A>> subtractT<NUM,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> productT<NUM,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> divideT<NUM,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> appendT<SEMI,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<IEnumerable<A>>`</param>
        /// <returns>`Task<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Task<IEnumerable<A>> fa) =>
            ApplTask< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTask< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Task<IEnumerable<A>>`</param>
        /// <returns>`Task<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<IEnumerable<A>> fa, Task<IEnumerable<B>> fb) =>
            ApplTask< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTask< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Task<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Task<Set<A>> ma) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Set<B>> bindT< A, B>(Task<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Task<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Task<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Task<B>>`</returns>
        [Pure]
        public static Set<Task<B>> traverse< A, B>(Task<Set<A>> ma, Func<A, B> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Task<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Task<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Task<A>>`</returns>
        [Pure]
        public static Set<Task<A>> sequence< A>(Task<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Set<B>> mapT< A, B>(Task<Set<A>> ma, Func<A, B> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Task<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Task<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Task<Set<A>> ma, Action<A> f) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Set<A>> filterT< A>(Task<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Set<A>> plusT<NUM,  A>(Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Set<A>> subtractT<NUM,  A>(Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Set<A>> productT<NUM,  A>(Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Set<A>> divideT<NUM,  A>(Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Set<A>> appendT<SEMI,  A>(Task<Set<A>> x, Task<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Task<Set<A>> x, Task<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Task<Set<A>> x, Task<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task<Set<A>>`</param>
        /// <returns>`Task<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Set<B>> applyT< A, B>(Func<A, B> fab, Task<Set<A>> fa) =>
            ApplTask< Set<A>, Set<B>>.Inst.Apply(
                 MTask< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task<Set<A>>`</param>
        /// <param name="fb">Monad of `Task<Set<A>>`</param>
        /// <returns>`Task<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Task<Set<A>> fa, Task<Set<B>> fb) =>
            ApplTask< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTask< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Arr<A>> ma) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> bindT< A, B>(Try<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Try<B>>`</returns>
        [Pure]
        public static Arr<Try<B>> traverse< A, B>(Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Try<A>>`</returns>
        [Pure]
        public static Arr<Try<A>> sequence< A>(Try<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> mapT< A, B>(Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Arr<A>> ma, Action<A> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Arr<A>> filterT< A>(Try<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Arr<A>> plusT<NUM,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Arr<A>> subtractT<NUM,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Arr<A>> productT<NUM,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Arr<A>> divideT<NUM,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Arr<A>> appendT<SEMI,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Arr<A>> x, Try<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Arr<A>>`</param>
        /// <returns>`Try<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Arr<B>> applyT< A, B>(Func<A, B> fab, Try<Arr<A>> fa) =>
            ApplTry< Arr<A>, Arr<B>>.Inst.Apply(
                 MTry< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Arr<A>>`</param>
        /// <param name="fb">Monad of `Try<Arr<A>>`</param>
        /// <returns>`Try<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Arr<A>> fa, Try<Arr<B>> fb) =>
            ApplTry< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTry< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<HashSet<A>> ma) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> bindT< A, B>(Try<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Try<B>>`</returns>
        [Pure]
        public static HashSet<Try<B>> traverse< A, B>(Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Try<A>>`</returns>
        [Pure]
        public static HashSet<Try<A>> sequence< A>(Try<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> mapT< A, B>(Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<HashSet<A>> ma, Action<A> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<HashSet<A>> filterT< A>(Try<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<HashSet<A>> plusT<NUM,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<HashSet<A>> subtractT<NUM,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<HashSet<A>> productT<NUM,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<HashSet<A>> divideT<NUM,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<HashSet<A>> appendT<SEMI,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<HashSet<A>> x, Try<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<HashSet<A>>`</param>
        /// <returns>`Try<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<HashSet<B>> applyT< A, B>(Func<A, B> fab, Try<HashSet<A>> fa) =>
            ApplTry< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTry< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Try<HashSet<A>>`</param>
        /// <returns>`Try<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<HashSet<A>> fa, Try<HashSet<B>> fb) =>
            ApplTry< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTry< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Lst<A>> ma) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> bindT< A, B>(Try<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Try<B>>`</returns>
        [Pure]
        public static Lst<Try<B>> traverse< A, B>(Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Try<A>>`</returns>
        [Pure]
        public static Lst<Try<A>> sequence< A>(Try<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> mapT< A, B>(Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Lst<A>> ma, Action<A> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Lst<A>> filterT< A>(Try<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Lst<A>> plusT<NUM,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Lst<A>> subtractT<NUM,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Lst<A>> productT<NUM,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Lst<A>> divideT<NUM,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Lst<A>> appendT<SEMI,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Lst<A>> x, Try<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Lst<A>>`</param>
        /// <returns>`Try<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Lst<B>> applyT< A, B>(Func<A, B> fab, Try<Lst<A>> fa) =>
            ApplTry< Lst<A>, Lst<B>>.Inst.Apply(
                 MTry< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Lst<A>>`</param>
        /// <param name="fb">Monad of `Try<Lst<A>>`</param>
        /// <returns>`Try<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Lst<A>> fa, Try<Lst<B>> fb) =>
            ApplTry< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTry< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Option<A>> ma) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> bindT< A, B>(Try<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Try<B>>`</returns>
        [Pure]
        public static Option<Try<B>> traverse< A, B>(Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Try<A>>`</returns>
        [Pure]
        public static Option<Try<A>> sequence< A>(Try<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> mapT< A, B>(Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Option<A>> ma, Action<A> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Option<A>> filterT< A>(Try<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Option<A>> plusT<NUM,  A>(Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Option<A>> subtractT<NUM,  A>(Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Option<A>> productT<NUM,  A>(Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Option<A>> divideT<NUM,  A>(Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Option<A>> appendT<SEMI,  A>(Try<Option<A>> x, Try<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Option<A>> x, Try<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Option<A>> x, Try<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Option<A>>`</param>
        /// <returns>`Try<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Option<B>> applyT< A, B>(Func<A, B> fab, Try<Option<A>> fa) =>
            ApplTry< Option<A>, Option<B>>.Inst.Apply(
                 MTry< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Option<A>>`</param>
        /// <param name="fb">Monad of `Try<Option<A>>`</param>
        /// <returns>`Try<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Option<A>> fa, Try<Option<B>> fb) =>
            ApplTry< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTry< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<OptionAsync<A>> ma) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> bindT< A, B>(Try<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Try<B>>`</returns>
        [Pure]
        public static OptionAsync<Try<B>> traverse< A, B>(Try<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Try<A>>`</returns>
        [Pure]
        public static OptionAsync<Try<A>> sequence< A>(Try<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> mapT< A, B>(Try<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionAsync<A>> filterT< A>(Try<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<OptionAsync<A>> plusT<NUM,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<OptionAsync<A>> subtractT<NUM,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> productT<NUM,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> divideT<NUM,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> appendT<SEMI,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<OptionAsync<A>>`</param>
        /// <returns>`Try<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Try<OptionAsync<A>> fa) =>
            ApplTry< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MTry< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Try<OptionAsync<A>>`</param>
        /// <returns>`Try<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<OptionAsync<A>> fa, Try<OptionAsync<B>> fb) =>
            ApplTry< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MTry< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<OptionUnsafe<A>> ma) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> bindT< A, B>(Try<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Try<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> traverse< A, B>(Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Try<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> sequence< A>(Try<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> mapT< A, B>(Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> filterT< A>(Try<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> plusT<NUM,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> subtractT<NUM,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> productT<NUM,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> divideT<NUM,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> appendT<SEMI,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<OptionUnsafe<A>>`</param>
        /// <returns>`Try<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Try<OptionUnsafe<A>> fa) =>
            ApplTry< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTry< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Try<OptionUnsafe<A>>`</param>
        /// <returns>`Try<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<OptionUnsafe<A>> fa, Try<OptionUnsafe<B>> fb) =>
            ApplTry< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTry< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Try<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Try<Either<L, A>> ma) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> bindT<L, A, B>(Try<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Try<B>>`</returns>
        [Pure]
        public static Either<L, Try<B>> traverse<L, A, B>(Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Try<A>>`</returns>
        [Pure]
        public static Either<L, Try<A>> sequence<L, A>(Try<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> mapT<L, A, B>(Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Try<Either<L, A>> ma, Action<A> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Either<L, A>> filterT<L, A>(Try<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Either<L, A>> plusT<NUM, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Either<L, A>> subtractT<NUM, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Either<L, A>> productT<NUM, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Either<L, A>> divideT<NUM, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Either<L, A>> appendT<SEMI, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Try<Either<L, A>> x, Try<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Either<L, A>>`</param>
        /// <returns>`Try<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Try<Either<L, A>> fa) =>
            ApplTry< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTry< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Try<Either<L, A>>`</param>
        /// <returns>`Try<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Try<Either<L, A>> fa, Try<Either<L, B>> fb) =>
            ApplTry< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTry< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Try<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Try<EitherUnsafe<L, A>> ma) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> bindT<L, A, B>(Try<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Try<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> traverse<L, A, B>(Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Try<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> sequence<L, A>(Try<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> mapT<L, A, B>(Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Try<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> filterT<L, A>(Try<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> plusT<NUM, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> productT<NUM, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> divideT<NUM, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<EitherUnsafe<L, A>>`</param>
        /// <returns>`Try<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Try<EitherUnsafe<L, A>> fa) =>
            ApplTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTry< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Try<EitherUnsafe<L, A>>`</param>
        /// <returns>`Try<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Try<EitherUnsafe<L, A>> fa, Try<EitherUnsafe<L, B>> fb) =>
            ApplTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTry< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Task<A>> ma) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> bindT< A, B>(Try<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Try<B>>`</returns>
        [Pure]
        public static Task<Try<B>> traverse< A, B>(Try<Task<A>> ma, Func<A, B> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Try<A>>`</returns>
        [Pure]
        public static Task<Try<A>> sequence< A>(Try<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> mapT< A, B>(Try<Task<A>> ma, Func<A, B> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Task<A>> ma, Action<A> f) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Task<A>> filterT< A>(Try<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Task<A>> plusT<NUM,  A>(Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Task<A>> subtractT<NUM,  A>(Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Task<A>> productT<NUM,  A>(Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Task<A>> divideT<NUM,  A>(Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Task<A>> appendT<SEMI,  A>(Try<Task<A>> x, Try<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Task<A>> x, Try<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Task<A>> x, Try<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Task<A>>`</param>
        /// <returns>`Try<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Task<B>> applyT< A, B>(Func<A, B> fab, Try<Task<A>> fa) =>
            ApplTry< Task<A>, Task<B>>.Inst.Apply(
                 MTry< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Task<A>>`</param>
        /// <param name="fb">Monad of `Try<Task<A>>`</param>
        /// <returns>`Try<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Task<A>> fa, Try<Task<B>> fb) =>
            ApplTry< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTry< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Try<A>> ma) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> bindT< A, B>(Try<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Try<B>>`</returns>
        [Pure]
        public static Try<Try<B>> traverse< A, B>(Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Try<A>>`</returns>
        [Pure]
        public static Try<Try<A>> sequence< A>(Try<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> mapT< A, B>(Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Try<A>> ma, Action<A> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Try<A>> filterT< A>(Try<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Try<A>> plusT<NUM,  A>(Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Try<A>> subtractT<NUM,  A>(Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Try<A>> productT<NUM,  A>(Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Try<A>> divideT<NUM,  A>(Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Try<A>> appendT<SEMI,  A>(Try<Try<A>> x, Try<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Try<A>> x, Try<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Try<A>> x, Try<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Try<A>>`</param>
        /// <returns>`Try<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Try<B>> applyT< A, B>(Func<A, B> fab, Try<Try<A>> fa) =>
            ApplTry< Try<A>, Try<B>>.Inst.Apply(
                 MTry< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Try<A>>`</param>
        /// <param name="fb">Monad of `Try<Try<A>>`</param>
        /// <returns>`Try<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Try<A>> fa, Try<Try<B>> fb) =>
            ApplTry< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTry< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<TryAsync<A>> ma) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> bindT< A, B>(Try<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Try<B>>`</returns>
        [Pure]
        public static TryAsync<Try<B>> traverse< A, B>(Try<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Try<A>>`</returns>
        [Pure]
        public static TryAsync<Try<A>> sequence< A>(Try<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> mapT< A, B>(Try<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryAsync<A>> filterT< A>(Try<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryAsync<A>> plusT<NUM,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryAsync<A>> subtractT<NUM,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryAsync<A>> productT<NUM,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryAsync<A>> divideT<NUM,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryAsync<A>> appendT<SEMI,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<TryAsync<A>> x, Try<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<TryAsync<A>>`</param>
        /// <returns>`Try<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Try<TryAsync<A>> fa) =>
            ApplTry< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTry< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Try<TryAsync<A>>`</param>
        /// <returns>`Try<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<TryAsync<A>> fa, Try<TryAsync<B>> fb) =>
            ApplTry< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTry< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<TryOption<A>> ma) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> bindT< A, B>(Try<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Try<B>>`</returns>
        [Pure]
        public static TryOption<Try<B>> traverse< A, B>(Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Try<A>>`</returns>
        [Pure]
        public static TryOption<Try<A>> sequence< A>(Try<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> mapT< A, B>(Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<TryOption<A>> ma, Action<A> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOption<A>> filterT< A>(Try<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOption<A>> plusT<NUM,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOption<A>> subtractT<NUM,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryOption<A>> productT<NUM,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryOption<A>> divideT<NUM,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryOption<A>> appendT<SEMI,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<TryOption<A>> x, Try<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<TryOption<A>>`</param>
        /// <returns>`Try<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryOption<B>> applyT< A, B>(Func<A, B> fab, Try<TryOption<A>> fa) =>
            ApplTry< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTry< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Try<TryOption<A>>`</param>
        /// <returns>`Try<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<TryOption<A>> fa, Try<TryOption<B>> fb) =>
            ApplTry< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTry< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<TryOptionAsync<A>> ma) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> bindT< A, B>(Try<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Try<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> traverse< A, B>(Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Try<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> sequence< A>(Try<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> mapT< A, B>(Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> filterT< A>(Try<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> plusT<NUM,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> subtractT<NUM,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> productT<NUM,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> divideT<NUM,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> appendT<SEMI,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<TryOptionAsync<A>>`</param>
        /// <returns>`Try<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Try<TryOptionAsync<A>> fa) =>
            ApplTry< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTry< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Try<TryOptionAsync<A>>`</param>
        /// <returns>`Try<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<TryOptionAsync<A>> fa, Try<TryOptionAsync<B>> fb) =>
            ApplTry< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTry< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<IEnumerable<A>> ma) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> bindT< A, B>(Try<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Try<B>>`</returns>
        [Pure]
        public static IEnumerable<Try<B>> traverse< A, B>(Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Try<A>>`</returns>
        [Pure]
        public static IEnumerable<Try<A>> sequence< A>(Try<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> mapT< A, B>(Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<IEnumerable<A>> filterT< A>(Try<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<IEnumerable<A>> plusT<NUM,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<IEnumerable<A>> subtractT<NUM,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> productT<NUM,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> divideT<NUM,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> appendT<SEMI,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<IEnumerable<A>>`</param>
        /// <returns>`Try<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Try<IEnumerable<A>> fa) =>
            ApplTry< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTry< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Try<IEnumerable<A>>`</param>
        /// <returns>`Try<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<IEnumerable<A>> fa, Try<IEnumerable<B>> fb) =>
            ApplTry< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTry< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Try<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Try<Set<A>> ma) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> bindT< A, B>(Try<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Try<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Try<B>>`</returns>
        [Pure]
        public static Set<Try<B>> traverse< A, B>(Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Try<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Try<A>>`</returns>
        [Pure]
        public static Set<Try<A>> sequence< A>(Try<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> mapT< A, B>(Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Try<Set<A>> ma, Action<A> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Set<A>> filterT< A>(Try<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Set<A>> plusT<NUM,  A>(Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Set<A>> subtractT<NUM,  A>(Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Set<A>> productT<NUM,  A>(Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Set<A>> divideT<NUM,  A>(Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Set<A>> appendT<SEMI,  A>(Try<Set<A>> x, Try<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Try<Set<A>> x, Try<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Try<Set<A>> x, Try<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try<Set<A>>`</param>
        /// <returns>`Try<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Set<B>> applyT< A, B>(Func<A, B> fab, Try<Set<A>> fa) =>
            ApplTry< Set<A>, Set<B>>.Inst.Apply(
                 MTry< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try<Set<A>>`</param>
        /// <param name="fb">Monad of `Try<Set<A>>`</param>
        /// <returns>`Try<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Try<Set<A>> fa, Try<Set<B>> fb) =>
            ApplTry< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTry< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Arr<A>> ma) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> bindT< A, B>(TryAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryAsync<B>>`</returns>
        [Pure]
        public static Arr<TryAsync<B>> traverse< A, B>(TryAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryAsync<A>>`</returns>
        [Pure]
        public static Arr<TryAsync<A>> sequence< A>(TryAsync<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> mapT< A, B>(TryAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Arr<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Arr<A>> filterT< A>(TryAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Arr<A>> plusT<NUM,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Arr<A>> subtractT<NUM,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> productT<NUM,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> divideT<NUM,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> appendT<SEMI,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Arr<A>>`</param>
        /// <returns>`TryAsync<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Arr<A>> fa) =>
            ApplTryAsync< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryAsync< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Arr<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Arr<A>>`</param>
        /// <returns>`TryAsync<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Arr<A>> fa, TryAsync<Arr<B>> fb) =>
            ApplTryAsync< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<HashSet<A>> ma) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> bindT< A, B>(TryAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryAsync<B>>`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> traverse< A, B>(TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryAsync<A>>`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> sequence< A>(TryAsync<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> mapT< A, B>(TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<HashSet<A>> filterT< A>(TryAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> plusT<NUM,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> subtractT<NUM,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> productT<NUM,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> divideT<NUM,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> appendT<SEMI,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<HashSet<A>>`</param>
        /// <returns>`TryAsync<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> applyT< A, B>(Func<A, B> fab, TryAsync<HashSet<A>> fa) =>
            ApplTryAsync< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryAsync< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<HashSet<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<HashSet<A>>`</param>
        /// <returns>`TryAsync<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<HashSet<A>> fa, TryAsync<HashSet<B>> fb) =>
            ApplTryAsync< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Lst<A>> ma) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> bindT< A, B>(TryAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryAsync<B>>`</returns>
        [Pure]
        public static Lst<TryAsync<B>> traverse< A, B>(TryAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryAsync<A>>`</returns>
        [Pure]
        public static Lst<TryAsync<A>> sequence< A>(TryAsync<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> mapT< A, B>(TryAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Lst<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Lst<A>> filterT< A>(TryAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Lst<A>> plusT<NUM,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Lst<A>> subtractT<NUM,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> productT<NUM,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> divideT<NUM,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> appendT<SEMI,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Lst<A>>`</param>
        /// <returns>`TryAsync<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Lst<A>> fa) =>
            ApplTryAsync< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryAsync< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Lst<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Lst<A>>`</param>
        /// <returns>`TryAsync<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Lst<A>> fa, TryAsync<Lst<B>> fb) =>
            ApplTryAsync< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Option<A>> ma) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Option<B>> bindT< A, B>(TryAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryAsync<B>>`</returns>
        [Pure]
        public static Option<TryAsync<B>> traverse< A, B>(TryAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryAsync<A>>`</returns>
        [Pure]
        public static Option<TryAsync<A>> sequence< A>(TryAsync<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Option<B>> mapT< A, B>(TryAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Option<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Option<A>> filterT< A>(TryAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Option<A>> plusT<NUM,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Option<A>> subtractT<NUM,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Option<A>> productT<NUM,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Option<A>> divideT<NUM,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Option<A>> appendT<SEMI,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Option<A>> x, TryAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Option<A>>`</param>
        /// <returns>`TryAsync<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Option<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Option<A>> fa) =>
            ApplTryAsync< Option<A>, Option<B>>.Inst.Apply(
                 MTryAsync< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Option<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Option<A>>`</param>
        /// <returns>`TryAsync<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Option<A>> fa, TryAsync<Option<B>> fb) =>
            ApplTryAsync< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<OptionAsync<A>> ma) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> bindT< A, B>(TryAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryAsync<B>>`</returns>
        [Pure]
        public static OptionAsync<TryAsync<B>> traverse< A, B>(TryAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<TryAsync<B>>, OptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static OptionAsync<TryAsync<A>> sequence< A>(TryAsync<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> mapT< A, B>(TryAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MTryAsync<OptionAsync<B>>, TryAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> filterT< A>(TryAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryAsync<OptionAsync<A>>, TryAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> plusT<NUM,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> subtractT<NUM,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> productT<NUM,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> divideT<NUM,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<OptionAsync<A>> appendT<SEMI,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<OptionAsync<A>> x, TryAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<OptionAsync<A>>`</param>
        /// <returns>`TryAsync<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryAsync<OptionAsync<A>> fa) =>
            ApplTryAsync< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MTryAsync< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<OptionAsync<A>>`</param>
        /// <returns>`TryAsync<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<OptionAsync<A>> fa, TryAsync<OptionAsync<B>> fb) =>
            ApplTryAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MTryAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<OptionUnsafe<A>> ma) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> bindT< A, B>(TryAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryAsync<B>>`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> traverse< A, B>(TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryAsync<A>>`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> sequence< A>(TryAsync<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> mapT< A, B>(TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> filterT< A>(TryAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> plusT<NUM,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> subtractT<NUM,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> productT<NUM,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> divideT<NUM,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> appendT<SEMI,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<OptionUnsafe<A>>`</param>
        /// <returns>`TryAsync<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, TryAsync<OptionUnsafe<A>> fa) =>
            ApplTryAsync< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<OptionUnsafe<A>>`</param>
        /// <returns>`TryAsync<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<OptionUnsafe<A>> fa, TryAsync<OptionUnsafe<B>> fb) =>
            ApplTryAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryAsync<Either<L, A>> ma) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> bindT<L, A, B>(TryAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryAsync<B>>`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> traverse<L, A, B>(TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryAsync<A>>`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> sequence<L, A>(TryAsync<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> mapT<L, A, B>(TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryAsync<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Either<L, A>> filterT<L, A>(TryAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> plusT<NUM, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> subtractT<NUM, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> productT<NUM, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> divideT<NUM, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> appendT<SEMI, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Either<L, A>>`</param>
        /// <returns>`TryAsync<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, TryAsync<Either<L, A>> fa) =>
            ApplTryAsync< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryAsync< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Either<L, A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Either<L, A>>`</param>
        /// <returns>`TryAsync<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryAsync<Either<L, A>> fa, TryAsync<Either<L, B>> fb) =>
            ApplTryAsync< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryAsync<EitherUnsafe<L, A>> ma) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> bindT<L, A, B>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryAsync<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> traverse<L, A, B>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryAsync<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> sequence<L, A>(TryAsync<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> mapT<L, A, B>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> filterT<L, A>(TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> plusT<NUM, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> subtractT<NUM, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> productT<NUM, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> divideT<NUM, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> appendT<SEMI, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryAsync<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, TryAsync<EitherUnsafe<L, A>> fa) =>
            ApplTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `TryAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryAsync<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryAsync<EitherUnsafe<L, A>> fa, TryAsync<EitherUnsafe<L, B>> fb) =>
            ApplTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Task<A>> ma) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> bindT< A, B>(TryAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryAsync<B>>`</returns>
        [Pure]
        public static Task<TryAsync<B>> traverse< A, B>(TryAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryAsync<B>>, Task<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryAsync<A>>`</returns>
        [Pure]
        public static Task<TryAsync<A>> sequence< A>(TryAsync<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Task<B>> mapT< A, B>(TryAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryAsync<Task<B>>, TryAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Task<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Task<A>> filterT< A>(TryAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryAsync<Task<A>>, TryAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Task<A>> plusT<NUM,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Task<A>> subtractT<NUM,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Task<A>> productT<NUM,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Task<A>> divideT<NUM,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Task<A>> appendT<SEMI,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Task<A>> x, TryAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Task<A>>`</param>
        /// <returns>`TryAsync<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Task<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Task<A>> fa) =>
            ApplTryAsync< Task<A>, Task<B>>.Inst.Apply(
                 MTryAsync< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Task<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Task<A>>`</param>
        /// <returns>`TryAsync<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Task<A>> fa, TryAsync<Task<B>> fb) =>
            ApplTryAsync< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Try<A>> ma) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Try<B>> bindT< A, B>(TryAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryAsync<B>>`</returns>
        [Pure]
        public static Try<TryAsync<B>> traverse< A, B>(TryAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryAsync<A>>`</returns>
        [Pure]
        public static Try<TryAsync<A>> sequence< A>(TryAsync<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Try<B>> mapT< A, B>(TryAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Try<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Try<A>> filterT< A>(TryAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Try<A>> plusT<NUM,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Try<A>> subtractT<NUM,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Try<A>> productT<NUM,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Try<A>> divideT<NUM,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Try<A>> appendT<SEMI,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Try<A>> x, TryAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Try<A>>`</param>
        /// <returns>`TryAsync<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Try<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Try<A>> fa) =>
            ApplTryAsync< Try<A>, Try<B>>.Inst.Apply(
                 MTryAsync< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Try<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Try<A>>`</param>
        /// <returns>`TryAsync<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Try<A>> fa, TryAsync<Try<B>> fb) =>
            ApplTryAsync< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<TryAsync<A>> ma) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> bindT< A, B>(TryAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryAsync<B>>`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> traverse< A, B>(TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryAsync<A>>`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> sequence< A>(TryAsync<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> mapT< A, B>(TryAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryAsync<TryAsync<B>>, TryAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> filterT< A>(TryAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryAsync<TryAsync<A>>, TryAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> plusT<NUM,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> subtractT<NUM,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> productT<NUM,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> divideT<NUM,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryAsync<A>> appendT<SEMI,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<TryAsync<A>> x, TryAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryAsync<A>>`</param>
        /// <returns>`TryAsync<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryAsync<B>> applyT< A, B>(Func<A, B> fab, TryAsync<TryAsync<A>> fa) =>
            ApplTryAsync< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryAsync< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<TryAsync<A>>`</param>
        /// <returns>`TryAsync<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<TryAsync<A>> fa, TryAsync<TryAsync<B>> fb) =>
            ApplTryAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<TryOption<A>> ma) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> bindT< A, B>(TryAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryAsync<B>>`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> traverse< A, B>(TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryAsync<A>>`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> sequence< A>(TryAsync<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> mapT< A, B>(TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOption<A>> filterT< A>(TryAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> plusT<NUM,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> subtractT<NUM,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> productT<NUM,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> divideT<NUM,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> appendT<SEMI,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryOption<A>>`</param>
        /// <returns>`TryAsync<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> applyT< A, B>(Func<A, B> fab, TryAsync<TryOption<A>> fa) =>
            ApplTryAsync< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryAsync< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryOption<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<TryOption<A>>`</param>
        /// <returns>`TryAsync<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<TryOption<A>> fa, TryAsync<TryOption<B>> fb) =>
            ApplTryAsync< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<TryOptionAsync<A>> ma) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> bindT< A, B>(TryAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryAsync<B>>`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> traverse< A, B>(TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> sequence< A>(TryAsync<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> mapT< A, B>(TryAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> filterT< A>(TryAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryAsync<TryOptionAsync<A>>, TryAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> plusT<NUM,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> subtractT<NUM,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> productT<NUM,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> divideT<NUM,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> appendT<SEMI,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<TryOptionAsync<A>> x, TryAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryOptionAsync<A>>`</param>
        /// <returns>`TryAsync<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryAsync<TryOptionAsync<A>> fa) =>
            ApplTryAsync< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<TryOptionAsync<A>>`</param>
        /// <returns>`TryAsync<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<TryOptionAsync<A>> fa, TryAsync<TryOptionAsync<B>> fb) =>
            ApplTryAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<IEnumerable<A>> ma) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> bindT< A, B>(TryAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryAsync<B>>`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> traverse< A, B>(TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryAsync<A>>`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> sequence< A>(TryAsync<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> mapT< A, B>(TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> filterT< A>(TryAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> plusT<NUM,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> subtractT<NUM,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> productT<NUM,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> divideT<NUM,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> appendT<SEMI,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<IEnumerable<A>>`</param>
        /// <returns>`TryAsync<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, TryAsync<IEnumerable<A>> fa) =>
            ApplTryAsync< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryAsync< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<IEnumerable<A>>`</param>
        /// <returns>`TryAsync<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<IEnumerable<A>> fa, TryAsync<IEnumerable<B>> fb) =>
            ApplTryAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(TryAsync<Set<A>> ma) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Set<B>> bindT< A, B>(TryAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryAsync<B>>`</returns>
        [Pure]
        public static Set<TryAsync<B>> traverse< A, B>(TryAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryAsync<A>>`</returns>
        [Pure]
        public static Set<TryAsync<A>> sequence< A>(TryAsync<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Set<B>> mapT< A, B>(TryAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryAsync<Set<A>> ma, Action<A> f) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Set<A>> filterT< A>(TryAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Set<A>> plusT<NUM,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Set<A>> subtractT<NUM,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Set<A>> productT<NUM,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Set<A>> divideT<NUM,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Set<A>> appendT<SEMI,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryAsync<Set<A>> x, TryAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Set<A>>`</param>
        /// <returns>`TryAsync<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Set<B>> applyT< A, B>(Func<A, B> fab, TryAsync<Set<A>> fa) =>
            ApplTryAsync< Set<A>, Set<B>>.Inst.Apply(
                 MTryAsync< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync<Set<A>>`</param>
        /// <param name="fb">Monad of `TryAsync<Set<A>>`</param>
        /// <returns>`TryAsync<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryAsync<Set<A>> fa, TryAsync<Set<B>> fb) =>
            ApplTryAsync< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Arr<A>> ma) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> bindT< A, B>(TryOption<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOption<B>>`</returns>
        [Pure]
        public static Arr<TryOption<B>> traverse< A, B>(TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOption<A>>`</returns>
        [Pure]
        public static Arr<TryOption<A>> sequence< A>(TryOption<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> mapT< A, B>(TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Arr<A>> ma, Action<A> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Arr<A>> filterT< A>(TryOption<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Arr<A>> plusT<NUM,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Arr<A>> subtractT<NUM,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Arr<A>> productT<NUM,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Arr<A>> divideT<NUM,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Arr<A>> appendT<SEMI,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Arr<A>> x, TryOption<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Arr<A>>`</param>
        /// <returns>`TryOption<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Arr<B>> applyT< A, B>(Func<A, B> fab, TryOption<Arr<A>> fa) =>
            ApplTryOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Arr<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Arr<A>>`</param>
        /// <returns>`TryOption<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Arr<A>> fa, TryOption<Arr<B>> fb) =>
            ApplTryOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<HashSet<A>> ma) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> bindT< A, B>(TryOption<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOption<B>>`</returns>
        [Pure]
        public static HashSet<TryOption<B>> traverse< A, B>(TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOption<A>>`</returns>
        [Pure]
        public static HashSet<TryOption<A>> sequence< A>(TryOption<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> mapT< A, B>(TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<HashSet<A>> filterT< A>(TryOption<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<HashSet<A>> plusT<NUM,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<HashSet<A>> subtractT<NUM,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> productT<NUM,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> divideT<NUM,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> appendT<SEMI,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<HashSet<A>>`</param>
        /// <returns>`TryOption<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> applyT< A, B>(Func<A, B> fab, TryOption<HashSet<A>> fa) =>
            ApplTryOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<HashSet<A>>`</param>
        /// <param name="fb">Monad of `TryOption<HashSet<A>>`</param>
        /// <returns>`TryOption<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<HashSet<A>> fa, TryOption<HashSet<B>> fb) =>
            ApplTryOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Lst<A>> ma) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> bindT< A, B>(TryOption<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOption<B>>`</returns>
        [Pure]
        public static Lst<TryOption<B>> traverse< A, B>(TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOption<A>>`</returns>
        [Pure]
        public static Lst<TryOption<A>> sequence< A>(TryOption<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> mapT< A, B>(TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Lst<A>> ma, Action<A> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Lst<A>> filterT< A>(TryOption<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Lst<A>> plusT<NUM,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Lst<A>> subtractT<NUM,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Lst<A>> productT<NUM,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Lst<A>> divideT<NUM,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Lst<A>> appendT<SEMI,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Lst<A>> x, TryOption<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Lst<A>>`</param>
        /// <returns>`TryOption<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Lst<B>> applyT< A, B>(Func<A, B> fab, TryOption<Lst<A>> fa) =>
            ApplTryOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Lst<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Lst<A>>`</param>
        /// <returns>`TryOption<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Lst<A>> fa, TryOption<Lst<B>> fb) =>
            ApplTryOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Option<A>> ma) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> bindT< A, B>(TryOption<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOption<B>>`</returns>
        [Pure]
        public static Option<TryOption<B>> traverse< A, B>(TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOption<A>>`</returns>
        [Pure]
        public static Option<TryOption<A>> sequence< A>(TryOption<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> mapT< A, B>(TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Option<A>> ma, Action<A> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Option<A>> filterT< A>(TryOption<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Option<A>> plusT<NUM,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Option<A>> subtractT<NUM,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Option<A>> productT<NUM,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Option<A>> divideT<NUM,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Option<A>> appendT<SEMI,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Option<A>> x, TryOption<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Option<A>>`</param>
        /// <returns>`TryOption<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Option<B>> applyT< A, B>(Func<A, B> fab, TryOption<Option<A>> fa) =>
            ApplTryOption< Option<A>, Option<B>>.Inst.Apply(
                 MTryOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Option<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Option<A>>`</param>
        /// <returns>`TryOption<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Option<A>> fa, TryOption<Option<B>> fb) =>
            ApplTryOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<OptionAsync<A>> ma) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> bindT< A, B>(TryOption<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOption<B>>`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> traverse< A, B>(TryOption<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> sequence< A>(TryOption<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> mapT< A, B>(TryOption<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> filterT< A>(TryOption<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> plusT<NUM,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> subtractT<NUM,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> productT<NUM,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> divideT<NUM,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> appendT<SEMI,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<OptionAsync<A>>`</param>
        /// <returns>`TryOption<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryOption<OptionAsync<A>> fa) =>
            ApplTryOption< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MTryOption< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOption<OptionAsync<A>>`</param>
        /// <returns>`TryOption<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<OptionAsync<A>> fa, TryOption<OptionAsync<B>> fb) =>
            ApplTryOption< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MTryOption< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<OptionUnsafe<A>> ma) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> bindT< A, B>(TryOption<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOption<B>>`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> traverse< A, B>(TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOption<A>>`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> sequence< A>(TryOption<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> mapT< A, B>(TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> filterT< A>(TryOption<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> plusT<NUM,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> subtractT<NUM,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> productT<NUM,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> divideT<NUM,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> appendT<SEMI,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<OptionUnsafe<A>>`</param>
        /// <returns>`TryOption<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, TryOption<OptionUnsafe<A>> fa) =>
            ApplTryOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `TryOption<OptionUnsafe<A>>`</param>
        /// <returns>`TryOption<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<OptionUnsafe<A>> fa, TryOption<OptionUnsafe<B>> fb) =>
            ApplTryOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryOption<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryOption<Either<L, A>> ma) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> bindT<L, A, B>(TryOption<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOption<B>>`</returns>
        [Pure]
        public static Either<L, TryOption<B>> traverse<L, A, B>(TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOption<A>>`</returns>
        [Pure]
        public static Either<L, TryOption<A>> sequence<L, A>(TryOption<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> mapT<L, A, B>(TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryOption<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Either<L, A>> filterT<L, A>(TryOption<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Either<L, A>> plusT<NUM, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Either<L, A>> subtractT<NUM, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> productT<NUM, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> divideT<NUM, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> appendT<SEMI, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Either<L, A>>`</param>
        /// <returns>`TryOption<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, TryOption<Either<L, A>> fa) =>
            ApplTryOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Either<L, A>>`</param>
        /// <param name="fb">Monad of `TryOption<Either<L, A>>`</param>
        /// <returns>`TryOption<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryOption<Either<L, A>> fa, TryOption<Either<L, B>> fb) =>
            ApplTryOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryOption<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryOption<EitherUnsafe<L, A>> ma) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> bindT<L, A, B>(TryOption<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOption<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> traverse<L, A, B>(TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOption<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> sequence<L, A>(TryOption<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> mapT<L, A, B>(TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryOption<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> filterT<L, A>(TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> plusT<NUM, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> subtractT<NUM, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> productT<NUM, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> divideT<NUM, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> appendT<SEMI, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryOption<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, TryOption<EitherUnsafe<L, A>> fa) =>
            ApplTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `TryOption<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryOption<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryOption<EitherUnsafe<L, A>> fa, TryOption<EitherUnsafe<L, B>> fb) =>
            ApplTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Task<A>> ma) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> bindT< A, B>(TryOption<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOption<B>>`</returns>
        [Pure]
        public static Task<TryOption<B>> traverse< A, B>(TryOption<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOption<A>>`</returns>
        [Pure]
        public static Task<TryOption<A>> sequence< A>(TryOption<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> mapT< A, B>(TryOption<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Task<A>> ma, Action<A> f) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Task<A>> filterT< A>(TryOption<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Task<A>> plusT<NUM,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Task<A>> subtractT<NUM,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Task<A>> productT<NUM,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Task<A>> divideT<NUM,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Task<A>> appendT<SEMI,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Task<A>> x, TryOption<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Task<A>>`</param>
        /// <returns>`TryOption<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Task<B>> applyT< A, B>(Func<A, B> fab, TryOption<Task<A>> fa) =>
            ApplTryOption< Task<A>, Task<B>>.Inst.Apply(
                 MTryOption< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Task<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Task<A>>`</param>
        /// <returns>`TryOption<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Task<A>> fa, TryOption<Task<B>> fb) =>
            ApplTryOption< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryOption< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Try<A>> ma) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> bindT< A, B>(TryOption<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOption<B>>`</returns>
        [Pure]
        public static Try<TryOption<B>> traverse< A, B>(TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOption<A>>`</returns>
        [Pure]
        public static Try<TryOption<A>> sequence< A>(TryOption<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> mapT< A, B>(TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Try<A>> ma, Action<A> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Try<A>> filterT< A>(TryOption<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Try<A>> plusT<NUM,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Try<A>> subtractT<NUM,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Try<A>> productT<NUM,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Try<A>> divideT<NUM,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Try<A>> appendT<SEMI,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Try<A>> x, TryOption<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Try<A>>`</param>
        /// <returns>`TryOption<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Try<B>> applyT< A, B>(Func<A, B> fab, TryOption<Try<A>> fa) =>
            ApplTryOption< Try<A>, Try<B>>.Inst.Apply(
                 MTryOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Try<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Try<A>>`</param>
        /// <returns>`TryOption<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Try<A>> fa, TryOption<Try<B>> fb) =>
            ApplTryOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<TryAsync<A>> ma) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> bindT< A, B>(TryOption<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOption<B>>`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> traverse< A, B>(TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOption<A>>`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> sequence< A>(TryOption<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> mapT< A, B>(TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> filterT< A>(TryOption<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> plusT<NUM,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> subtractT<NUM,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> productT<NUM,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> divideT<NUM,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> appendT<SEMI,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryAsync<A>>`</param>
        /// <returns>`TryOption<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> applyT< A, B>(Func<A, B> fab, TryOption<TryAsync<A>> fa) =>
            ApplTryOption< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryOption< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOption<TryAsync<A>>`</param>
        /// <returns>`TryOption<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<TryAsync<A>> fa, TryOption<TryAsync<B>> fb) =>
            ApplTryOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<TryOption<A>> ma) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> bindT< A, B>(TryOption<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOption<B>>`</returns>
        [Pure]
        public static TryOption<TryOption<B>> traverse< A, B>(TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOption<A>>`</returns>
        [Pure]
        public static TryOption<TryOption<A>> sequence< A>(TryOption<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> mapT< A, B>(TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOption<A>> filterT< A>(TryOption<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOption<A>> plusT<NUM,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOption<A>> subtractT<NUM,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> productT<NUM,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> divideT<NUM,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> appendT<SEMI,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryOption<A>>`</param>
        /// <returns>`TryOption<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> applyT< A, B>(Func<A, B> fab, TryOption<TryOption<A>> fa) =>
            ApplTryOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryOption<A>>`</param>
        /// <param name="fb">Monad of `TryOption<TryOption<A>>`</param>
        /// <returns>`TryOption<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<TryOption<A>> fa, TryOption<TryOption<B>> fb) =>
            ApplTryOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<TryOptionAsync<A>> ma) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> bindT< A, B>(TryOption<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOption<B>>`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> traverse< A, B>(TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> sequence< A>(TryOption<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> mapT< A, B>(TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> filterT< A>(TryOption<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> plusT<NUM,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> subtractT<NUM,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> productT<NUM,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> divideT<NUM,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> appendT<SEMI,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryOptionAsync<A>>`</param>
        /// <returns>`TryOption<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryOption<TryOptionAsync<A>> fa) =>
            ApplTryOption< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOption<TryOptionAsync<A>>`</param>
        /// <returns>`TryOption<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<TryOptionAsync<A>> fa, TryOption<TryOptionAsync<B>> fb) =>
            ApplTryOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<IEnumerable<A>> ma) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> bindT< A, B>(TryOption<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOption<B>>`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> traverse< A, B>(TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOption<A>>`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> sequence< A>(TryOption<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> mapT< A, B>(TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> filterT< A>(TryOption<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> plusT<NUM,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> subtractT<NUM,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> productT<NUM,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> divideT<NUM,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> appendT<SEMI,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<IEnumerable<A>>`</param>
        /// <returns>`TryOption<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, TryOption<IEnumerable<A>> fa) =>
            ApplTryOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `TryOption<IEnumerable<A>>`</param>
        /// <returns>`TryOption<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<IEnumerable<A>> fa, TryOption<IEnumerable<B>> fb) =>
            ApplTryOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOption<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOption<Set<A>> ma) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> bindT< A, B>(TryOption<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryOption<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOption<B>>`</returns>
        [Pure]
        public static Set<TryOption<B>> traverse< A, B>(TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryOption<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOption<A>>`</returns>
        [Pure]
        public static Set<TryOption<A>> sequence< A>(TryOption<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> mapT< A, B>(TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOption<Set<A>> ma, Action<A> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Set<A>> filterT< A>(TryOption<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Set<A>> plusT<NUM,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Set<A>> subtractT<NUM,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Set<A>> productT<NUM,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Set<A>> divideT<NUM,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Set<A>> appendT<SEMI,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOption<Set<A>> x, TryOption<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption<Set<A>>`</param>
        /// <returns>`TryOption<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Set<B>> applyT< A, B>(Func<A, B> fab, TryOption<Set<A>> fa) =>
            ApplTryOption< Set<A>, Set<B>>.Inst.Apply(
                 MTryOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption<Set<A>>`</param>
        /// <param name="fb">Monad of `TryOption<Set<A>>`</param>
        /// <returns>`TryOption<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOption<Set<A>> fa, TryOption<Set<B>> fb) =>
            ApplTryOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Arr<A>> ma) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> bindT< A, B>(TryOptionAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> mapT< A, B>(TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Arr<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> filterT< A>(TryOptionAsync<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> plusT<NUM,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> subtractT<NUM,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> productT<NUM,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> divideT<NUM,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> appendT<SEMI,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Arr<A>>`</param>
        /// <returns>`TryOptionAsync<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Arr<A>> fa) =>
            ApplTryOptionAsync< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Arr<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Arr<A>>`</param>
        /// <returns>`TryOptionAsync<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Arr<A>> fa, TryOptionAsync<Arr<B>> fb) =>
            ApplTryOptionAsync< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryOptionAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<HashSet<A>> ma) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> bindT< A, B>(TryOptionAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOptionAsync<B>>`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<TryOptionAsync<A>>`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> sequence< A>(TryOptionAsync<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> mapT< A, B>(TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> filterT< A>(TryOptionAsync<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> plusT<NUM,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> subtractT<NUM,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> productT<NUM,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> divideT<NUM,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> appendT<SEMI,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<HashSet<A>>`</param>
        /// <returns>`TryOptionAsync<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<HashSet<A>> fa) =>
            ApplTryOptionAsync< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryOptionAsync< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<HashSet<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<HashSet<A>>`</param>
        /// <returns>`TryOptionAsync<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<HashSet<A>> fa, TryOptionAsync<HashSet<B>> fb) =>
            ApplTryOptionAsync< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryOptionAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Lst<A>> ma) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> bindT< A, B>(TryOptionAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> mapT< A, B>(TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Lst<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> filterT< A>(TryOptionAsync<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> plusT<NUM,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> subtractT<NUM,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> productT<NUM,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> divideT<NUM,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> appendT<SEMI,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Lst<A>>`</param>
        /// <returns>`TryOptionAsync<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Lst<A>> fa) =>
            ApplTryOptionAsync< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Lst<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Lst<A>>`</param>
        /// <returns>`TryOptionAsync<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Lst<A>> fa, TryOptionAsync<Lst<B>> fb) =>
            ApplTryOptionAsync< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryOptionAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Option<A>> ma) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> bindT< A, B>(TryOptionAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> mapT< A, B>(TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Option<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> filterT< A>(TryOptionAsync<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> plusT<NUM,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> subtractT<NUM,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> productT<NUM,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> divideT<NUM,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> appendT<SEMI,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Option<A>>`</param>
        /// <returns>`TryOptionAsync<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Option<A>> fa) =>
            ApplTryOptionAsync< Option<A>, Option<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Option<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Option<A>>`</param>
        /// <returns>`TryOptionAsync<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Option<A>> fa, TryOptionAsync<Option<B>> fb) =>
            ApplTryOptionAsync< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryOptionAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<OptionAsync<A>> ma) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> bindT< A, B>(TryOptionAsync<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOptionAsync<B>>`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<TryOptionAsync<B>>, OptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static OptionAsync<TryOptionAsync<A>> sequence< A>(TryOptionAsync<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> mapT< A, B>(TryOptionAsync<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MTryOptionAsync<OptionAsync<B>>, TryOptionAsync<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> filterT< A>(TryOptionAsync<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionAsync<A>>, TryOptionAsync<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> plusT<NUM,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> subtractT<NUM,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> productT<NUM,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> divideT<NUM,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<A>> appendT<SEMI,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<OptionAsync<A>> x, TryOptionAsync<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<OptionAsync<A>>`</param>
        /// <returns>`TryOptionAsync<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<OptionAsync<A>> fa) =>
            ApplTryOptionAsync< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MTryOptionAsync< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<OptionAsync<A>>`</param>
        /// <returns>`TryOptionAsync<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<OptionAsync<A>> fa, TryOptionAsync<OptionAsync<B>> fb) =>
            ApplTryOptionAsync< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MTryOptionAsync< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<OptionUnsafe<A>> ma) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> bindT< A, B>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<B>>`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<TryOptionAsync<A>>`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> sequence< A>(TryOptionAsync<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> mapT< A, B>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> filterT< A>(TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> plusT<NUM,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> subtractT<NUM,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> productT<NUM,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> divideT<NUM,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> appendT<SEMI,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<OptionUnsafe<A>>`</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<OptionUnsafe<A>> fa) =>
            ApplTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryOptionAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<OptionUnsafe<A>>`</param>
        /// <returns>`TryOptionAsync<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<OptionUnsafe<A>> fa, TryOptionAsync<OptionUnsafe<B>> fb) =>
            ApplTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryOptionAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryOptionAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryOptionAsync<Either<L, A>> ma) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> bindT<L, A, B>(TryOptionAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOptionAsync<B>>`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> traverse<L, A, B>(TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> sequence<L, A>(TryOptionAsync<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> mapT<L, A, B>(TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryOptionAsync<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> filterT<L, A>(TryOptionAsync<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> plusT<NUM, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> subtractT<NUM, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> productT<NUM, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> divideT<NUM, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> appendT<SEMI, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Either<L, A>>`</param>
        /// <returns>`TryOptionAsync<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, TryOptionAsync<Either<L, A>> fa) =>
            ApplTryOptionAsync< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryOptionAsync< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Either<L, A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Either<L, A>>`</param>
        /// <returns>`TryOptionAsync<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Either<L, A>> fa, TryOptionAsync<Either<L, B>> fb) =>
            ApplTryOptionAsync< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryOptionAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> bindT<L, A, B>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> traverse<L, A, B>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, TryOptionAsync<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> sequence<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> mapT<L, A, B>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> filterT<L, A>(TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> plusT<NUM, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> subtractT<NUM, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> productT<NUM, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> divideT<NUM, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> appendT<SEMI, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, TryOptionAsync<EitherUnsafe<L, A>> fa) =>
            ApplTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryOptionAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<EitherUnsafe<L, A>>`</param>
        /// <returns>`TryOptionAsync<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, TryOptionAsync<EitherUnsafe<L, A>> fa, TryOptionAsync<EitherUnsafe<L, B>> fb) =>
            ApplTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryOptionAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Task<A>> ma) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> bindT< A, B>(TryOptionAsync<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Task<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<TryOptionAsync<B>>, Task<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Task<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> mapT< A, B>(TryOptionAsync<Task<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MTryOptionAsync<Task<B>>, TryOptionAsync<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Task<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Task<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> filterT< A>(TryOptionAsync<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MTryOptionAsync<Task<A>>, TryOptionAsync<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> plusT<NUM,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> subtractT<NUM,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> productT<NUM,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> divideT<NUM,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Task<A>> appendT<SEMI,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Task<A>> x, TryOptionAsync<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Task<A>>`</param>
        /// <returns>`TryOptionAsync<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Task<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Task<A>> fa) =>
            ApplTryOptionAsync< Task<A>, Task<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Task<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Task<A>>`</param>
        /// <returns>`TryOptionAsync<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Task<A>> fa, TryOptionAsync<Task<B>> fb) =>
            ApplTryOptionAsync< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MTryOptionAsync< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Try<A>> ma) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> bindT< A, B>(TryOptionAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> mapT< A, B>(TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Try<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> filterT< A>(TryOptionAsync<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> plusT<NUM,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> subtractT<NUM,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> productT<NUM,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> divideT<NUM,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> appendT<SEMI,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Try<A>>`</param>
        /// <returns>`TryOptionAsync<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Try<A>> fa) =>
            ApplTryOptionAsync< Try<A>, Try<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Try<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Try<A>>`</param>
        /// <returns>`TryOptionAsync<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Try<A>> fa, TryOptionAsync<Try<B>> fb) =>
            ApplTryOptionAsync< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryOptionAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<TryAsync<A>> ma) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> bindT< A, B>(TryOptionAsync<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOptionAsync<B>>`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<TryOptionAsync<B>>, TryAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static TryAsync<TryOptionAsync<A>> sequence< A>(TryOptionAsync<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> mapT< A, B>(TryOptionAsync<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryAsync<B>>, TryOptionAsync<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<TryAsync<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> filterT< A>(TryOptionAsync<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryAsync<A>>, TryOptionAsync<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> plusT<NUM,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> subtractT<NUM,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> productT<NUM,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> divideT<NUM,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<A>> appendT<SEMI,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<TryAsync<A>> x, TryOptionAsync<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryAsync<A>>`</param>
        /// <returns>`TryOptionAsync<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<TryAsync<A>> fa) =>
            ApplTryOptionAsync< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<TryAsync<A>>`</param>
        /// <returns>`TryOptionAsync<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<TryAsync<A>> fa, TryOptionAsync<TryAsync<B>> fb) =>
            ApplTryOptionAsync< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<TryOption<A>> ma) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> bindT< A, B>(TryOptionAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOptionAsync<B>>`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<TryOptionAsync<A>>`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> sequence< A>(TryOptionAsync<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> mapT< A, B>(TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> filterT< A>(TryOptionAsync<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> plusT<NUM,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> subtractT<NUM,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> productT<NUM,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> divideT<NUM,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> appendT<SEMI,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryOption<A>>`</param>
        /// <returns>`TryOptionAsync<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<TryOption<A>> fa) =>
            ApplTryOptionAsync< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryOption<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<TryOption<A>>`</param>
        /// <returns>`TryOptionAsync<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<TryOption<A>> fa, TryOptionAsync<TryOption<B>> fb) =>
            ApplTryOptionAsync< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<TryOptionAsync<A>> ma) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> bindT< A, B>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<B>>`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> sequence< A>(TryOptionAsync<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> mapT< A, B>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MTryOptionAsync<TryOptionAsync<B>>, TryOptionAsync<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> filterT< A>(TryOptionAsync<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MTryOptionAsync<TryOptionAsync<A>>, TryOptionAsync<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> plusT<NUM,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> subtractT<NUM,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> productT<NUM,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> divideT<NUM,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<A>> appendT<SEMI,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<TryOptionAsync<A>> x, TryOptionAsync<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryOptionAsync<A>>`</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<TryOptionAsync<A>> fa) =>
            ApplTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MTryOptionAsync< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<TryOptionAsync<A>>`</param>
        /// <returns>`TryOptionAsync<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<TryOptionAsync<A>> fa, TryOptionAsync<TryOptionAsync<B>> fb) =>
            ApplTryOptionAsync< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MTryOptionAsync< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<IEnumerable<A>> ma) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> bindT< A, B>(TryOptionAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOptionAsync<B>>`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> sequence< A>(TryOptionAsync<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> mapT< A, B>(TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> filterT< A>(TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> plusT<NUM,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> subtractT<NUM,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> productT<NUM,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> divideT<NUM,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> appendT<SEMI,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<IEnumerable<A>>`</param>
        /// <returns>`TryOptionAsync<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<IEnumerable<A>> fa) =>
            ApplTryOptionAsync< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryOptionAsync< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<IEnumerable<A>>`</param>
        /// <returns>`TryOptionAsync<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<IEnumerable<A>> fa, TryOptionAsync<IEnumerable<B>> fb) =>
            ApplTryOptionAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryOptionAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(TryOptionAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(TryOptionAsync<Set<A>> ma) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> bindT< A, B>(TryOptionAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOptionAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryOptionAsync<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOptionAsync<B>>`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> traverse< A, B>(TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOptionAsync<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<TryOptionAsync<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOptionAsync<A>>`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> sequence< A>(TryOptionAsync<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> mapT< A, B>(TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(TryOptionAsync<Set<A>> ma, Action<A> f) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> filterT< A>(TryOptionAsync<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> plusT<NUM,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> subtractT<NUM,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> productT<NUM,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> divideT<NUM,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> appendT<SEMI,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Set<A>>`</param>
        /// <returns>`TryOptionAsync<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> applyT< A, B>(Func<A, B> fab, TryOptionAsync<Set<A>> fa) =>
            ApplTryOptionAsync< Set<A>, Set<B>>.Inst.Apply(
                 MTryOptionAsync< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync<Set<A>>`</param>
        /// <param name="fb">Monad of `TryOptionAsync<Set<A>>`</param>
        /// <returns>`TryOptionAsync<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, TryOptionAsync<Set<A>> fa, TryOptionAsync<Set<B>> fb) =>
            ApplTryOptionAsync< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryOptionAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Arr<A>> ma) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> bindT< A, B>(IEnumerable<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<IEnumerable<B>>`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> traverse< A, B>(IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<IEnumerable<A>>`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> sequence< A>(IEnumerable<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> mapT< A, B>(IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSeq<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Arr<A>> ma, Action<A> f) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Arr<A>> filterT< A>(IEnumerable<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> plusT<NUM,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> subtractT<NUM,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> productT<NUM,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> divideT<NUM,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> appendT<SEMI,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Arr<A>>`</param>
        /// <returns>`IEnumerable<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Arr<A>> fa) =>
            ApplSeq< Arr<A>, Arr<B>>.Inst.Apply(
                 MSeq< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Arr<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Arr<A>>`</param>
        /// <returns>`IEnumerable<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Arr<A>> fa, IEnumerable<Arr<B>> fb) =>
            ApplSeq< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSeq< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<HashSet<A>> ma) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> bindT< A, B>(IEnumerable<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<IEnumerable<B>>`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> traverse< A, B>(IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<IEnumerable<A>>`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> sequence< A>(IEnumerable<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> mapT< A, B>(IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSeq<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<HashSet<A>> ma, Action<A> f) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> filterT< A>(IEnumerable<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> plusT<NUM,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> subtractT<NUM,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> productT<NUM,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> divideT<NUM,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> appendT<SEMI,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<HashSet<A>>`</param>
        /// <returns>`IEnumerable<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<HashSet<A>> fa) =>
            ApplSeq< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSeq< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<HashSet<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<HashSet<A>>`</param>
        /// <returns>`IEnumerable<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<HashSet<A>> fa, IEnumerable<HashSet<B>> fb) =>
            ApplSeq< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSeq< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Lst<A>> ma) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> bindT< A, B>(IEnumerable<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<IEnumerable<B>>`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> traverse< A, B>(IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<IEnumerable<A>>`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> sequence< A>(IEnumerable<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> mapT< A, B>(IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSeq<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Lst<A>> ma, Action<A> f) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Lst<A>> filterT< A>(IEnumerable<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> plusT<NUM,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> subtractT<NUM,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> productT<NUM,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> divideT<NUM,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> appendT<SEMI,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Lst<A>>`</param>
        /// <returns>`IEnumerable<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Lst<A>> fa) =>
            ApplSeq< Lst<A>, Lst<B>>.Inst.Apply(
                 MSeq< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Lst<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Lst<A>>`</param>
        /// <returns>`IEnumerable<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Lst<A>> fa, IEnumerable<Lst<B>> fb) =>
            ApplSeq< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSeq< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Option<A>> ma) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> bindT< A, B>(IEnumerable<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<IEnumerable<B>>`</returns>
        [Pure]
        public static Option<IEnumerable<B>> traverse< A, B>(IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<IEnumerable<A>>`</returns>
        [Pure]
        public static Option<IEnumerable<A>> sequence< A>(IEnumerable<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> mapT< A, B>(IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSeq<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Option<A>> ma, Action<A> f) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Option<A>> filterT< A>(IEnumerable<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Option<A>> plusT<NUM,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Option<A>> subtractT<NUM,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> productT<NUM,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> divideT<NUM,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> appendT<SEMI,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Option<A>>`</param>
        /// <returns>`IEnumerable<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Option<A>> fa) =>
            ApplSeq< Option<A>, Option<B>>.Inst.Apply(
                 MSeq< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Option<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Option<A>>`</param>
        /// <returns>`IEnumerable<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Option<A>> fa, IEnumerable<Option<B>> fb) =>
            ApplSeq< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSeq< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<OptionAsync<A>> ma) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> bindT< A, B>(IEnumerable<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MSeq<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<IEnumerable<B>>`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> traverse< A, B>(IEnumerable<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> sequence< A>(IEnumerable<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> mapT< A, B>(IEnumerable<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MSeq<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> filterT< A>(IEnumerable<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MSeq<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> plusT<NUM,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> subtractT<NUM,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> productT<NUM,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> divideT<NUM,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> appendT<SEMI,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<OptionAsync<A>>`</param>
        /// <returns>`IEnumerable<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<OptionAsync<A>> fa) =>
            ApplSeq< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MSeq< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<OptionAsync<A>>`</param>
        /// <returns>`IEnumerable<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<OptionAsync<A>> fa, IEnumerable<OptionAsync<B>> fb) =>
            ApplSeq< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MSeq< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<OptionUnsafe<A>> ma) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> bindT< A, B>(IEnumerable<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<IEnumerable<B>>`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> traverse< A, B>(IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<IEnumerable<A>>`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> sequence< A>(IEnumerable<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> mapT< A, B>(IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSeq<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> filterT< A>(IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> plusT<NUM,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> subtractT<NUM,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> productT<NUM,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> divideT<NUM,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> appendT<SEMI,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<OptionUnsafe<A>>`</param>
        /// <returns>`IEnumerable<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<OptionUnsafe<A>> fa) =>
            ApplSeq< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSeq< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<OptionUnsafe<A>>`</param>
        /// <returns>`IEnumerable<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<OptionUnsafe<A>> fa, IEnumerable<OptionUnsafe<B>> fb) =>
            ApplSeq< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSeq< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(IEnumerable<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(IEnumerable<Either<L, A>> ma) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> bindT<L, A, B>(IEnumerable<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, IEnumerable<B>>`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> traverse<L, A, B>(IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, IEnumerable<A>>`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> sequence<L, A>(IEnumerable<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> mapT<L, A, B>(IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSeq<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(IEnumerable<Either<L, A>> ma, Action<A> f) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> filterT<L, A>(IEnumerable<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> plusT<NUM, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> subtractT<NUM, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> productT<NUM, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> divideT<NUM, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> appendT<SEMI, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Either<L, A>>`</param>
        /// <returns>`IEnumerable<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, IEnumerable<Either<L, A>> fa) =>
            ApplSeq< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSeq< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Either<L, A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Either<L, A>>`</param>
        /// <returns>`IEnumerable<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, IEnumerable<Either<L, A>> fa, IEnumerable<Either<L, B>> fb) =>
            ApplSeq< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSeq< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(IEnumerable<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(IEnumerable<EitherUnsafe<L, A>> ma) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> bindT<L, A, B>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> traverse<L, A, B>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, IEnumerable<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> sequence<L, A>(IEnumerable<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> mapT<L, A, B>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSeq<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(IEnumerable<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> filterT<L, A>(IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> plusT<NUM, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> subtractT<NUM, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> productT<NUM, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> divideT<NUM, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> appendT<SEMI, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<EitherUnsafe<L, A>>`</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, IEnumerable<EitherUnsafe<L, A>> fa) =>
            ApplSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSeq< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<EitherUnsafe<L, A>>`</param>
        /// <returns>`IEnumerable<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, IEnumerable<EitherUnsafe<L, A>> fa, IEnumerable<EitherUnsafe<L, B>> fb) =>
            ApplSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSeq< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Task<A>> ma) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> bindT< A, B>(IEnumerable<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<IEnumerable<B>>`</returns>
        [Pure]
        public static Task<IEnumerable<B>> traverse< A, B>(IEnumerable<Task<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<IEnumerable<A>>`</returns>
        [Pure]
        public static Task<IEnumerable<A>> sequence< A>(IEnumerable<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> mapT< A, B>(IEnumerable<Task<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSeq<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Task<A>> ma, Action<A> f) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> filterT< A>(IEnumerable<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSeq<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Task<A>> plusT<NUM,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Task<A>> subtractT<NUM,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> productT<NUM,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> divideT<NUM,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> appendT<SEMI,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Task<A>>`</param>
        /// <returns>`IEnumerable<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Task<A>> fa) =>
            ApplSeq< Task<A>, Task<B>>.Inst.Apply(
                 MSeq< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Task<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Task<A>>`</param>
        /// <returns>`IEnumerable<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Task<A>> fa, IEnumerable<Task<B>> fb) =>
            ApplSeq< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MSeq< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Try<A>> ma) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> bindT< A, B>(IEnumerable<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<IEnumerable<B>>`</returns>
        [Pure]
        public static Try<IEnumerable<B>> traverse< A, B>(IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<IEnumerable<A>>`</returns>
        [Pure]
        public static Try<IEnumerable<A>> sequence< A>(IEnumerable<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> mapT< A, B>(IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSeq<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Try<A>> ma, Action<A> f) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Try<A>> filterT< A>(IEnumerable<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Try<A>> plusT<NUM,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Try<A>> subtractT<NUM,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> productT<NUM,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> divideT<NUM,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> appendT<SEMI,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Try<A>>`</param>
        /// <returns>`IEnumerable<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Try<A>> fa) =>
            ApplSeq< Try<A>, Try<B>>.Inst.Apply(
                 MSeq< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Try<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Try<A>>`</param>
        /// <returns>`IEnumerable<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Try<A>> fa, IEnumerable<Try<B>> fb) =>
            ApplSeq< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSeq< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<TryAsync<A>> ma) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> bindT< A, B>(IEnumerable<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<IEnumerable<B>>`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> traverse< A, B>(IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> sequence< A>(IEnumerable<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> mapT< A, B>(IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSeq<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<TryAsync<A>> ma, Action<A> f) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> filterT< A>(IEnumerable<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSeq<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> plusT<NUM,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> subtractT<NUM,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> productT<NUM,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> divideT<NUM,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> appendT<SEMI,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryAsync<A>>`</param>
        /// <returns>`IEnumerable<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<TryAsync<A>> fa) =>
            ApplSeq< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MSeq< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<TryAsync<A>>`</param>
        /// <returns>`IEnumerable<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<TryAsync<A>> fa, IEnumerable<TryAsync<B>> fb) =>
            ApplSeq< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MSeq< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<TryOption<A>> ma) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> bindT< A, B>(IEnumerable<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<IEnumerable<B>>`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> traverse< A, B>(IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<IEnumerable<A>>`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> sequence< A>(IEnumerable<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> mapT< A, B>(IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSeq<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<TryOption<A>> ma, Action<A> f) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> filterT< A>(IEnumerable<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> plusT<NUM,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> subtractT<NUM,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> productT<NUM,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> divideT<NUM,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> appendT<SEMI,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryOption<A>>`</param>
        /// <returns>`IEnumerable<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<TryOption<A>> fa) =>
            ApplSeq< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSeq< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryOption<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<TryOption<A>>`</param>
        /// <returns>`IEnumerable<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<TryOption<A>> fa, IEnumerable<TryOption<B>> fb) =>
            ApplSeq< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSeq< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<TryOptionAsync<A>> ma) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> bindT< A, B>(IEnumerable<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<IEnumerable<B>>`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> traverse< A, B>(IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<IEnumerable<A>>`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> sequence< A>(IEnumerable<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> mapT< A, B>(IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSeq<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> filterT< A>(IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSeq<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> plusT<NUM,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> subtractT<NUM,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> productT<NUM,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> divideT<NUM,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> appendT<SEMI,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryOptionAsync<A>>`</param>
        /// <returns>`IEnumerable<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<TryOptionAsync<A>> fa) =>
            ApplSeq< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MSeq< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<TryOptionAsync<A>>`</param>
        /// <returns>`IEnumerable<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<TryOptionAsync<A>> fa, IEnumerable<TryOptionAsync<B>> fb) =>
            ApplSeq< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MSeq< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<IEnumerable<A>> ma) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> bindT< A, B>(IEnumerable<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<IEnumerable<B>>`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> traverse< A, B>(IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<IEnumerable<A>>`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> sequence< A>(IEnumerable<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> mapT< A, B>(IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSeq<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> filterT< A>(IEnumerable<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> plusT<NUM,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> subtractT<NUM,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> productT<NUM,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> divideT<NUM,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> appendT<SEMI,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<IEnumerable<A>>`</param>
        /// <returns>`IEnumerable<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<IEnumerable<A>> fa) =>
            ApplSeq< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSeq< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<IEnumerable<A>>`</param>
        /// <returns>`IEnumerable<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<IEnumerable<A>> fa, IEnumerable<IEnumerable<B>> fb) =>
            ApplSeq< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSeq< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(IEnumerable<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(IEnumerable<Set<A>> ma) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> bindT< A, B>(IEnumerable<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<IEnumerable<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<IEnumerable<B>>`</returns>
        [Pure]
        public static Set<IEnumerable<B>> traverse< A, B>(IEnumerable<Set<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<IEnumerable<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<IEnumerable<A>>`</returns>
        [Pure]
        public static Set<IEnumerable<A>> sequence< A>(IEnumerable<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> mapT< A, B>(IEnumerable<Set<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(IEnumerable<Set<A>> ma, Action<A> f) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Set<A>> filterT< A>(IEnumerable<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Set<A>> plusT<NUM,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Set<A>> subtractT<NUM,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> productT<NUM,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> divideT<NUM,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> appendT<SEMI,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Set<A>>`</param>
        /// <returns>`IEnumerable<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> applyT< A, B>(Func<A, B> fab, IEnumerable<Set<A>> fa) =>
            ApplSeq< Set<A>, Set<B>>.Inst.Apply(
                 MSeq< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable<Set<A>>`</param>
        /// <param name="fb">Monad of `IEnumerable<Set<A>>`</param>
        /// <returns>`IEnumerable<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, IEnumerable<Set<A>> fa, IEnumerable<Set<B>> fb) =>
            ApplSeq< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSeq< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class ArrT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Arr<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Arr<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Arr<A>> ma) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> bindT< A, B>(Set<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Set<B>>`</returns>
        [Pure]
        public static Arr<Set<B>> traverse< A, B>(Set<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Arr<A>>`, traverses the inner
        /// values of type `A`, and returns `Arr<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr<Set<A>>`</returns>
        [Pure]
        public static Arr<Set<A>> sequence< A>(Set<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Arr<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> mapT< A, B>(Set<Arr<A>> ma, Func<A, B> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Arr<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Arr<A>> ma, Action<A> f) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Arr<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Arr<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Arr<A>> filterT< A>(Set<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Arr<A>> plusT<NUM,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Arr<A>> subtractT<NUM,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Arr<A>> productT<NUM,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Arr<A>> divideT<NUM,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Arr<A>> appendT<SEMI,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Arr<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Arr<A>> x, Set<Arr<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Arr<A>>`</param>
        /// <returns>`Set<Arr<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Arr<B>> applyT< A, B>(Func<A, B> fab, Set<Arr<A>> fa) =>
            ApplSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Arr<A>>`</param>
        /// <param name="fb">Monad of `Set<Arr<A>>`</param>
        /// <returns>`Set<Arr<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Arr<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Arr<A>> fa, Set<Arr<B>> fb) =>
            ApplSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class HashSetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<HashSet<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<HashSet<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<HashSet<A>> ma) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> bindT< A, B>(Set<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Set<B>>`</returns>
        [Pure]
        public static HashSet<Set<B>> traverse< A, B>(Set<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<HashSet<A>>`, traverses the inner
        /// values of type `A`, and returns `HashSet<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet<Set<A>>`</returns>
        [Pure]
        public static HashSet<Set<A>> sequence< A>(Set<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<HashSet<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> mapT< A, B>(Set<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<HashSet<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<HashSet<A>> ma, Action<A> f) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<HashSet<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<HashSet<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<HashSet<A>> filterT< A>(Set<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<HashSet<A>> plusT<NUM,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<HashSet<A>> subtractT<NUM,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<HashSet<A>> productT<NUM,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<HashSet<A>> divideT<NUM,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<HashSet<A>> appendT<SEMI,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<HashSet<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<HashSet<A>> x, Set<HashSet<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<HashSet<A>>`</param>
        /// <returns>`Set<HashSet<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<HashSet<B>> applyT< A, B>(Func<A, B> fab, Set<HashSet<A>> fa) =>
            ApplSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<HashSet<A>>`</param>
        /// <param name="fb">Monad of `Set<HashSet<A>>`</param>
        /// <returns>`Set<HashSet<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<HashSet<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<HashSet<A>> fa, Set<HashSet<B>> fb) =>
            ApplSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class LstT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Lst<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Lst<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Lst<A>> ma) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> bindT< A, B>(Set<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Set<B>>`</returns>
        [Pure]
        public static Lst<Set<B>> traverse< A, B>(Set<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Lst<A>>`, traverses the inner
        /// values of type `A`, and returns `Lst<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst<Set<A>>`</returns>
        [Pure]
        public static Lst<Set<A>> sequence< A>(Set<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Lst<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> mapT< A, B>(Set<Lst<A>> ma, Func<A, B> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Lst<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Lst<A>> ma, Action<A> f) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Lst<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Lst<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Lst<A>> filterT< A>(Set<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Lst<A>> plusT<NUM,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Lst<A>> subtractT<NUM,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Lst<A>> productT<NUM,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Lst<A>> divideT<NUM,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Lst<A>> appendT<SEMI,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Lst<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Lst<A>> x, Set<Lst<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Lst<A>>`</param>
        /// <returns>`Set<Lst<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Lst<B>> applyT< A, B>(Func<A, B> fab, Set<Lst<A>> fa) =>
            ApplSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Lst<A>>`</param>
        /// <param name="fb">Monad of `Set<Lst<A>>`</param>
        /// <returns>`Set<Lst<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Lst<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Lst<A>> fa, Set<Lst<B>> fb) =>
            ApplSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Option<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Option<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Option<A>> ma) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> bindT< A, B>(Set<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Set<B>>`</returns>
        [Pure]
        public static Option<Set<B>> traverse< A, B>(Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Option<A>>`, traverses the inner
        /// values of type `A`, and returns `Option<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option<Set<A>>`</returns>
        [Pure]
        public static Option<Set<A>> sequence< A>(Set<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Option<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> mapT< A, B>(Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Option<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Option<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Option<A>> ma, Action<A> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Option<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Option<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Option<A>> filterT< A>(Set<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Option<A>> plusT<NUM,  A>(Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Option<A>> subtractT<NUM,  A>(Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Option<A>> productT<NUM,  A>(Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Option<A>> divideT<NUM,  A>(Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Option<A>> appendT<SEMI,  A>(Set<Option<A>> x, Set<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Option<A>> x, Set<Option<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Option<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Option<A>> x, Set<Option<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Option<A>>`</param>
        /// <returns>`Set<Option<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Option<B>> applyT< A, B>(Func<A, B> fab, Set<Option<A>> fa) =>
            ApplSet< Option<A>, Option<B>>.Inst.Apply(
                 MSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Option<A>>`</param>
        /// <param name="fb">Monad of `Set<Option<A>>`</param>
        /// <returns>`Set<Option<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Option<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Option<A>> fa, Set<Option<B>> fb) =>
            ApplSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<OptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<OptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<OptionAsync<A>> ma) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> bindT< A, B>(Set<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Set<B>>`</returns>
        [Pure]
        public static OptionAsync<Set<B>> traverse< A, B>(Set<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Traverse<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<OptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionAsync<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync<Set<A>>`</returns>
        [Pure]
        public static OptionAsync<Set<A>> sequence< A>(Set<OptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> mapT< A, B>(Set<OptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Map<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<OptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<OptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<OptionAsync<A>> ma, Action<A> f) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<OptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionAsync<A>> filterT< A>(Set<OptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>
                .Inst.Bind<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).Return(a)
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<OptionAsync<A>> plusT<NUM,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<OptionAsync<A>> subtractT<NUM,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> productT<NUM,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> divideT<NUM,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> appendT<SEMI,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<OptionAsync<A>>`</param>
        /// <returns>`Set<OptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> applyT< A, B>(Func<A, B> fab, Set<OptionAsync<A>> fa) =>
            ApplSet< OptionAsync<A>, OptionAsync<B>>.Inst.Apply(
                 MSet< Func<OptionAsync<A>, OptionAsync<B>>>.Inst.Return((OptionAsync<A> a) => ApplOptionAsync< A, B>.Inst.Apply(
                     MOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<OptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Set<OptionAsync<A>>`</param>
        /// <returns>`Set<OptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<OptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<OptionAsync<A>> fa, Set<OptionAsync<B>> fb) =>
            ApplSet< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>.Inst.Apply(
                MSet< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>.Inst.Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            ApplOptionAsync< A, B, C>.Inst.Apply(
                                MOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class OptionUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<OptionUnsafe<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<OptionUnsafe<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<OptionUnsafe<A>> ma) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> bindT< A, B>(Set<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Set<B>>`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> traverse< A, B>(Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<OptionUnsafe<A>>`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe<Set<A>>`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> sequence< A>(Set<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<OptionUnsafe<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> mapT< A, B>(Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<OptionUnsafe<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<OptionUnsafe<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<OptionUnsafe<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> filterT< A>(Set<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> plusT<NUM,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> subtractT<NUM,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> productT<NUM,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> divideT<NUM,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> appendT<SEMI,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<OptionUnsafe<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<OptionUnsafe<A>>`</param>
        /// <returns>`Set<OptionUnsafe<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> applyT< A, B>(Func<A, B> fab, Set<OptionUnsafe<A>> fa) =>
            ApplSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<OptionUnsafe<A>>`</param>
        /// <param name="fb">Monad of `Set<OptionUnsafe<A>>`</param>
        /// <returns>`Set<OptionUnsafe<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<OptionUnsafe<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<OptionUnsafe<A>> fa, Set<OptionUnsafe<B>> fb) =>
            ApplSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Either<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Set<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Either<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Set<Either<L, A>> ma) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> bindT<L, A, B>(Set<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Set<B>>`</returns>
        [Pure]
        public static Either<L, Set<B>> traverse<L, A, B>(Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Either<L, A>>`, traverses the inner
        /// values of type `A`, and returns `Either<L, Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either<L, Set<A>>`</returns>
        [Pure]
        public static Either<L, Set<A>> sequence<L, A>(Set<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Either<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> mapT<L, A, B>(Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Set<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Set<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Either<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Set<Either<L, A>> ma, Action<A> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Either<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Either<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Either<L, A>> filterT<L, A>(Set<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Either<L, A>> plusT<NUM, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Either<L, A>> subtractT<NUM, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Either<L, A>> productT<NUM, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Either<L, A>> divideT<NUM, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Either<L, A>> appendT<SEMI, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Either<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Set<Either<L, A>> x, Set<Either<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Either<L, A>>`</param>
        /// <returns>`Set<Either<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Either<L, B>> applyT<L, A, B>(Func<A, B> fab, Set<Either<L, A>> fa) =>
            ApplSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Either<L, A>>`</param>
        /// <param name="fb">Monad of `Set<Either<L, A>>`</param>
        /// <returns>`Set<Either<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Either<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Set<Either<L, A>> fa, Set<Either<L, B>> fb) =>
            ApplSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class EitherUnsafeT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static A sumT<NumA, L, A>(Set<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<EitherUnsafe<L, A>>`</returns>
        [Pure]
        public static int countT<L, A>(Set<EitherUnsafe<L, A>> ma) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> bindT<L, A, B>(Set<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Set<B>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> traverse<L, A, B>(Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<EitherUnsafe<L, A>>`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe<L, Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe<L, Set<A>>`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> sequence<L, A>(Set<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<EitherUnsafe<L, B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> mapT<L, A, B>(Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S, L, A>(Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S, L, A>(Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT<L, A>(Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT<L, A>(Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<EitherUnsafe<L, A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT<L, A>(Set<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<EitherUnsafe<L, A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> filterT<L, A>(Set<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> plusT<NUM, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> subtractT<NUM, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> productT<NUM, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> divideT<NUM, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> appendT<SEMI, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<EitherUnsafe<L, A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ, L, A>(Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<EitherUnsafe<L, A>>`</param>
        /// <returns>`Set<EitherUnsafe<L, B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> applyT<L, A, B>(Func<A, B> fab, Set<EitherUnsafe<L, A>> fa) =>
            ApplSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<EitherUnsafe<L, A>>`</param>
        /// <param name="fb">Monad of `Set<EitherUnsafe<L, A>>`</param>
        /// <returns>`Set<EitherUnsafe<L, B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, C>> applyT<L, A, B, C>(Func<A, B, C> fabc, Set<EitherUnsafe<L, A>> fa, Set<EitherUnsafe<L, B>> fb) =>
            ApplSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TaskT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Task<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Task<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Task<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Task<A>> ma) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> bindT< A, B>(Set<Task<A>> ma, Func<A, Task<B>> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Set<B>>`</returns>
        [Pure]
        public static Task<Set<B>> traverse< A, B>(Set<Task<A>> ma, Func<A, B> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Traverse<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Task<A>>`, traverses the inner
        /// values of type `A`, and returns `Task<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task<Set<A>>`</returns>
        [Pure]
        public static Task<Set<A>> sequence< A>(Set<Task<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Task<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> mapT< A, B>(Set<Task<A>> ma, Func<A, B> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Map<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Task<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Task<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Task<A>> ma, Action<A> f) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Task<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Task<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Task<A>> filterT< A>(Set<Task<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>
                .Inst.Bind<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).Return(a)
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Task<A>> plusT<NUM,  A>(Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Task<A>> subtractT<NUM,  A>(Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Task<A>> productT<NUM,  A>(Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Task<A>> divideT<NUM,  A>(Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Task<A>> appendT<SEMI,  A>(Set<Task<A>> x, Set<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Task<A>> x, Set<Task<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Task<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Task<A>> x, Set<Task<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Task<A>>`</param>
        /// <returns>`Set<Task<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Task<B>> applyT< A, B>(Func<A, B> fab, Set<Task<A>> fa) =>
            ApplSet< Task<A>, Task<B>>.Inst.Apply(
                 MSet< Func<Task<A>, Task<B>>>.Inst.Return((Task<A> a) => ApplTask< A, B>.Inst.Apply(
                     MTask< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Task<A>>`</param>
        /// <param name="fb">Monad of `Set<Task<A>>`</param>
        /// <returns>`Set<Task<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Task<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Task<A>> fa, Set<Task<B>> fb) =>
            ApplSet< Task<A>, Task<B>, Task<C>>.Inst.Apply(
                MSet< Func<Task<A>, Func<Task<B>, Task<C>>>>.Inst.Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            ApplTask< A, B, C>.Inst.Apply(
                                MTask< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Try<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Try<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Try<A>> ma) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> bindT< A, B>(Set<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Set<B>>`</returns>
        [Pure]
        public static Try<Set<B>> traverse< A, B>(Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Try<A>>`, traverses the inner
        /// values of type `A`, and returns `Try<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try<Set<A>>`</returns>
        [Pure]
        public static Try<Set<A>> sequence< A>(Set<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Try<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> mapT< A, B>(Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Try<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Try<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Try<A>> ma, Action<A> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Try<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Try<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Try<A>> filterT< A>(Set<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Try<A>> plusT<NUM,  A>(Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Try<A>> subtractT<NUM,  A>(Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Try<A>> productT<NUM,  A>(Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Try<A>> divideT<NUM,  A>(Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Try<A>> appendT<SEMI,  A>(Set<Try<A>> x, Set<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Try<A>> x, Set<Try<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Try<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Try<A>> x, Set<Try<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Try<A>>`</param>
        /// <returns>`Set<Try<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Try<B>> applyT< A, B>(Func<A, B> fab, Set<Try<A>> fa) =>
            ApplSet< Try<A>, Try<B>>.Inst.Apply(
                 MSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Try<A>>`</param>
        /// <param name="fb">Monad of `Set<Try<A>>`</param>
        /// <returns>`Set<Try<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Try<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Try<A>> fa, Set<Try<B>> fb) =>
            ApplSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<TryAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<TryAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<TryAsync<A>> ma) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> bindT< A, B>(Set<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Set<B>>`</returns>
        [Pure]
        public static TryAsync<Set<B>> traverse< A, B>(Set<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Traverse<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<TryAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryAsync<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync<Set<A>>`</returns>
        [Pure]
        public static TryAsync<Set<A>> sequence< A>(Set<TryAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> mapT< A, B>(Set<TryAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Map<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<TryAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<TryAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<TryAsync<A>> ma, Action<A> f) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<TryAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryAsync<A>> filterT< A>(Set<TryAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>
                .Inst.Bind<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).Return(a)
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryAsync<A>> plusT<NUM,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryAsync<A>> subtractT<NUM,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryAsync<A>> productT<NUM,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryAsync<A>> divideT<NUM,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryAsync<A>> appendT<SEMI,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<TryAsync<A>> x, Set<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<TryAsync<A>>`</param>
        /// <returns>`Set<TryAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryAsync<B>> applyT< A, B>(Func<A, B> fab, Set<TryAsync<A>> fa) =>
            ApplSet< TryAsync<A>, TryAsync<B>>.Inst.Apply(
                 MSet< Func<TryAsync<A>, TryAsync<B>>>.Inst.Return((TryAsync<A> a) => ApplTryAsync< A, B>.Inst.Apply(
                     MTryAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<TryAsync<A>>`</param>
        /// <param name="fb">Monad of `Set<TryAsync<A>>`</param>
        /// <returns>`Set<TryAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<TryAsync<A>> fa, Set<TryAsync<B>> fb) =>
            ApplSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>.Inst.Apply(
                MSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>.Inst.Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            ApplTryAsync< A, B, C>.Inst.Apply(
                                MTryAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<TryOption<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<TryOption<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<TryOption<A>> ma) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> bindT< A, B>(Set<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Set<B>>`</returns>
        [Pure]
        public static TryOption<Set<B>> traverse< A, B>(Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<TryOption<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOption<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption<Set<A>>`</returns>
        [Pure]
        public static TryOption<Set<A>> sequence< A>(Set<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOption<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> mapT< A, B>(Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<TryOption<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<TryOption<A>> ma, Action<A> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOption<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<TryOption<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOption<A>> filterT< A>(Set<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOption<A>> plusT<NUM,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOption<A>> subtractT<NUM,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryOption<A>> productT<NUM,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryOption<A>> divideT<NUM,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryOption<A>> appendT<SEMI,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOption<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<TryOption<A>> x, Set<TryOption<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<TryOption<A>>`</param>
        /// <returns>`Set<TryOption<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryOption<B>> applyT< A, B>(Func<A, B> fab, Set<TryOption<A>> fa) =>
            ApplSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<TryOption<A>>`</param>
        /// <param name="fb">Monad of `Set<TryOption<A>>`</param>
        /// <returns>`Set<TryOption<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryOption<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<TryOption<A>> fa, Set<TryOption<B>> fb) =>
            ApplSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class TryOptionAsyncT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<TryOptionAsync<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<TryOptionAsync<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<TryOptionAsync<A>> ma) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> bindT< A, B>(Set<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Set<B>>`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> traverse< A, B>(Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Traverse<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<TryOptionAsync<A>>`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync<Set<A>>`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> sequence< A>(Set<TryOptionAsync<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<TryOptionAsync<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> mapT< A, B>(Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Map<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<TryOptionAsync<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<TryOptionAsync<A>> ma, Action<A> f) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<TryOptionAsync<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<TryOptionAsync<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> filterT< A>(Set<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>
                .Inst.Bind<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).Return(a)
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> plusT<NUM,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> subtractT<NUM,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> productT<NUM,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> divideT<NUM,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> appendT<SEMI,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<TryOptionAsync<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<TryOptionAsync<A>>`</param>
        /// <returns>`Set<TryOptionAsync<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> applyT< A, B>(Func<A, B> fab, Set<TryOptionAsync<A>> fa) =>
            ApplSet< TryOptionAsync<A>, TryOptionAsync<B>>.Inst.Apply(
                 MSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>.Inst.Return((TryOptionAsync<A> a) => ApplTryOptionAsync< A, B>.Inst.Apply(
                     MTryOptionAsync< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<TryOptionAsync<A>>`</param>
        /// <param name="fb">Monad of `Set<TryOptionAsync<A>>`</param>
        /// <returns>`Set<TryOptionAsync<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<TryOptionAsync<A>> fa, Set<TryOptionAsync<B>> fb) =>
            ApplSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>.Inst.Apply(
                MSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>.Inst.Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            ApplTryOptionAsync< A, B, C>.Inst.Apply(
                                MTryOptionAsync< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class IEnumerableT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<IEnumerable<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<IEnumerable<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<IEnumerable<A>> ma) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> bindT< A, B>(Set<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Set<B>>`</returns>
        [Pure]
        public static IEnumerable<Set<B>> traverse< A, B>(Set<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Traverse<MSeq<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<IEnumerable<A>>`, traverses the inner
        /// values of type `A`, and returns `IEnumerable<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable<Set<A>>`</returns>
        [Pure]
        public static IEnumerable<Set<A>> sequence< A>(Set<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<IEnumerable<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> mapT< A, B>(Set<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Map<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MSeq<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<IEnumerable<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<IEnumerable<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<IEnumerable<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<IEnumerable<A>> filterT< A>(Set<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MSeq<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<IEnumerable<A>> plusT<NUM,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<IEnumerable<A>> subtractT<NUM,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> productT<NUM,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> divideT<NUM,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> appendT<SEMI,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<IEnumerable<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<IEnumerable<A>>`</param>
        /// <returns>`Set<IEnumerable<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> applyT< A, B>(Func<A, B> fab, Set<IEnumerable<A>> fa) =>
            ApplSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<IEnumerable<A>>`</param>
        /// <param name="fb">Monad of `Set<IEnumerable<A>>`</param>
        /// <returns>`Set<IEnumerable<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<IEnumerable<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<IEnumerable<A>> fa, Set<IEnumerable<B>> fb) =>
            ApplSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    public static partial class SetT
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set<Set<A>>`</returns>
        [Pure]
        public static A sumT<NumA,  A>(Set<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set<Set<A>>`</returns>
        [Pure]
        public static int countT< A>(Set<Set<A>> ma) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> bindT< A, B>(Set<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Set<B>>` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Set<B>>`</returns>
        [Pure]
        public static Set<Set<B>> traverse< A, B>(Set<Set<A>> ma, Func<A, B> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set<Set<A>>`, traverses the inner
        /// values of type `A`, and returns `Set<Set<A>>`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Set<A>>`</returns>
        [Pure]
        public static Set<Set<A>> sequence< A>(Set<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set<Set<B>>` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> mapT< A, B>(Set<Set<A>> ma, Func<A, B> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldT<S,  A>(Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S foldBackT<S,  A>(Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool existsT< A>(Set<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool forallT< A>(Set<Set<A>> ma, Func<A, bool> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set<Set<A>>`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit iterT< A>(Set<Set<A>> ma, Action<A> f) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set<Set<A>>` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set<Set<A>>` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Set<A>> filterT< A>(Set<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Set<A>> plusT<NUM,  A>(Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Set<A>> subtractT<NUM,  A>(Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Set<A>> productT<NUM,  A>(Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Set<A>> divideT<NUM,  A>(Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Set<A>> appendT<SEMI,  A>(Set<Set<A>> x, Set<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int compareT<ORD,  A>(Set<Set<A>> x, Set<Set<A>> y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set<Set<A>>` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool equalsT<EQ,  A>(Set<Set<A>> x, Set<Set<A>> y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set<Set<A>>`</param>
        /// <returns>`Set<Set<B>>` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Set<B>> applyT< A, B>(Func<A, B> fab, Set<Set<A>> fa) =>
            ApplSet< Set<A>, Set<B>>.Inst.Apply(
                 MSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set<Set<A>>`</param>
        /// <param name="fb">Monad of `Set<Set<A>>`</param>
        /// <returns>`Set<Set<B>>` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Set<C>> applyT< A, B, C>(Func<A, B, C> fabc, Set<Set<A>> fa, Set<Set<B>> fb) =>
            ApplSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
}
