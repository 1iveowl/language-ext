
        //
        // CLASS_NAME
        //

        [Pure]
        public static A sumT<NumA, GENS, A>(OUTER_A ma)
            where NumA : struct, Num<A> =>
                Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, NumA, A>.Inst.Sum(ma);

        [Pure]
        public static int countT<GENS, A>(OUTER_A ma) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>.Inst.Count(ma);

        [Pure]
        public static OUTER_B bindT<GENS, A, B>(OUTER_A ma, Func<A, INNER_B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Bind<M_OUTER_B, OUTER_B, M_INNER_B, INNER_B, B>(ma, f);

        [Pure]
        public static FLIPPED_OUTER_B traverse<GENS, A, B>(OUTER_A ma, Func<A, B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Traverse<M_FLIPPED_OUTER_B, FLIPPED_OUTER_B, M_FLIPPED_INNER_B, FLIPPED_INNER_B, B>(ma, f);

        [Pure]
        public static FLIPPED_OUTER_A sequence<GENS, A>(OUTER_A ma) =>
            ma.Traverse<GENS, A, A>(identity);

        [Pure]
        public static OUTER_B mapT<GENS, A, B>(OUTER_A ma, Func<A, B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Map<M_OUTER_B, OUTER_B, M_INNER_B, INNER_B, B>(ma, f);

        [Pure]
        public static S foldT<S, GENS, A>(OUTER_A ma, S state, Func<S, A, S> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, state, f);

        [Pure]
        public static S foldBackT<S, GENS, A>(OUTER_A ma, S state, Func<S, A, S> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.FoldBack(ma, state, f);

        [Pure]
        public static bool existsT<GENS, A>(OUTER_A ma, Func<A, bool> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        [Pure]
        public static bool forallT<GENS, A>(OUTER_A ma, Func<A, bool> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        public static Unit iterT<GENS, A>(OUTER_A ma, Action<A> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        [Pure]
        public static OUTER_A filterT<GENS, A>(OUTER_A ma, Func<A, bool> pred) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Bind<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>(ma, 
                    a => pred(a)
                        ? default(M_INNER_A).Return(a)
                        : default(M_INNER_A).Zero());

        [Pure]
        public static OUTER_A plusT<NUM, GENS, A>(OUTER_A x, OUTER_A y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Plus, x, y);

        [Pure]
        public static OUTER_A subtractT<NUM, GENS, A>(OUTER_A x, OUTER_A y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Subtract, x, y);

        [Pure]
        public static OUTER_A productT<NUM, GENS, A>(OUTER_A x, OUTER_A y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Product, x, y);

        [Pure]
        public static OUTER_A divideT<NUM, GENS, A>(OUTER_A x, OUTER_A y) where NUM : struct, Num<A> =>
            applyT(default(NUM).Divide, x, y);

        [Pure]
        public static OUTER_A appendT<SEMI, GENS, A>(OUTER_A x, OUTER_A y) where SEMI : struct, Semigroup<A> =>
            applyT(default(SEMI).Append, x, y);

        [Pure]
        public static int compareT<ORD, GENS, A>(OUTER_A x, OUTER_A y) where ORD : struct, Ord<A> =>
            applyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        [Pure]
        public static bool equalsT<EQ, GENS, A>(OUTER_A x, OUTER_A y) where EQ : struct, Eq<A> =>
            applyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        [Pure]
        public static OUTER_B applyT<GENS, A, B>(Func<A, B> fab, OUTER_A fa) =>
            APPL_INNER_AB.Inst.Apply(
                 M_INNER_FUNC_AB.Inst.Return((INNER_A a) => APPL_AB.Inst.Apply(
                     M_FUNC_AB.Inst.Return(fab), 
                     a)),
                 fa);

        [Pure]
        public static OUTER_C applyT<GENS, A, B, C>(Func<A, B, C> fabc, OUTER_A fa, OUTER_B fb) =>
            APPL_INNER_ABC.Inst.Apply(
                M_INNER_FUNC_ABC.Inst.Return(
                    (INNER_A a) =>
                        (INNER_B b) =>
                            APPL_ABC.Inst.Apply(
                                M_FUNC_ABC.Inst.Return(curry(fabc)), a, b)), fa, fb);

    