    public static class CLASS_NAME
    {
        public static A SumT<NumA, GENS, A>(this OUTER_A ma)
            where NumA : struct, Num<A> =>
                Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, NumA, A>.Inst.Sum(ma);

        public static int CountT<GENS, A>(this OUTER_A ma) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>.Inst.Count(ma);

        public static OUTER_B BindT<GENS, A, B>(this OUTER_A ma, Func<A, INNER_B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Bind<M_OUTER_B, OUTER_B, M_INNER_B, INNER_B, B>(ma, f);

        public static OUTER_B MapT<GENS, A, B>(this OUTER_A ma, Func<A, B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Map<M_OUTER_B, OUTER_B, M_INNER_B, INNER_B, B>(ma, f);

        public static bool ExistsT<GENS, A, B>(this OUTER_A ma, Func<A, bool> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        public static bool ForAllT<GENS, A, B>(this OUTER_A ma, Func<A, bool> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        public static Unit IterT<GENS, A, B>(this OUTER_A ma, Action<A> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        public static OUTER_A Lift<GENS, A>(INNER_A ma) =>
            default(M_OUTER_A).Return(ma);

        public static OUTER_A Lift<GENS, A>(A a) =>
            default(M_OUTER_A).Return(default(M_INNER_A).Return(a));

        public static OUTER_A FilterT<GENS, A>(this OUTER_A ma, Func<A, bool> pred) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Bind<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>(ma, 
                    a => pred(a)
                        ? default(M_INNER_A).Return(a)
                        : default(M_INNER_A).Zero());

        public static OUTER_A Where<GENS, A>(this OUTER_A ma, Func<A, bool> pred) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Bind<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>(ma, 
                    a => pred(a)
                        ? default(M_INNER_A).Return(a)
                        : default(M_INNER_A).Zero());

        public static OUTER_B Select<GENS, A, B>(this OUTER_A ma, Func<A, B> f) =>
            Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                .Inst.Map<M_OUTER_B, OUTER_B, M_INNER_B, INNER_B, B>(ma, f);

        public static OUTER_C SelectMany<GENS, A, B, C>(
            this OUTER_A ma,
            Func<A, INNER_B> bind,
            Func<A, B, C> project) =>
                Trans<M_OUTER_A, OUTER_A, M_INNER_A, INNER_A, A>
                    .Inst.Bind<M_OUTER_C, OUTER_C, M_INNER_C, INNER_C, C>(ma, a =>
                    {
                        var mb = bind(a);
                        return default(M_INNER_B).Bind<M_INNER_C, INNER_C, C>(mb, b => default(M_INNER_C).Return(project(a, b)));
                    });
    } 